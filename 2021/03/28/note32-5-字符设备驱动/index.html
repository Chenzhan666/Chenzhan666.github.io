<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>note32.5-字符设备驱动 | CHENZHAN</title><meta name="keywords" content="驱动开发"><meta name="author" content="Chenzhan666"><meta name="copyright" content="Chenzhan666"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="字符设备驱动开发框架简介字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节 流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI， LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动 Linux 下的应用程序是如何调用驱动程序的，Linux 应用程序对驱动程序的调用？    open()、close()、read(">
<meta property="og:type" content="article">
<meta property="og:title" content="note32.5-字符设备驱动">
<meta property="og:url" content="https://www.chenzhan.club/2021/03/28/note32-5-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/index.html">
<meta property="og:site_name" content="CHENZHAN">
<meta property="og:description" content="字符设备驱动开发框架简介字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节 流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI， LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动 Linux 下的应用程序是如何调用驱动程序的，Linux 应用程序对驱动程序的调用？    open()、close()、read(">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i0.hdslb.com/bfs/article/75769bed78f538cd7890ba1931904cf4662ef7d7.jpg@1320w_742h.webp">
<meta property="article:published_time" content="2021-03-28T13:14:49.000Z">
<meta property="article:modified_time" content="2021-04-12T15:12:46.398Z">
<meta property="article:author" content="Chenzhan666">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i0.hdslb.com/bfs/article/75769bed78f538cd7890ba1931904cf4662ef7d7.jpg@1320w_742h.webp"><link rel="shortcut icon" href="/Chenzhan666.github.io/img/favicon.png"><link rel="canonical" href="https://www.chenzhan.club/2021/03/28/note32-5-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Chenzhan666.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Chenzhan666.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-12 23:12:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/Chenzhan666.github.io/atom.xml" title="CHENZHAN" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/Chenzhan666.github.io/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/Chenzhan666.github.io/archives/"><div class="headline">文章</div><div class="length-num">36</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/Chenzhan666.github.io/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i0.hdslb.com/bfs/article/75769bed78f538cd7890ba1931904cf4662ef7d7.jpg@1320w_742h.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/Chenzhan666.github.io/">CHENZHAN</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">note32.5-字符设备驱动</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-28T13:14:49.000Z" title="发表于 2021-03-28 21:14:49">2021-03-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-12T15:12:46.398Z" title="更新于 2021-04-12 23:12:46">2021-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="note32.5-字符设备驱动"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer">

<h1 id="字符设备驱动开发框架"><a href="#字符设备驱动开发框架" class="headerlink" title="字符设备驱动开发框架"></a>字符设备驱动开发框架</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节 流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI， LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动</p>
<p><strong><em>Linux 下的应用程序是如何调用驱动程序的，Linux 应用程序对驱动程序的调用？</em></strong></p>
<table>
<thead>
<tr>
<th>open()、close()、read()、write()等其他API函数</th>
<th>应用程序</th>
</tr>
</thead>
<tbody><tr>
<td>对应的库函数</td>
<td>库</td>
</tr>
<tr>
<td>通过系统调用进入内核</td>
<td>内核</td>
</tr>
<tr>
<td>驱动程序中的open()、close()、read()、release()等函数</td>
<td>驱动程序</td>
</tr>
<tr>
<td>具体硬件设备</td>
<td>硬件</td>
</tr>
</tbody></table>
<p> <em>Linux 应用程序对驱动程序的调用流程</em></p>
<p>Linux 中一切皆为文件，驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应 用程序通过对这个名为“/dev/xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实 现对硬件的操作</p>
<blockquote>
<p>例如：有个叫做/dev/led 的驱动文件，此文件是 led 灯的驱动文件。应用程序使用 open 函数来打开文件/dev/led，使用完成以后使用 close 函数关闭/dev/led 这个文件。open 和 close 就是打开和关闭 led 驱动的函数，如果要点亮或关闭 led，那么就使用 write 函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开 led 的控制参数。如果要获取 led 灯的状态，就用 read 函数从驱动中读取相应的状态</p>
</blockquote>
<p>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间</p>
<p>当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开/dev/led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作</p>
<p>open、close、write 和 read 等这些函 数是由 C 库提供的，在 Linux 系统中，系统调用作为 C 库的一部分</p>
<p><strong><em>当我们调用 open 函数的 时候流程如下：</em></strong></p>
<table>
<thead>
<tr>
<th>应用程序</th>
<th>C库</th>
<th>内核</th>
<th>具体驱动</th>
</tr>
</thead>
<tbody><tr>
<td>应用调用open()</td>
<td>C库中的open()函数</td>
<td>open()系统调用</td>
<td>驱动的open()函数</td>
</tr>
</tbody></table>
<p><em>open 函数调用流程</em></p>
<p>应用程序使用到的函数在具体驱动程序中都有与之对应的函数， 比如应用程序中调用了 open 这个函数，那么在驱动程序中也得有一个名为 open 的函数</p>
<p>每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 include/linux/fs.h 中 有个叫做 file_operations 的结构体，此结构体就是 Linux 内核驱动操作函数集合</p>
<p><strong><em>file_operation 结构体中比较重要的、常用的函数：</em></strong></p>
<table>
<thead>
<tr>
<th>owner</th>
<th>拥有该结构体的模块的指针，一般设置为 THIS_MODULE</th>
</tr>
</thead>
<tbody><tr>
<td>llseek 函数</td>
<td>用于修改文件当前的读写位置</td>
</tr>
<tr>
<td>read 函数</td>
<td>用于读取设备文件</td>
</tr>
<tr>
<td>write 函数</td>
<td>用于向设备文件写入(发送)数据</td>
</tr>
<tr>
<td>poll 是个轮询函数</td>
<td>用于查询设备是否可以进行非阻塞的读写</td>
</tr>
<tr>
<td>unlocked_ioctl 函数</td>
<td>提供对于设备的控制功能，在 32 位的系统上运行 32 位的应用程序调用的是 unlocked_ioctl</td>
</tr>
<tr>
<td>compat_ioctl 函数</td>
<td>与 unlocked_ioctl 函数功能一样，在 64 位系统上运行 32 位的应用程序调用使用此函数</td>
</tr>
<tr>
<td>mmap 函数</td>
<td>用于将将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应 用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制</td>
</tr>
<tr>
<td>open 函数</td>
<td>用于打开设备文件</td>
</tr>
<tr>
<td>release 函数</td>
<td>用于释放(关闭)设备文件，与应用程序中的 close 函数对应</td>
</tr>
<tr>
<td>fasync 函数</td>
<td>用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中</td>
</tr>
<tr>
<td>aio_fsync 函数</td>
<td>与 fasync 函数的功能类似，只是 aio_fsync 是异步刷新待处理的 数据</td>
</tr>
</tbody></table>
<h2 id="字符设备驱动开发步骤"><a href="#字符设备驱动开发步骤" class="headerlink" title="字符设备驱动开发步骤"></a>字符设备驱动开发步骤</h2><p>Linux驱动程序可以编译到kernel里面，也就是zImage，也可以编译为模块，.ko。测试的时候只需要加载.ko模块就可以s</p>
<p>sudo fdisk -l 查看那个设备即 /dev/sdb1</p>
<h3 id="驱动模块的加载和卸载"><a href="#驱动模块的加载和卸载" class="headerlink" title="驱动模块的加载和卸载"></a>驱动模块的加载和卸载</h3><p>Linux 驱动有两种运行方式，第一种就是将驱动编译进 Linux 内核中，这样当 Linux 内核启 动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)，在 Linux 内核启动以后使用“insmod”命令加载驱动模块</p>
<p>在调试驱动的时候一般都选择将其编译 为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。 而且在调试的时候只需要加载或者卸载驱动模块即可</p>
<p>模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和 卸载注册函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(xxx_init); &#x2F;&#x2F;注册模块加载函数</span><br><span class="line">module_exit(xxx_exit); &#x2F;&#x2F;注册模块卸载函数</span><br></pre></td></tr></table></figure>
<p>module_init 函数用来向 Linux 内核注册一个模块加载函数，参数 xxx_init 就是需要注册的具体函数，当使用<strong>“insmod”</strong>命令加载驱动的时候，xxx_init 这个函数就会被调用。module_exit() 函数用来向 Linux 内核注册一个模块卸载函数，参数 xxx_exit 就是需要注册的具体函数，当使用<strong>“rmmod”</strong>命令卸载具体驱动的时候 xxx_exit 函数就会被调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* 入口函数具体内容 *&#x2F;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动出口函数 *&#x2F;</span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* 出口函数具体内容 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 将上面两个函数指定为驱动的入口和出口函数 *&#x2F;</span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure>
<p><em>字符设备驱动模块加载和卸载函数模板</em></p>
<p>驱动编译完成以后扩展名为.ko，有两种命令可以加载驱动模块：insmod和 modprobe，insmod 是最简单的模块加载命令，此命令用于加载指定的.ko 模块</p>
<p>加载 drv.ko 这个驱动模块：<strong>insmod</strong> drv.ko</p>
<p>insmod 命令不能解决模块的依赖关系，比如 drv.ko 依赖 first.ko 这个模块，就必须先使用 insmod 命令加载 first.ko 这个模块，然后再加载 drv.ko 这个模块。modprobe 会分析模块的依赖关系，然后会将所有的依赖模块都加载到内核中</p>
<p>卸载 drv.ko：<strong>rmmod</strong> drv.ko</p>
<p>或者 <strong>modprobe -r</strong> drv.ko</p>
<p>推荐：<strong>加载使用 modprobe 卸载使用 rmmod</strong></p>
<h3 id="字符设备注册与注销"><a href="#字符设备注册与注销" class="headerlink" title="字符设备注册与注销"></a>字符设备注册与注销</h3><p>对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模 块的时候也需要注销掉字符设备。字符设备的注册和注销函数原型如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static inline int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)</span><br><span class="line">static inline void unregister_chrdev(unsigned int major, const char *name)</span><br></pre></td></tr></table></figure>
<p><strong>register_chrdev 函数用于注册字符设备：</strong></p>
<p>major：主设备号，Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两 部分</p>
<p>name：设备名字，指向一串字符串</p>
<p>fops：结构体 file_operations 类型指针，指向设备的操作函数集合变量</p>
<p><strong>unregister_chrdev 函数用户注销字符设备：</strong></p>
<p>major：要注销的设备对应的主设备号</p>
<p>name：要注销的设备对应的设备名</p>
<p>一般字符设备的注册在驱动模块的入口函数 xxx_init 中进行，字符设备的注销在驱动模块 的出口函数 xxx_exit 中进行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static struct file_operations test_fops;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 入口函数具体内容 *&#x2F;</span><br><span class="line">int retvalue &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* 注册字符设备驱动 *&#x2F;</span><br><span class="line">retvalue &#x3D; register_chrdev(200, &quot;chrtest&quot;, &amp;test_fops);</span><br><span class="line">if(retvalue &lt; 0)&#123;</span><br><span class="line">&#x2F;* 字符设备注册失败,自行处理 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动出口函数 *&#x2F;</span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 注销字符设备驱动 *&#x2F;</span><br><span class="line">unregister_chrdev(200, &quot;chrtest&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 将上面两个函数指定为驱动的入口和出口函数 *&#x2F;</span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure>
<p>定义了一个 file_operations 结构体变量 test_fops，test_fops 就是设备的操作函数集 合</p>
<p>调用函数 register_chrdev 注册字符设备，主设备号为 200，设备名字为“chrtest”， 设备操作函数集合就是第 1 行定义的 test_fops</p>
<p>选择没有被使用的主设备号，输入命令<strong>“cat /proc/devices”</strong>可以查看当前已经被使用掉的设备号</p>
<h3 id="实现设备的具体操作函数"><a href="#实现设备的具体操作函数" class="headerlink" title="实现设备的具体操作函数"></a>实现设备的具体操作函数</h3><p>file_operations 结构体就是设备的具体操作函数</p>
<p>初始化其中的open、 release、read 和 write 等具体的设备操作函数</p>
<p>对chrtest设备的基本要求：</p>
<p>能够对 chrtest 进行打开和关闭操作</p>
<p>需要实现 file_operations 中的 **open **和 **release **这两个函数</p>
<p>对 chrtest 进行读写操作</p>
<p>假设 chrtest 这个设备控制着一段缓冲区(内存)，应用程序需要通过 read 和 write 这两个函 数对 chrtest 的缓冲区进行读写操作。所以需要实现 file_operations 中的 <strong>read</strong> 和 <strong>write</strong>这两个函 数</p>
<p>根据需求，修改上述代码，加入test_fops 这个结构体的初始化操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 打开设备 *&#x2F;</span><br><span class="line">static int chrtest_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 用户实现具体功能 *&#x2F;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 从设备读取 *&#x2F;</span><br><span class="line">static ssize_t chrtest_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#x2F;* 向设备写数据 *&#x2F;</span><br><span class="line">static ssize_t chrtest_write(struct file *filp,const char __user *buf,size_t cnt, loff_t *offt)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#x2F;* 关闭&#x2F;释放设备 *&#x2F;</span><br><span class="line">static int chrtest_release(struct inode *inode, struct file *filp)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">static struct file_operations test_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE, </span><br><span class="line">.open &#x3D; chrtest_open,</span><br><span class="line">.read &#x3D; chrtest_read,</span><br><span class="line">.write &#x3D; chrtest_write,</span><br><span class="line">.release &#x3D; chrtest_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="添加-LICENSE-和作者信息"><a href="#添加-LICENSE-和作者信息" class="headerlink" title="添加 LICENSE 和作者信息"></a>添加 LICENSE 和作者信息</h3><p>MODULE_LICENSE() //添加模块 LICENSE 信息 </p>
<p>MODULE_AUTHOR() //添加模块作者信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;chenzhan&quot;);</span><br></pre></td></tr></table></figure>
<p>LICENSE 采用 GPL 协议</p>
<h2 id="Linux-设备号"><a href="#Linux-设备号" class="headerlink" title="Linux 设备号"></a>Linux 设备号</h2><h3 id="设备号的组成"><a href="#设备号的组成" class="headerlink" title="设备号的组成"></a>设备号的组成</h3><p>Linux 中每个设备都有一个设备号，设备号由主设备号和次设备号两部分 组成，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备</p>
<p>Linux 提供了 一个名为 dev_t 的数据类型表示设备号，dev_t 定义在文件 include/linux/types.h 里面</p>
<p>可以看出 dev_t 是__ u32 类型的，而 __u32 定义在文件 include/uapi/asm-generic/int-ll64.h 里</p>
<p>dev_t 其实就是 unsigned int 类型，是一个 32 位的数据类型。32 位的数据构成了主设备号和次设备号两部分，其中高 12 位为主设备号，低 20 位为次设备号。因此 Linux 系统中主设备号范围为 0~4095，在选择主设备号的时候一定不要超过这个范围</p>
<p>include/linux/kdev_t.h 中提供了几个关于设备号的操作函数(本质是宏)</p>
<h3 id="设备号的分配"><a href="#设备号的分配" class="headerlink" title="设备号的分配"></a>设备号的分配</h3><h4 id="静态分配设备号"><a href="#静态分配设备号" class="headerlink" title="静态分配设备号"></a>静态分配设备号</h4><p>使用“cat /proc/devices”命令即可查看当前系统中所有已经使用了的设备号</p>
<h4 id="动态分配设备号"><a href="#动态分配设备号" class="headerlink" title="动态分配设备号"></a>动态分配设备号</h4><p>Linux 社区推荐使用动态分配设备号，在注册字 符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。 卸载驱动的时候释放掉这个设备号即可，设备号的申请函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)</span><br></pre></td></tr></table></figure>
<p><strong>函数 alloc_chrdev_region 用于申请设备号</strong></p>
<p>dev：保存申请到的设备号</p>
<p>baseminor：次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这 些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递 增。一般 baseminor 为 0，也就是说次设备号从 0 开始</p>
<p>count：要申请的设备号数量</p>
<p>name：设备名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void unregister_chrdev_region(dev_t from, unsigned count)</span><br></pre></td></tr></table></figure>
<p>注销字符设备之后要释放掉设备号，设备号释放函数如下：</p>
<p>from：要释放的设备号</p>
<p>count：表示从 from 开始，要释放的设备号数量</p>
<h2 id="chrdevbase-字符设备驱动开发实验"><a href="#chrdevbase-字符设备驱动开发实验" class="headerlink" title="chrdevbase 字符设备驱动开发实验"></a>chrdevbase 字符设备驱动开发实验</h2><p>chrdevbase 是引入的一个虚拟设备。chrdevbase 设备有两个缓冲区，一个为读缓冲 区，一个为写缓冲区，这两个缓冲区的大小都为 100 字节</p>
<p>printk 可以根据日志级别对消息进行分类，一共有 8 个消息级 别，这 8 个消息级别定义在文件 include/linux/kern_levels.h 里</p>
<p>一共定义了 8 个级别，其中 0 的优先级最高，7 的优先级最低。如果要设置消息级别，参 考如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_EMERG &quot;gsmi: Log Shutdown Reason\n&quot;);</span><br></pre></td></tr></table></figure>
<p>上述代码就是设置“gsmi: Log Shutdown Reason\n”这行消息的级别为 KERN_EMERG。在 具体的消息前面加上 KERN_EMERG 就可以将这条消息的级别设置为 KERN_EMERG</p>
<p>如果使用 printk 的 时 候 不 显 式 的 设 置 消 息 级 别 ， 那 么 printk 将 会 采 用 默 认 级 别 MESSAGE_LOGLEVEL_DEFAULT，MESSAGE_LOGLEVEL_DEFAULT 默认为 4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define KERN_SOH &quot;\001&quot;</span><br><span class="line">#define KERN_EMERG KERN_SOH &quot;0&quot; &#x2F;* 紧急事件，一般是内核崩溃 *&#x2F;</span><br><span class="line">#define KERN_ALERT KERN_SOH &quot;1&quot; &#x2F;* 必须立即采取行动 *&#x2F;</span><br><span class="line">#define KERN_CRIT KERN_SOH &quot;2&quot; &#x2F;* 临界条件，比如严重的软件或硬件错误*&#x2F;</span><br><span class="line">#define KERN_ERR KERN_SOH &quot;3&quot; &#x2F;* 错误状态，一般设备驱动程序中使用</span><br><span class="line">KERN_ERR 报告硬件错误 *&#x2F;</span><br><span class="line">#define KERN_WARNING KERN_SOH &quot;4&quot; &#x2F;* 警告信息，不会对系统造成严重影响 *&#x2F;</span><br><span class="line">#define KERN_NOTICE KERN_SOH &quot;5&quot; &#x2F;* 有必要进行提示的一些信息 *&#x2F;</span><br><span class="line">#define KERN_INFO KERN_SOH &quot;6&quot; &#x2F;* 提示性的信息 *&#x2F;</span><br><span class="line">#define KERN_DEBUG KERN_SOH &quot;7&quot; &#x2F;* 调试信息 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>在 include/linux/printk.h 中有个宏 CONSOLE_LOGLEVEL_DEFAULT，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CONSOLE_LOGLEVEL_DEFAULT 7 </span><br></pre></td></tr></table></figure>
<p>CONSOLE_LOGLEVEL_DEFAULT 控制着哪些级别的消息可以显示在控制台上，此宏默认 为 7，意味着只有优先级高于 7 的消息才能显示在控制台上。 这个就是 printk 和 printf 的最大区别，可以通过消息级别来决定哪些消息可以显示在控制 台上。默认消息级别为 4，4 的级别比 7 高，所示直接使用 printk 输出的信息是可以显示在控制 台上的</p>
<p>参数 filp 有个叫做 private_data 的成员变量，private_data 是个 void 指针，一般在驱动中将 private_data 指向设备结构体，设备结构体会存放设备的一些属性</p>
<p>chrdevbase_read 函数，应用程序调用 read 函数从设备中读取数据的时候此函数会执行。参数 buf 是用户空间的内存，读取到的数据存储在 buf 中，参数 cnt 是要读取的字节数，参数 offt 是相对于文件首地址的偏移，kerneldata 里面保存着用户空间要读取的数据，先将 kerneldata 数组中的数据拷贝到读缓冲区 readbuf 中，通过函数 copy_to_user 将 readbuf 中的数据复制到参数 buf 中。因为内核空间不能直接操作用户空间的内存，因此需要借 助 copy_to_user 函数来完成内核空间的数据到用户空间的复制。copy_to_user 函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline long copy_to_user(void __user *to, const void *from, unsigned long n)</span><br></pre></td></tr></table></figure>
<p>参数 to 表示目的，参数 from 表示源，参数 n 表示要复制的数据长度。如果复制成功，返 回值为 0，如果复制失败则返回负数</p>
<p>chrdevbase_write 函数，应用程序调用 write 函数向设备写数据的时候此函数 就会执行。参数 buf 就是应用程序要写入设备的数据，也是用户空间的内存，参数 cnt 是要写入 的数据长度，参数 offt 是相对文件首地址的偏移。通过函数 copy_from_user 将 buf 中的 数据复制到写缓冲区 writebuf 中，因为用户空间内存不能直接访问内核空间的内存，需要借助函数 copy_from_user 将用户空间的数据复制到 writebuf 这个内核空间中</p>
<p>chrdevbase_release 函数，应用程序调用 close 关闭设备文件的时候此函数会 执行，一般会在此函数里面执行一些释放操作。如果在 open 函数中设置了 filp 的 private_data 成员变量指向设备结构体，那么在 release 函数最终就要释放掉</p>
<p>memcpy函数语法</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *destin, void *source, unsigned n);</span><br></pre></td></tr></table></figure>
<p>参数</p>
<p>destin– 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</p>
<p>source– 指向要复制的数据源，类型强制转换为 void* 指针</p>
<p>n– 要被复制的字节数</p>
<p>返回值</p>
<p>该函数返回一个指向目标存储区destin的指针</p>
<p>功能</p>
<p>从源source所指的内存地址的起始位置开始拷贝n个字节到目标destin所指的内存地址的起始位置中</p>
<p>所需头文件</p>
<p>C语言：#include&lt;string.h&gt;        C++：#include<cstring></cstring></p>
<h2 id="编写测试-APP"><a href="#编写测试-APP" class="headerlink" title="编写测试 APP"></a>编写测试 APP</h2><h3 id="C-库文件操作基本函数"><a href="#C-库文件操作基本函数" class="headerlink" title="C 库文件操作基本函数"></a>C 库文件操作基本函数</h3><h4 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h4><p>int open(const char *pathname, int flags)</p>
<p>pathname：要打开的设备或者文件名</p>
<p>flags：文件打开模式，以下三种模式必选其一： </p>
<p>O_RDONLY 只读模式 </p>
<p>O_WRONLY 只写模式 </p>
<p>O_RDWR 读写模式</p>
<p>除了上述三种 模式以外还有其他的可选模式，通过逻辑或来选择多种模式</p>
<p>返回值：如果文件打开成功的话返回文件的文件描述符</p>
<p>在 Ubuntu 中输入“man 2 open”即可查看 open 函数的详细内容</p>
<h4 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h4><p>ssize_t read(int fd, void *buf, size_t count)</p>
<p>fd：要读取的文件描述符，读取文件之前要先用 open 函数打开文件，open 函数打开文件成 功以后会得到文件描述符</p>
<p>buf：数据读取到此 buf 中</p>
<p>count：要读取的数据长度，也就是字节数</p>
<p>返回值：读取成功的话返回读取到的字节数；如果返回 0 表示读取到了文件末尾；如果返 回负值，表示读取失败。在 Ubuntu 中输入“man 2 read”命令即可查看 read 函数的详细内容</p>
<h4 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a>write 函数</h4><p>ssize_t write(int fd, const void *buf, size_t count);</p>
<p>fd：要进行写操作的文件描述符，写文件之前要先用 open 函数打开文件，open 函数打开文 件成功以后会得到文件描述符</p>
<p>buf：要写入的数据</p>
<p>count：要写入的数据长度，也就是字节数 </p>
<p>返回值：写入成功的话返回写入的字节数；如果返回 0 表示没有写入任何数据；如果返回负值，表示写入失败</p>
<h4 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h4><p>int close(int fd);</p>
<p>fd：要关闭的文件描述符</p>
<p>返回值：0 表示关闭成功，负值表示关闭失败</p>
<h3 id="编译驱动程序"><a href="#编译驱动程序" class="headerlink" title="编译驱动程序"></a>编译驱动程序</h3><p>需要将其编译为.ko 模块，创建 Makefile 文件</p>
<p>Makefile：</p>
<p>KERNELDIR 表示开发板所使用的 Linux 内核源码目录，使用绝对路径，根据实际情况填写</p>
<p>CURRENT_PATH 表示当前路径，直接通过运行“pwd”命令来获取当前所处路 径</p>
<p>obj-m 表示将 chrdevbase.c 这个文件编译为 chrdevbase.ko 模块</p>
<p>具体的编译命令，后面的 modules 表示编译模块，-C 表示将当前的工作目录切换到指定目录中，也就是 KERNERLDIR 目录。M 表示模块源码目录，“make modules”命令 中加入 M=dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件</p>
<p>使用 arm-linux-gnueabihf-gcc 来编译， 输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc chrdevbaseApp.c -o chrdevbaseApp</span><br></pre></td></tr></table></figure>
<p>编译完成以后会生成一个叫做 chrdevbaseApp 的可执行程序，输入如下命令查看 chrdevbaseAPP 这个程序的文件信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file chrdevbaseApp</span><br></pre></td></tr></table></figure>
<p>输入如下命令加载 chrdevbase.ko 驱动文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insmod chrdevbase.ko</span><br><span class="line">或</span><br><span class="line">modprobe chrdevbase.ko</span><br></pre></td></tr></table></figure>
<p>modprobe 提示无法打开“modules.dep”这个文件，因此驱动挂载 失败了。我们不用手动创建 modules.dep 这个文件，直接输入 depmod 命令即可自动生成 modules.dep，有些根文件系统可能没有 depmod 这个命令，如果没有这个命令就只能重新配置 busybox，使能此命令，然后重新编译 busybox。输入“depmod”命令以后会自动生成 modules.alias、 modules.symbols 和 modules.dep 这三个文件</p>
<p>输入“lsmod”命令即可查看当前系统中存在的模块</p>
<p>输入如下命令查看当前 系统中有没有 chrdevbase 这个设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;devices</span><br></pre></td></tr></table></figure>
<p>驱动加载成功需要在/dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操 作这个设备节点文件来完成对具体设备的操作。输入如下命令创建/dev/chrdevbase 这个设备节 点文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod &#x2F;dev&#x2F;chrdevbase c 200 0</span><br></pre></td></tr></table></figure>
<p>其中“mknod”是创建节点命令，“/dev/chrdevbase”是要创建的节点文件，“c”表示这是个字符设备，“200”是设备的主设备号，“0”是设备的次设备号。创建完成以后就会存在 /dev/chrdevbase 这个文件，可以使用“ls /dev/chrdevbase -l”命令查看</p>
<p>如果 chrdevbaseAPP 想要读写 chrdevbase 设备，直接对/dev/chrdevbase 进行读写操作即可。 相当于/dev/chrdevbase 这个文件是 chrdevbase 设备在用户空间中的实现</p>
<p>输入如下命令卸载掉 chrdevbase 这 个设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmmod chrdevbase.ko</span><br></pre></td></tr></table></figure>


<blockquote>
<p>驱动给应用传递数据的时候需要用到copy_to_user函数</p>
<p>memcpy () 把一段内存(kerneldata)拷贝到另一段内存(readbuf)去,拷贝长度sizeof(kerneldata)</p>
<p>用户空间内存不能直接访问内核空间的内存，需要借助函数copy_from_user</p>
<p>./chrdevbaseAPP &lt; filename &gt; &lt;1 : 2&gt; 1表示读，2表示写</p>
<p>./chrdevbaseAPP /dev/chrdevbase 1 表示从驱动里面读数据</p>
<p>&lt; filename &gt; 即驱动文件</p>
<p>1是字符串，需要转变成数字1，通过函数atoi ()  </p>
</blockquote>
<hr>
<p>参考资料：正点原子</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Chenzhan666</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.chenzhan.club/2021/03/28/note32-5-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">https://www.chenzhan.club/2021/03/28/note32-5-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.chenzhan.club" target="_blank">CHENZHAN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Chenzhan666.github.io/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a></div><div class="post_share"><div class="social-share" data-image="https://i0.hdslb.com/bfs/article/75769bed78f538cd7890ba1931904cf4662ef7d7.jpg@1320w_742h.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Chenzhan666.github.io/2021/03/31/note33-5-LED%E9%A9%B1%E5%8A%A8/"><img class="prev-cover" src="https://i0.hdslb.com/bfs/article/b03d90a0505947ddf8c3384eaf3c751f06930f47.jpg@1320w_990h.webp" onerror="onerror=null;src='/Chenzhan666.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">note33.5-LED驱动</div></div></a></div><div class="next-post pull-right"><a href="/Chenzhan666.github.io/2021/03/27/note31-4-rootfs%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><img class="next-cover" src="https://i0.hdslb.com/bfs/album/70f78b669890b61676ae026d8035d7ca62a9743e.jpg@518w.webp" onerror="onerror=null;src='/Chenzhan666.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">note31.4-rootfs根文件系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Chenzhan666.github.io/2021/03/31/note33-5-LED驱动/" title="note33.5-LED驱动"><img class="cover" src="https://i0.hdslb.com/bfs/article/b03d90a0505947ddf8c3384eaf3c751f06930f47.jpg@1320w_990h.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-31</div><div class="title">note33.5-LED驱动</div></div></a></div><div><a href="/Chenzhan666.github.io/2021/04/12/note34-5-设备树/" title="note34.5-设备树"><img class="cover" src="https://i0.hdslb.com/bfs/article/94d982713d5da4c87565e163d86eaefe81ff5225.jpg@1320w_742h.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-12</div><div class="title">note34.5-设备树</div></div></a></div><div><a href="/Chenzhan666.github.io/2021/04/23/note36-5-并发与竞争/" title="note36.5-并发与竞争"><img class="cover" src="https://i0.hdslb.com/bfs/album/1d7758160e0870422e75cdb2d166d75eeaa3cd2e.jpg@518w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-23</div><div class="title">note36.5-并发与竞争</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/Chenzhan666.github.io/null" onerror="this.onerror=null;this.src='/Chenzhan666.github.io/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Chenzhan666</div><div class="author-info__description">演好你的剧本( ´･ω･)ﾉ(._.`)</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/Chenzhan666.github.io/archives/"><div class="headline">文章</div><div class="length-num">36</div></a></div><div class="card-info-data-item is-center"><a href="/Chenzhan666.github.io/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">字符设备驱动开发框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.</span> <span class="toc-text">字符设备驱动开发步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">驱动模块的加载和卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B3%A8%E9%94%80"><span class="toc-number">1.2.2.</span> <span class="toc-text">字符设备注册与注销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%AE%BE%E5%A4%87%E7%9A%84%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">实现设备的具体操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-LICENSE-%E5%92%8C%E4%BD%9C%E8%80%85%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">添加 LICENSE 和作者信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">1.3.</span> <span class="toc-text">Linux 设备号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%8F%B7%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">设备号的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%8F%B7%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-number">1.3.2.</span> <span class="toc-text">设备号的分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">静态分配设备号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">动态分配设备号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chrdevbase-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.4.</span> <span class="toc-text">chrdevbase 字符设备驱动开发实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95-APP"><span class="toc-number">1.5.</span> <span class="toc-text">编写测试 APP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%BA%93%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">C 库文件操作基本函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#open-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">open 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">read 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">write 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#close-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">close 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">编译驱动程序</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Chenzhan666.github.io/2021/04/23/note36-5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" title="note36.5-并发与竞争"><img src="https://i0.hdslb.com/bfs/album/1d7758160e0870422e75cdb2d166d75eeaa3cd2e.jpg@518w.webp" onerror="this.onerror=null;this.src='/Chenzhan666.github.io/img/404.jpg'" alt="note36.5-并发与竞争"/></a><div class="content"><a class="title" href="/Chenzhan666.github.io/2021/04/23/note36-5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" title="note36.5-并发与竞争">note36.5-并发与竞争</a><time datetime="2021-04-22T17:13:25.000Z" title="发表于 2021-04-23 01:13:25">2021-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Chenzhan666.github.io/2021/04/12/note35-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/" title="note35.3-数据结构绪论"><img src="https://i0.hdslb.com/bfs/article/9a3b32d2ff5b616b0344818cad02e8ba499f6606.jpg@1320w_826h.webp" onerror="this.onerror=null;this.src='/Chenzhan666.github.io/img/404.jpg'" alt="note35.3-数据结构绪论"/></a><div class="content"><a class="title" href="/Chenzhan666.github.io/2021/04/12/note35-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/" title="note35.3-数据结构绪论">note35.3-数据结构绪论</a><time datetime="2021-04-12T13:14:03.000Z" title="发表于 2021-04-12 21:14:03">2021-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Chenzhan666.github.io/2021/04/12/note34-5-%E8%AE%BE%E5%A4%87%E6%A0%91/" title="note34.5-设备树"><img src="https://i0.hdslb.com/bfs/article/94d982713d5da4c87565e163d86eaefe81ff5225.jpg@1320w_742h.webp" onerror="this.onerror=null;this.src='/Chenzhan666.github.io/img/404.jpg'" alt="note34.5-设备树"/></a><div class="content"><a class="title" href="/Chenzhan666.github.io/2021/04/12/note34-5-%E8%AE%BE%E5%A4%87%E6%A0%91/" title="note34.5-设备树">note34.5-设备树</a><time datetime="2021-04-12T13:13:46.000Z" title="发表于 2021-04-12 21:13:46">2021-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Chenzhan666.github.io/2021/03/31/note33-5-LED%E9%A9%B1%E5%8A%A8/" title="note33.5-LED驱动"><img src="https://i0.hdslb.com/bfs/article/b03d90a0505947ddf8c3384eaf3c751f06930f47.jpg@1320w_990h.webp" onerror="this.onerror=null;this.src='/Chenzhan666.github.io/img/404.jpg'" alt="note33.5-LED驱动"/></a><div class="content"><a class="title" href="/Chenzhan666.github.io/2021/03/31/note33-5-LED%E9%A9%B1%E5%8A%A8/" title="note33.5-LED驱动">note33.5-LED驱动</a><time datetime="2021-03-31T13:17:02.000Z" title="发表于 2021-03-31 21:17:02">2021-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Chenzhan666.github.io/2021/03/28/note32-5-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" title="note32.5-字符设备驱动"><img src="https://i0.hdslb.com/bfs/article/75769bed78f538cd7890ba1931904cf4662ef7d7.jpg@1320w_742h.webp" onerror="this.onerror=null;this.src='/Chenzhan666.github.io/img/404.jpg'" alt="note32.5-字符设备驱动"/></a><div class="content"><a class="title" href="/Chenzhan666.github.io/2021/03/28/note32-5-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" title="note32.5-字符设备驱动">note32.5-字符设备驱动</a><time datetime="2021-03-28T13:14:49.000Z" title="发表于 2021-03-28 21:14:49">2021-03-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Chenzhan666</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/Chenzhan666.github.io/js/utils.js"></script><script src="/Chenzhan666.github.io/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/Chenzhan666.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/Chenzhan666.github.io/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>