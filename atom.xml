<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHENZHAN</title>
  
  <subtitle>CHENZHAN</subtitle>
  <link href="https://www.chenzhan.club/atom.xml" rel="self"/>
  
  <link href="https://www.chenzhan.club/"/>
  <updated>2021-04-22T17:28:46.019Z</updated>
  <id>https://www.chenzhan.club/</id>
  
  <author>
    <name>Chenzhan666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>note36.5-并发与竞争</title>
    <link href="https://www.chenzhan.club/2021/04/23/note36-5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/"/>
    <id>https://www.chenzhan.club/2021/04/23/note36-5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/</id>
    <published>2021-04-22T17:13:25.000Z</published>
    <updated>2021-04-22T17:28:46.019Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>a = 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldr r0, &#x3D;0X30000000 &#x2F;* 变量 a 地址 *&#x2F;</span><br><span class="line">ldr r1, &#x3D; 3 &#x2F;* 要写入的值 *&#x2F;</span><br><span class="line">str r1, [r0] &#x2F;* 将 3 写入到 a 变量中 *&#x2F;</span><br></pre></td></tr></table></figure></blockquote><h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a><strong>原子操作</strong></h1><h2 id="API-函数"><a href="#API-函数" class="headerlink" title="API 函数"></a><strong>API</strong> <strong>函数</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">int counter;</span><br><span class="line">&#125; atomic_t;</span><br><span class="line"></span><br><span class="line">atomic_t a; &#x2F;&#x2F;定义 a</span><br><span class="line"></span><br><span class="line">atomic_t b &#x3D; ATOMIC_INIT(0); &#x2F;&#x2F;定义原子变量 b 并赋初值为 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原子变量和 API 函数使用</span><br><span class="line"></span><br><span class="line">atomic_t v &#x3D; ATOMIC_INIT(0); &#x2F;* 定义并初始化原子变零 v&#x3D;0 *&#x2F;</span><br><span class="line"></span><br><span class="line">atomic_set(10); &#x2F;* 设置 v&#x3D;10 *&#x2F;</span><br><span class="line">atomic_read(&amp;v); &#x2F;* 读取 v 的值，肯定是 10 *&#x2F;</span><br><span class="line">atomic_inc(&amp;v); &#x2F;* v 的值加 1，v&#x3D;11 *&#x2F;</span><br></pre></td></tr></table></figure><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h1><p>自旋锁适用于短时期的轻量级加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct spinlock &#123;</span><br><span class="line">union &#123;</span><br><span class="line">struct raw_spinlock rlock;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line"># define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span><br><span class="line">struct &#123;</span><br><span class="line">u8 __padding[LOCK_PADSIZE];</span><br><span class="line">struct lockdep_map dep_map;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line">&#125; spinlock_t;</span><br><span class="line"></span><br><span class="line">spinlock_t lock; &#x2F;&#x2F;定义自旋锁</span><br></pre></td></tr></table></figure><p>自旋锁API函数适用于SMP或支持抢占的单CPU下线程之间的并发访问，也就是用于线程与线程之间，被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数，否则的话会可能会导致死锁现象的发生。自旋锁会自动禁止抢占</p><p>中断里面可以使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要先禁止本地中断(也就是本 CPU 中断，对于多核 SOC来说会有多个 CPU 核)</p><p>建议使用 spin_lock_irqsave/spin_unlock_irqrestore，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。一般在线程中使用 spin_lock_irqsave/spin_unlock_irqrestore，在中断中使用 spin_lock/spin_unlock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">自旋锁使用示例</span><br><span class="line"></span><br><span class="line">DEFINE_SPINLOCK(lock) &#x2F;* 定义并初始化一个锁 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 线程 A *&#x2F;</span><br><span class="line">void functionA ()&#123;</span><br><span class="line">unsigned long flags; &#x2F;* 中断状态 *&#x2F;</span><br><span class="line">spin_lock_irqsave(&amp;lock, flags) &#x2F;* 获取锁 *&#x2F;</span><br><span class="line">&#x2F;* 临界区 *&#x2F;</span><br><span class="line">spin_unlock_irqrestore(&amp;lock, flags) &#x2F;* 释放锁 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中断服务函数 *&#x2F;</span><br><span class="line">void irq() &#123;</span><br><span class="line">spin_lock(&amp;lock) &#x2F;* 获取锁 *&#x2F;</span><br><span class="line">&#x2F;* 临界区 *&#x2F;</span><br><span class="line">spin_unlock(&amp;lock) &#x2F;* 释放锁 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><strong>信号量</strong></h1><ol><li>信号量可以使线程进入休眠状态,因此适用于那些占用资源比较久的场合</li><li>信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠</li><li>如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct semaphore &#123;</span><br><span class="line"> raw_spinlock_t lock;</span><br><span class="line"> unsigned int count;</span><br><span class="line"> struct list_head wait_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">信号量使用示例</span><br><span class="line"></span><br><span class="line">struct semaphore sem; &#x2F;* 定义信号量 *&#x2F;</span><br><span class="line"></span><br><span class="line">sema_init(&amp;sem, 1)； &#x2F;* 初始化信号量 *&#x2F;</span><br><span class="line"></span><br><span class="line">down(&amp;sem); &#x2F;* 申请信号量 *&#x2F;</span><br><span class="line">&#x2F;* 临界区 *&#x2F;</span><br><span class="line">up(&amp;sem); &#x2F;* 释放信号量 *&#x2F;</span><br></pre></td></tr></table></figure><h1 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a><strong>互斥体</strong></h1><p>互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥体。在我们编写 Linux 驱动的时候遇到需要互斥访问的地方建议使用 mutex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct mutex &#123;</span><br><span class="line"> &#x2F;* 1: unlocked, 0: locked, negative: locked, possible waiters *&#x2F;</span><br><span class="line"> atomic_t count;</span><br><span class="line"> spinlock_t wait_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>mutex 可以导致休眠，因此不能在中断中使用 mutex，中断中只能使用自旋锁</li><li>和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数</li><li>因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">互斥体使用示例</span><br><span class="line"></span><br><span class="line">struct mutex lock; &#x2F;* 定义一个互斥体 *&#x2F;</span><br><span class="line">mutex_init(&amp;lock); &#x2F;* 初始化互斥体 *&#x2F;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;lock); &#x2F;* 上锁 *&#x2F;</span><br><span class="line">&#x2F;* 临界区 *&#x2F;</span><br><span class="line">mutex_unlock(&amp;lock); &#x2F;* 解锁 *&#x2F;</span><br></pre></td></tr></table></figure><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;a = 3&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    
    <category term="驱动开发" scheme="https://www.chenzhan.club/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>note35.3-数据结构绪论</title>
    <link href="https://www.chenzhan.club/2021/04/12/note35-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
    <id>https://www.chenzhan.club/2021/04/12/note35-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/</id>
    <published>2021-04-12T13:14:03.000Z</published>
    <updated>2021-04-12T15:12:16.211Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>数据</strong>：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号的集合</p><p>包括整型、实型等数值类型，字符、声音、图像、视频等非数值类型</p><p><strong>数据元素</strong>：是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录</p><p><strong>数据项</strong>：一个数据元素可以由若干个数据项组成</p><p>是数据项不可分割的最小单位</p><p><strong>数据对象</strong>：是性质相同的数据元素的集合，是数据的子集</p><p><strong>数据结构</strong>：是相互之间存在的一种或多种特定关系的数据元素的集合</p><p><strong>逻辑结构</strong>;是指数据对象中数据元素之间的相互关系</p><p>分为以下几种:</p><p><strong>集合结构</strong>:集合结构中的数据元素除了同属于一个集合外，之间没有其他关系</p><p><strong>线性结构</strong>：数据元素之间是一对一的关系</p><p><strong>树形结构</strong>：数据元素之间存在一对一的层次关系</p><p><strong>图形关系</strong>：数据元素是多对多关系</p><p><strong>物理结构（存储结构）</strong>：数据的逻辑结构在计算机中的存储形式</p><p>主要是对内存来说，对硬盘等外存来说是文件结构</p><p>形式有两种：</p><p><strong>迅速存储结构</strong>：数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的</p><p><strong>链式存储结构</strong>：把数据元素存放在任意的存储单元里，这组存储单位可以是连续的也可以是不连续的</p><p>逻辑结构是面向问题的</p><p><strong>抽象数据类型</strong>：体现了程序设计中问题分解、抽象和信息隐藏的特性</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</p><p><strong>基本特性</strong>：输入、输出、有穷性、确定性和可行性</p><p>算法设计要求：</p><p>确定性</p><p>可读性</p><p><strong>健壮性</strong>：当输入数据不合法时，算法也能做出相关处理，而不是产生异常和莫名的的结果</p><p>尽量满足时间效率和存储量低的需求</p><p>事前分析估算方法：在计算机编制前，依据统计方法对算法进行估算</p><p><strong>函数的渐近增长</strong>：给定两个函数f（n）g（n），如果存在一个整数N，使得对于所有的n&gt;N，f（n）总是比g（n）大，那么我们说f（n）的增长渐进快于g（n）</p><p><strong>算法时间复杂读</strong>：大<strong>O</strong>记法</p><p>随着n的增大，T（n）增长最慢的算法为最优算法</p><p>O（1）常数阶O（n）线性阶O（n2）平方阶</p><p><strong>推导大O阶的方法</strong></p><p>步骤：<br>1.分析代码片段的执行次数<br>2.得到执行次数的函数F(n)=1+n+n²=n(1+n)/2=3/2n²+3/2n+1<br>3.用常数取代运行时间中的所有加法常数——————————-&gt;得到F(n)=An²+An+1(A为常数）<br>4.在修改后的运行次数函数中，只保留最高阶项———————-&gt;得到F(n)=An²<br>5.如果最高阶项存在且不是1，则去除与这个项相乘的常数——–&gt;最高阶项存在，不是1，去掉常数A<br>最终得到O(n)=n²,时间复杂度为n²</p><p>先要得到执行次数的函数，再求Ｏ(n)</p><p>时间复杂程度：</p><p>O（1）&lt;O（logn)&lt;O（n）&lt;O（nlogn)&lt;O（n2）&lt;O（n3）&lt;O（2n）&lt;O(n!)&lt;O（nn）；</p><p>对数阶、循环嵌套、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i,j;</span><br><span class="line">for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(j&#x3D;i;j&lt;n;j++)&#x2F;* 主要j&#x3D;i而不是0 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 时间复杂度为O（1）的程序步骤序列 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*当i&#x3D;0，内循环执行n次，当i&#x3D;1，执行n-1</span><br><span class="line"> *n+（n-1）+...+1&#x3D;n*n&#x2F;2+n&#x2F;2</span><br><span class="line"> *O(n*n)</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p>如果内循环是O（n），外循环执行了m次，那么时间复杂度就是O（m*n）</p><p><strong>最坏情况</strong>：是一种运行时间的保证，就是运行时间内不会再坏了，重要的需求，除非特别指定，我们提到的运行时间都是最坏情况的运行时间</p><p>平均运行时间复杂度、最坏时间复杂度</p><p><strong>算法空间复杂度</strong></p><hr><p>参考资料：大话数据结构</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;数据&lt;/stro</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://www.chenzhan.club/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>note34.5-设备树</title>
    <link href="https://www.chenzhan.club/2021/04/12/note34-5-%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
    <id>https://www.chenzhan.club/2021/04/12/note34-5-%E8%AE%BE%E5%A4%87%E6%A0%91/</id>
    <published>2021-04-12T13:13:46.000Z</published>
    <updated>2021-04-12T15:13:24.903Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h1><ol><li>uboot启动内核用到zImage，imx6ull-alientek-emmc.dtb。bootz 80800000 – 83000000.</li><li>设备树：设备和树</li><li>在单片机驱动里面比如W25QXX，SPI，速度都是在.c文件里面写死。板级信息都写到.c里面，导致linux内核臃肿。因此将板子信息做成独立的格式，文件扩展名为.dts。一个平台或者机器对应一个.dts</li></ol><h1 id="DTS、DTB和DTC的关系"><a href="#DTS、DTB和DTC的关系" class="headerlink" title="DTS、DTB和DTC的关系"></a>DTS、DTB和DTC的关系</h1><p>.dts相当于.c，就是DTS源码文件</p><p>DTC工具相当于gcc编译器，将.dts编译成.dtb</p><p>.dtb相当于bin文件，或可执行文件</p><p>通过make dtbs编译所有的dts文件。如果要编译指定的dtbs</p><p>make imx6ull-alientek-emmc.dtb</p><h1 id="DTS基本语法"><a href="#DTS基本语法" class="headerlink" title="DTS基本语法"></a>DTS基本语法</h1><ol><li>设备树也有头文件，扩展名为.dtsi。可以将一款SOC他的其他所有设备/平台的共有的信息提出来，作为一个通用的.dtsi文件</li><li>DTS也是’/’开始</li><li>从/根节点开始描述设备信息</li><li>在/根节点外有一些&amp;cpu0这样的语句是“追加“</li><li>节点名字，完整的要求</li></ol><p><strong>node-name@unit-address</strong></p><p>unit-address一般都是外设寄存器的起始地址，有时候是I2C的设备地址，或者其他含义，具体节点具体分析。设备树里面常常遇到如下所示节点名字：</p><p><strong>intc: interrupt-controller@00a01000</strong></p><p>:前面是标签label，后面才是名字。intc，完整的名字是interrupt-controller@00a01000。&amp;intc</p><h1 id="设备树在系统中的体现"><a href="#设备树在系统中的体现" class="headerlink" title="设备树在系统中的体现"></a>设备树在系统中的体现</h1><p>系统启动以后可以在根文件系统里面看到设备树的节点信息。在/proc/device-tree/目录下存放着设备树信息</p><p>内核启动的时候会解析设备树，然后在/proc/device-tree/目录下呈现出来</p><h1 id="特殊节点"><a href="#特殊节点" class="headerlink" title="特殊节点"></a>特殊节点</h1><ol><li>aliases</li><li>chosen节点，主要目的就是将uboot里面bootargs环境变量值，传递给Linux内核作为命令行参数cmd line</li></ol><p><strong><em>uboot里面bootargs值为：</em></strong></p><p>bootargs=console=ttymxc0,115200 rw root=/dev/nfs nfsroot=192.168.1.249:/home/zzk/linux/nfs/rootfs ip=192.168.1.50:192.168.1.249:192.168.1.1:255.255.255.0::eth0:off</p><p><strong><em>linux内核cmdline值为：</em></strong></p><p> Kernel command line: console=ttymxc0,115200 rw root=/dev/nfs nfsroot=192.168.1.249:/home/zzk/linux/nfs/rootfs ip=192.168.1.50:192.168.1.249:192.168.1.1:255.255.255.0::eth0:off</p><p><strong><em>uboot是如何向kernel传递bootargs</em></strong></p><p>经过查看发现chosen节点中包含bootargs属性，属性值和uboot的bootargs一致</p><p>uboot接触过dtb，最终通过bootz 80800000 – 83000000 来启动内核。经过分析判断uboot拥有bootargs环境变量和dtb，因此最有可能</p><p>最终发现在uboot的fdt_chosen函数中会查找chosen节点，并且在里面添加bootargs属性，属性值为bootargs变量值</p><h1 id="特殊的属性"><a href="#特殊的属性" class="headerlink" title="特殊的属性"></a>特殊的属性</h1><p>compatible属性，值是字符串</p><p>根节点/下面的compatible。内核启动的时候会检查是否支持此平台，或机器</p><p>不使用设备树的时候通过machine id来判断内核是否支持此机器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#define MACHINE_START(_type,_name)         \</span><br><span class="line">static const struct machine_desc __mach_desc_##_type \</span><br><span class="line"> __used                      \</span><br><span class="line"> __attribute__((__section__(&quot;.arch.info.init&quot;))) &#x3D; &#123; \</span><br><span class="line">.nr     &#x3D; MACH_TYPE_##_type,      \</span><br><span class="line">    .name      &#x3D; _name,</span><br><span class="line"></span><br><span class="line">#define MACHINE_END              \</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MACHINE_START(MX35_3DS, &quot;Freescale MX35PDK&quot;)</span><br><span class="line">    &#x2F;* Maintainer: Freescale Semiconductor, Inc *&#x2F;</span><br><span class="line">    .atag_offset &#x3D; 0x100,</span><br><span class="line">    .map_io &#x3D; mx35_map_io,</span><br><span class="line">    .init_early &#x3D; imx35_init_early,</span><br><span class="line">    .init_irq &#x3D; mx35_init_irq,</span><br><span class="line">    .init_time &#x3D; mx35pdk_timer_init,</span><br><span class="line">    .init_machine &#x3D; mx35_3ds_init,</span><br><span class="line">    .reserve &#x3D; mx35_3ds_reserve,</span><br><span class="line">    .restart  &#x3D; mxc_restart,</span><br><span class="line">MACHINE_END</span><br></pre></td></tr></table></figure><p>​    展开以后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static const struct machine_desc __mach_desc_MX35_3DS __used                  </span><br><span class="line"> __attribute__((__section__(&quot;.arch.info.init&quot;))) &#x3D; &#123; </span><br><span class="line">    .nr     &#x3D; MACH_TYPE_MX35_3DS,          &#x2F;&#x2F;机器ID  </span><br><span class="line">    .name   &#x3D; &quot;Freescale MX35PDK&quot;,</span><br><span class="line">    .atag_offset &#x3D; 0x100,</span><br><span class="line">    .map_io &#x3D; mx35_map_io,</span><br><span class="line">    .init_early &#x3D; imx35_init_early,</span><br><span class="line">    .init_irq &#x3D; mx35_init_irq,</span><br><span class="line">    .init_time &#x3D; mx35pdk_timer_init,</span><br><span class="line">    .init_machine &#x3D; mx35_3ds_init,</span><br><span class="line">    .reserve &#x3D; mx35_3ds_reserve,</span><br><span class="line">    .restart  &#x3D; mxc_restart,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用设备树的时候不使用机器ID，而是使用根节点/下的compatible</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define DT_MACHINE_START(_name, _namestr)      \</span><br><span class="line">static const struct machine_desc __mach_desc_##_name \</span><br><span class="line"> __used                      \</span><br><span class="line"> __attribute__((__section__(&quot;.arch.info.init&quot;))) &#x3D; &#123; \</span><br><span class="line">    .nr     &#x3D; ~0,             \</span><br><span class="line">    .name      &#x3D; _namestr,</span><br><span class="line"></span><br><span class="line">DT_MACHINE_START(IMX6UL, &quot;Freescale i.MX6 Ultralite (Device Tree)&quot;)</span><br><span class="line">    .map_io     &#x3D; imx6ul_map_io,</span><br><span class="line">    .init_irq  &#x3D; imx6ul_init_irq,</span><br><span class="line">    .init_machine &#x3D; imx6ul_init_machine,</span><br><span class="line">    .init_late &#x3D; imx6ul_init_late,</span><br><span class="line">    .dt_compat  &#x3D; imx6ul_dt_compat,</span><br><span class="line">MACHINE_END</span><br></pre></td></tr></table></figure><p>展开以后就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> static const struct machine_desc __mach_desc_IMX6UL __used                 </span><br><span class="line"> __attribute__((__section__(&quot;.arch.info.init&quot;))) &#x3D; &#123; </span><br><span class="line">    .nr     &#x3D; ~0,           </span><br><span class="line">    .name      &#x3D; &quot;Freescale i.MX6 Ultralite (Device Tree)&quot;,</span><br><span class="line">    .map_io     &#x3D; imx6ul_map_io,</span><br><span class="line">    .init_irq  &#x3D; imx6ul_init_irq,</span><br><span class="line">    .init_machine &#x3D; imx6ul_init_machine,</span><br><span class="line">    .init_late &#x3D; imx6ul_init_late,</span><br><span class="line">    .dt_compat  &#x3D; imx6ul_dt_compat,</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h1 id="Linux内核的OF操作函数"><a href="#Linux内核的OF操作函数" class="headerlink" title="Linux内核的OF操作函数"></a>Linux内核的OF操作函数</h1><ol><li>驱动如何获取到设备树中节点信息。在驱动中使用OF函数获取设备树属性内容</li><li>驱动要想获取到设备树节点内容，首先要找到节点。</li></ol><h1 id="设备树LED驱动"><a href="#设备树LED驱动" class="headerlink" title="设备树LED驱动"></a>设备树LED驱动</h1><p>修改设备树文件</p><p>设备节点最好添加到好区分的地方，1级节点是最好的地方</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;设备树&quot;&gt;&lt;a href=&quot;#设备树&quot; class=&quot;headerlink&quot; title=&quot;设备树&quot;&gt;&lt;/a&gt;设备树&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;uboot启动内核用到zIm</summary>
      
    
    
    
    
    <category term="驱动开发" scheme="https://www.chenzhan.club/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>note33.5-LED驱动</title>
    <link href="https://www.chenzhan.club/2021/03/31/note33-5-LED%E9%A9%B1%E5%8A%A8/"/>
    <id>https://www.chenzhan.club/2021/03/31/note33-5-LED%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-03-31T13:17:02.000Z</published>
    <updated>2021-04-12T15:13:06.146Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p><strong>bit操作</strong></p><p>val &amp;= ~(3&lt;&lt;26) ;</p><p>即 val = val &amp; ~(3&lt;&lt;26);</p><p>将 3=0011 左移到26位(以32位系统为例)，使得26、27位强制变为1，28、29为0，其余不变，接着取非，使得，26、27位为0，28、29位为1，其余取非，接着与原val进行‘与’，在其余位中，原本为1的，与0’与‘得0，原本为0的，与1‘与’得0，同时，28、29位与原来‘与’得0，另外，26、27位原来是0的，与1’与‘得0，原来是1的，与1’与‘得1，保存不变，即上述操作清零(初始化)了26、27之外的其他位并保存了26、27位不变</p><p>val |= 3 &lt;&lt; 26;</p><p>即 val = val | (3&lt;&lt;26)</p><p>同上，26、27位强制变为1，28、29为0，其余不变继续为0，使得bit26、bit27置1</p></blockquote><h1 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h1><p>MMU 全称叫做 Memory  Manage Unit，也就是内存管理单元</p><p>MMU 主要完成的功能如下：</p><ol><li>完成虚拟空间到物理空间的映射</li><li>内存保护，设置存储器的访问权限，设置虚拟存储空间的缓冲特性</li></ol><p>虚拟空间到物理空间的映射，也叫做地址映射</p><p>虚拟地址(VA,Virtual Address)、物理地址(PA，PhyscicalAddress)。对于 32 位 的处理器来说，虚拟地址范围是 2^32=4GB，开发板上有 512MB 的 DDR3，这 512MB 的内存就是物理内存，经过 MMU 可以将其映射到整个 4GB 的虚拟空间</p><p>Linux 内核启动的时候会初始化 MMU，设置好内存映射，设置好以后 CPU 访问的都是虚拟地址</p><p>开启 了 MMU，并且设置了内存映射，因此就不能直接向 0X020E0068 这个地址写入数据了。我们必 须得到 0X020E0068 这个物理地址在 Linux 系统里面对应的虚拟地址，这里就涉及到了物理内 存和虚拟内存之间的转换，需要用到两个函数：ioremap 和 iounmap</p><p>ioremap 函 数 用 于 获 取 指 定 物 理 地 址 空 间 对 应 的 虚 拟 地 址 空 间 ， 定 义 在 arch/arm/include/asm/io.h 文件中，是个宏，有两个参数：cookie 和 size，真正起作用的是函数__arm_ioremap，此函数有三个参数和一个返回值</p><p>phys_addr：要映射给的物理起始地址</p><p>size：要映射的内存空间大小</p><p>mtype：ioremap 的类型，可以选择 MT_DEVICE、MT_DEVICE_NONSHARED、 MT_DEVICE_CACHED 和 MT_DEVICE_WC，ioremap 函数选择 MT_DEVICE</p><p>返回值：__iomem 类型的指针，指向映射后的虚拟空间首地址</p><blockquote><p>假如我们要获取 I.MX6ULL 的 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 寄存器对应 的虚拟地址，使用如下代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SW_MUX_GPIO1_IO03_BASE (0X020E0068)</span><br><span class="line">static void __iomem* SW_MUX_GPIO1_IO03;</span><br><span class="line">SW_MUX_GPIO1_IO03 &#x3D; ioremap(SW_MUX_GPIO1_IO03_BASE, 4);</span><br></pre></td></tr></table></figure><p>宏 SW_MUX_GPIO1_IO03_BASE 是寄存器物理地址，SW_MUX_GPIO1_IO03 是映射后 的虚拟地址。对于 I.MX6ULL 来说一个寄存器是 4 字节(32 位)的，因此映射的内存长度为 4。 映射完成以后直接对 SW_MUX_GPIO1_IO03 进行读写操作即可</p></blockquote><p>卸载驱动的时候需要使用 iounmap 函数释放掉 ioremap 函数所做的映射，iounmap 函数原 型如下：</p><p>void iounmap (volatile void __iomem *addr)</p><p>iounmap 只有一个参数 addr，此参数就是要取消映射的虚拟地址空间首地址。假如我们现 在要取消掉 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 寄存器的地址映射，使用如下代码 即可：</p><h3 id="LED灯字符设备驱动框架搭建"><a href="#LED灯字符设备驱动框架搭建" class="headerlink" title="LED灯字符设备驱动框架搭建"></a>LED灯字符设备驱动框架搭建</h3><p>uboot下载系统失败，以前都能成功，突然不能下载怎么解决？</p><p>保证正个网段内开发板的IP地址和ubuntu的IP地址是唯一的，测试哪个IP地址有冲突，比如ubuntu的192.168.1.66有被其他设备占用，如果有占用就改一个没被占用的IP地址，即更换 ubuntu 地址</p><h3 id="驱动程序编写、测试"><a href="#驱动程序编写、测试" class="headerlink" title="驱动程序编写、测试"></a>驱动程序编写、测试</h3><p>初始化时钟、IO、GPIO等等</p><p>加载驱动、创建设备节点、mknod /dev/led c 249 0</p><h1 id="新字符设备驱动"><a href="#新字符设备驱动" class="headerlink" title="新字符设备驱动"></a>新字符设备驱动</h1><p>自动创建设备节点</p><p>……</p><p>文件私有数据</p><p>……</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;bit操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;val &amp;amp;= ~(3&amp;lt;&amp;lt;26) ;&lt;/p&gt;
&lt;p&gt;即 val = val &amp;</summary>
      
    
    
    
    
    <category term="驱动开发" scheme="https://www.chenzhan.club/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>note32.5-字符设备驱动</title>
    <link href="https://www.chenzhan.club/2021/03/28/note32-5-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <id>https://www.chenzhan.club/2021/03/28/note32-5-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-03-28T13:14:49.000Z</published>
    <updated>2021-04-12T15:12:46.398Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="字符设备驱动开发框架"><a href="#字符设备驱动开发框架" class="headerlink" title="字符设备驱动开发框架"></a>字符设备驱动开发框架</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节 流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI， LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动</p><p><strong><em>Linux 下的应用程序是如何调用驱动程序的，Linux 应用程序对驱动程序的调用？</em></strong></p><table><thead><tr><th>open()、close()、read()、write()等其他API函数</th><th>应用程序</th></tr></thead><tbody><tr><td>对应的库函数</td><td>库</td></tr><tr><td>通过系统调用进入内核</td><td>内核</td></tr><tr><td>驱动程序中的open()、close()、read()、release()等函数</td><td>驱动程序</td></tr><tr><td>具体硬件设备</td><td>硬件</td></tr></tbody></table><p> <em>Linux 应用程序对驱动程序的调用流程</em></p><p>Linux 中一切皆为文件，驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应 用程序通过对这个名为“/dev/xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实 现对硬件的操作</p><blockquote><p>例如：有个叫做/dev/led 的驱动文件，此文件是 led 灯的驱动文件。应用程序使用 open 函数来打开文件/dev/led，使用完成以后使用 close 函数关闭/dev/led 这个文件。open 和 close 就是打开和关闭 led 驱动的函数，如果要点亮或关闭 led，那么就使用 write 函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开 led 的控制参数。如果要获取 led 灯的状态，就用 read 函数从驱动中读取相应的状态</p></blockquote><p>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间</p><p>当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开/dev/led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作</p><p>open、close、write 和 read 等这些函 数是由 C 库提供的，在 Linux 系统中，系统调用作为 C 库的一部分</p><p><strong><em>当我们调用 open 函数的 时候流程如下：</em></strong></p><table><thead><tr><th>应用程序</th><th>C库</th><th>内核</th><th>具体驱动</th></tr></thead><tbody><tr><td>应用调用open()</td><td>C库中的open()函数</td><td>open()系统调用</td><td>驱动的open()函数</td></tr></tbody></table><p><em>open 函数调用流程</em></p><p>应用程序使用到的函数在具体驱动程序中都有与之对应的函数， 比如应用程序中调用了 open 这个函数，那么在驱动程序中也得有一个名为 open 的函数</p><p>每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 include/linux/fs.h 中 有个叫做 file_operations 的结构体，此结构体就是 Linux 内核驱动操作函数集合</p><p><strong><em>file_operation 结构体中比较重要的、常用的函数：</em></strong></p><table><thead><tr><th>owner</th><th>拥有该结构体的模块的指针，一般设置为 THIS_MODULE</th></tr></thead><tbody><tr><td>llseek 函数</td><td>用于修改文件当前的读写位置</td></tr><tr><td>read 函数</td><td>用于读取设备文件</td></tr><tr><td>write 函数</td><td>用于向设备文件写入(发送)数据</td></tr><tr><td>poll 是个轮询函数</td><td>用于查询设备是否可以进行非阻塞的读写</td></tr><tr><td>unlocked_ioctl 函数</td><td>提供对于设备的控制功能，在 32 位的系统上运行 32 位的应用程序调用的是 unlocked_ioctl</td></tr><tr><td>compat_ioctl 函数</td><td>与 unlocked_ioctl 函数功能一样，在 64 位系统上运行 32 位的应用程序调用使用此函数</td></tr><tr><td>mmap 函数</td><td>用于将将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应 用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制</td></tr><tr><td>open 函数</td><td>用于打开设备文件</td></tr><tr><td>release 函数</td><td>用于释放(关闭)设备文件，与应用程序中的 close 函数对应</td></tr><tr><td>fasync 函数</td><td>用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中</td></tr><tr><td>aio_fsync 函数</td><td>与 fasync 函数的功能类似，只是 aio_fsync 是异步刷新待处理的 数据</td></tr></tbody></table><h2 id="字符设备驱动开发步骤"><a href="#字符设备驱动开发步骤" class="headerlink" title="字符设备驱动开发步骤"></a>字符设备驱动开发步骤</h2><p>Linux驱动程序可以编译到kernel里面，也就是zImage，也可以编译为模块，.ko。测试的时候只需要加载.ko模块就可以s</p><p>sudo fdisk -l 查看那个设备即 /dev/sdb1</p><h3 id="驱动模块的加载和卸载"><a href="#驱动模块的加载和卸载" class="headerlink" title="驱动模块的加载和卸载"></a>驱动模块的加载和卸载</h3><p>Linux 驱动有两种运行方式，第一种就是将驱动编译进 Linux 内核中，这样当 Linux 内核启 动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)，在 Linux 内核启动以后使用“insmod”命令加载驱动模块</p><p>在调试驱动的时候一般都选择将其编译 为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。 而且在调试的时候只需要加载或者卸载驱动模块即可</p><p>模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和 卸载注册函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(xxx_init); &#x2F;&#x2F;注册模块加载函数</span><br><span class="line">module_exit(xxx_exit); &#x2F;&#x2F;注册模块卸载函数</span><br></pre></td></tr></table></figure><p>module_init 函数用来向 Linux 内核注册一个模块加载函数，参数 xxx_init 就是需要注册的具体函数，当使用<strong>“insmod”</strong>命令加载驱动的时候，xxx_init 这个函数就会被调用。module_exit() 函数用来向 Linux 内核注册一个模块卸载函数，参数 xxx_exit 就是需要注册的具体函数，当使用<strong>“rmmod”</strong>命令卸载具体驱动的时候 xxx_exit 函数就会被调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 入口函数具体内容 *&#x2F;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动出口函数 *&#x2F;</span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 出口函数具体内容 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 将上面两个函数指定为驱动的入口和出口函数 *&#x2F;</span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure><p><em>字符设备驱动模块加载和卸载函数模板</em></p><p>驱动编译完成以后扩展名为.ko，有两种命令可以加载驱动模块：insmod和 modprobe，insmod 是最简单的模块加载命令，此命令用于加载指定的.ko 模块</p><p>加载 drv.ko 这个驱动模块：<strong>insmod</strong> drv.ko</p><p>insmod 命令不能解决模块的依赖关系，比如 drv.ko 依赖 first.ko 这个模块，就必须先使用 insmod 命令加载 first.ko 这个模块，然后再加载 drv.ko 这个模块。modprobe 会分析模块的依赖关系，然后会将所有的依赖模块都加载到内核中</p><p>卸载 drv.ko：<strong>rmmod</strong> drv.ko</p><p>或者 <strong>modprobe -r</strong> drv.ko</p><p>推荐：<strong>加载使用 modprobe 卸载使用 rmmod</strong></p><h3 id="字符设备注册与注销"><a href="#字符设备注册与注销" class="headerlink" title="字符设备注册与注销"></a>字符设备注册与注销</h3><p>对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模 块的时候也需要注销掉字符设备。字符设备的注册和注销函数原型如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static inline int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)</span><br><span class="line">static inline void unregister_chrdev(unsigned int major, const char *name)</span><br></pre></td></tr></table></figure><p><strong>register_chrdev 函数用于注册字符设备：</strong></p><p>major：主设备号，Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两 部分</p><p>name：设备名字，指向一串字符串</p><p>fops：结构体 file_operations 类型指针，指向设备的操作函数集合变量</p><p><strong>unregister_chrdev 函数用户注销字符设备：</strong></p><p>major：要注销的设备对应的主设备号</p><p>name：要注销的设备对应的设备名</p><p>一般字符设备的注册在驱动模块的入口函数 xxx_init 中进行，字符设备的注销在驱动模块 的出口函数 xxx_exit 中进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static struct file_operations test_fops;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 入口函数具体内容 *&#x2F;</span><br><span class="line">int retvalue &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* 注册字符设备驱动 *&#x2F;</span><br><span class="line">retvalue &#x3D; register_chrdev(200, &quot;chrtest&quot;, &amp;test_fops);</span><br><span class="line">if(retvalue &lt; 0)&#123;</span><br><span class="line">&#x2F;* 字符设备注册失败,自行处理 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动出口函数 *&#x2F;</span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 注销字符设备驱动 *&#x2F;</span><br><span class="line">unregister_chrdev(200, &quot;chrtest&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 将上面两个函数指定为驱动的入口和出口函数 *&#x2F;</span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure><p>定义了一个 file_operations 结构体变量 test_fops，test_fops 就是设备的操作函数集 合</p><p>调用函数 register_chrdev 注册字符设备，主设备号为 200，设备名字为“chrtest”， 设备操作函数集合就是第 1 行定义的 test_fops</p><p>选择没有被使用的主设备号，输入命令<strong>“cat /proc/devices”</strong>可以查看当前已经被使用掉的设备号</p><h3 id="实现设备的具体操作函数"><a href="#实现设备的具体操作函数" class="headerlink" title="实现设备的具体操作函数"></a>实现设备的具体操作函数</h3><p>file_operations 结构体就是设备的具体操作函数</p><p>初始化其中的open、 release、read 和 write 等具体的设备操作函数</p><p>对chrtest设备的基本要求：</p><p>能够对 chrtest 进行打开和关闭操作</p><p>需要实现 file_operations 中的 **open **和 **release **这两个函数</p><p>对 chrtest 进行读写操作</p><p>假设 chrtest 这个设备控制着一段缓冲区(内存)，应用程序需要通过 read 和 write 这两个函 数对 chrtest 的缓冲区进行读写操作。所以需要实现 file_operations 中的 <strong>read</strong> 和 <strong>write</strong>这两个函 数</p><p>根据需求，修改上述代码，加入test_fops 这个结构体的初始化操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 打开设备 *&#x2F;</span><br><span class="line">static int chrtest_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 用户实现具体功能 *&#x2F;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 从设备读取 *&#x2F;</span><br><span class="line">static ssize_t chrtest_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#x2F;* 向设备写数据 *&#x2F;</span><br><span class="line">static ssize_t chrtest_write(struct file *filp,const char __user *buf,size_t cnt, loff_t *offt)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#x2F;* 关闭&#x2F;释放设备 *&#x2F;</span><br><span class="line">static int chrtest_release(struct inode *inode, struct file *filp)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">static struct file_operations test_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE, </span><br><span class="line">.open &#x3D; chrtest_open,</span><br><span class="line">.read &#x3D; chrtest_read,</span><br><span class="line">.write &#x3D; chrtest_write,</span><br><span class="line">.release &#x3D; chrtest_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="添加-LICENSE-和作者信息"><a href="#添加-LICENSE-和作者信息" class="headerlink" title="添加 LICENSE 和作者信息"></a>添加 LICENSE 和作者信息</h3><p>MODULE_LICENSE() //添加模块 LICENSE 信息 </p><p>MODULE_AUTHOR() //添加模块作者信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;chenzhan&quot;);</span><br></pre></td></tr></table></figure><p>LICENSE 采用 GPL 协议</p><h2 id="Linux-设备号"><a href="#Linux-设备号" class="headerlink" title="Linux 设备号"></a>Linux 设备号</h2><h3 id="设备号的组成"><a href="#设备号的组成" class="headerlink" title="设备号的组成"></a>设备号的组成</h3><p>Linux 中每个设备都有一个设备号，设备号由主设备号和次设备号两部分 组成，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备</p><p>Linux 提供了 一个名为 dev_t 的数据类型表示设备号，dev_t 定义在文件 include/linux/types.h 里面</p><p>可以看出 dev_t 是__ u32 类型的，而 __u32 定义在文件 include/uapi/asm-generic/int-ll64.h 里</p><p>dev_t 其实就是 unsigned int 类型，是一个 32 位的数据类型。32 位的数据构成了主设备号和次设备号两部分，其中高 12 位为主设备号，低 20 位为次设备号。因此 Linux 系统中主设备号范围为 0~4095，在选择主设备号的时候一定不要超过这个范围</p><p>include/linux/kdev_t.h 中提供了几个关于设备号的操作函数(本质是宏)</p><h3 id="设备号的分配"><a href="#设备号的分配" class="headerlink" title="设备号的分配"></a>设备号的分配</h3><h4 id="静态分配设备号"><a href="#静态分配设备号" class="headerlink" title="静态分配设备号"></a>静态分配设备号</h4><p>使用“cat /proc/devices”命令即可查看当前系统中所有已经使用了的设备号</p><h4 id="动态分配设备号"><a href="#动态分配设备号" class="headerlink" title="动态分配设备号"></a>动态分配设备号</h4><p>Linux 社区推荐使用动态分配设备号，在注册字 符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。 卸载驱动的时候释放掉这个设备号即可，设备号的申请函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)</span><br></pre></td></tr></table></figure><p><strong>函数 alloc_chrdev_region 用于申请设备号</strong></p><p>dev：保存申请到的设备号</p><p>baseminor：次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这 些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递 增。一般 baseminor 为 0，也就是说次设备号从 0 开始</p><p>count：要申请的设备号数量</p><p>name：设备名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void unregister_chrdev_region(dev_t from, unsigned count)</span><br></pre></td></tr></table></figure><p>注销字符设备之后要释放掉设备号，设备号释放函数如下：</p><p>from：要释放的设备号</p><p>count：表示从 from 开始，要释放的设备号数量</p><h2 id="chrdevbase-字符设备驱动开发实验"><a href="#chrdevbase-字符设备驱动开发实验" class="headerlink" title="chrdevbase 字符设备驱动开发实验"></a>chrdevbase 字符设备驱动开发实验</h2><p>chrdevbase 是引入的一个虚拟设备。chrdevbase 设备有两个缓冲区，一个为读缓冲 区，一个为写缓冲区，这两个缓冲区的大小都为 100 字节</p><p>printk 可以根据日志级别对消息进行分类，一共有 8 个消息级 别，这 8 个消息级别定义在文件 include/linux/kern_levels.h 里</p><p>一共定义了 8 个级别，其中 0 的优先级最高，7 的优先级最低。如果要设置消息级别，参 考如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_EMERG &quot;gsmi: Log Shutdown Reason\n&quot;);</span><br></pre></td></tr></table></figure><p>上述代码就是设置“gsmi: Log Shutdown Reason\n”这行消息的级别为 KERN_EMERG。在 具体的消息前面加上 KERN_EMERG 就可以将这条消息的级别设置为 KERN_EMERG</p><p>如果使用 printk 的 时 候 不 显 式 的 设 置 消 息 级 别 ， 那 么 printk 将 会 采 用 默 认 级 别 MESSAGE_LOGLEVEL_DEFAULT，MESSAGE_LOGLEVEL_DEFAULT 默认为 4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define KERN_SOH &quot;\001&quot;</span><br><span class="line">#define KERN_EMERG KERN_SOH &quot;0&quot; &#x2F;* 紧急事件，一般是内核崩溃 *&#x2F;</span><br><span class="line">#define KERN_ALERT KERN_SOH &quot;1&quot; &#x2F;* 必须立即采取行动 *&#x2F;</span><br><span class="line">#define KERN_CRIT KERN_SOH &quot;2&quot; &#x2F;* 临界条件，比如严重的软件或硬件错误*&#x2F;</span><br><span class="line">#define KERN_ERR KERN_SOH &quot;3&quot; &#x2F;* 错误状态，一般设备驱动程序中使用</span><br><span class="line">KERN_ERR 报告硬件错误 *&#x2F;</span><br><span class="line">#define KERN_WARNING KERN_SOH &quot;4&quot; &#x2F;* 警告信息，不会对系统造成严重影响 *&#x2F;</span><br><span class="line">#define KERN_NOTICE KERN_SOH &quot;5&quot; &#x2F;* 有必要进行提示的一些信息 *&#x2F;</span><br><span class="line">#define KERN_INFO KERN_SOH &quot;6&quot; &#x2F;* 提示性的信息 *&#x2F;</span><br><span class="line">#define KERN_DEBUG KERN_SOH &quot;7&quot; &#x2F;* 调试信息 *&#x2F;</span><br></pre></td></tr></table></figure><p>在 include/linux/printk.h 中有个宏 CONSOLE_LOGLEVEL_DEFAULT，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CONSOLE_LOGLEVEL_DEFAULT 7 </span><br></pre></td></tr></table></figure><p>CONSOLE_LOGLEVEL_DEFAULT 控制着哪些级别的消息可以显示在控制台上，此宏默认 为 7，意味着只有优先级高于 7 的消息才能显示在控制台上。 这个就是 printk 和 printf 的最大区别，可以通过消息级别来决定哪些消息可以显示在控制 台上。默认消息级别为 4，4 的级别比 7 高，所示直接使用 printk 输出的信息是可以显示在控制 台上的</p><p>参数 filp 有个叫做 private_data 的成员变量，private_data 是个 void 指针，一般在驱动中将 private_data 指向设备结构体，设备结构体会存放设备的一些属性</p><p>chrdevbase_read 函数，应用程序调用 read 函数从设备中读取数据的时候此函数会执行。参数 buf 是用户空间的内存，读取到的数据存储在 buf 中，参数 cnt 是要读取的字节数，参数 offt 是相对于文件首地址的偏移，kerneldata 里面保存着用户空间要读取的数据，先将 kerneldata 数组中的数据拷贝到读缓冲区 readbuf 中，通过函数 copy_to_user 将 readbuf 中的数据复制到参数 buf 中。因为内核空间不能直接操作用户空间的内存，因此需要借 助 copy_to_user 函数来完成内核空间的数据到用户空间的复制。copy_to_user 函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline long copy_to_user(void __user *to, const void *from, unsigned long n)</span><br></pre></td></tr></table></figure><p>参数 to 表示目的，参数 from 表示源，参数 n 表示要复制的数据长度。如果复制成功，返 回值为 0，如果复制失败则返回负数</p><p>chrdevbase_write 函数，应用程序调用 write 函数向设备写数据的时候此函数 就会执行。参数 buf 就是应用程序要写入设备的数据，也是用户空间的内存，参数 cnt 是要写入 的数据长度，参数 offt 是相对文件首地址的偏移。通过函数 copy_from_user 将 buf 中的 数据复制到写缓冲区 writebuf 中，因为用户空间内存不能直接访问内核空间的内存，需要借助函数 copy_from_user 将用户空间的数据复制到 writebuf 这个内核空间中</p><p>chrdevbase_release 函数，应用程序调用 close 关闭设备文件的时候此函数会 执行，一般会在此函数里面执行一些释放操作。如果在 open 函数中设置了 filp 的 private_data 成员变量指向设备结构体，那么在 release 函数最终就要释放掉</p><p>memcpy函数语法</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *destin, void *source, unsigned n);</span><br></pre></td></tr></table></figure><p>参数</p><p>destin– 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</p><p>source– 指向要复制的数据源，类型强制转换为 void* 指针</p><p>n– 要被复制的字节数</p><p>返回值</p><p>该函数返回一个指向目标存储区destin的指针</p><p>功能</p><p>从源source所指的内存地址的起始位置开始拷贝n个字节到目标destin所指的内存地址的起始位置中</p><p>所需头文件</p><p>C语言：#include&lt;string.h&gt;        C++：#include<cstring></cstring></p><h2 id="编写测试-APP"><a href="#编写测试-APP" class="headerlink" title="编写测试 APP"></a>编写测试 APP</h2><h3 id="C-库文件操作基本函数"><a href="#C-库文件操作基本函数" class="headerlink" title="C 库文件操作基本函数"></a>C 库文件操作基本函数</h3><h4 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h4><p>int open(const char *pathname, int flags)</p><p>pathname：要打开的设备或者文件名</p><p>flags：文件打开模式，以下三种模式必选其一： </p><p>O_RDONLY 只读模式 </p><p>O_WRONLY 只写模式 </p><p>O_RDWR 读写模式</p><p>除了上述三种 模式以外还有其他的可选模式，通过逻辑或来选择多种模式</p><p>返回值：如果文件打开成功的话返回文件的文件描述符</p><p>在 Ubuntu 中输入“man 2 open”即可查看 open 函数的详细内容</p><h4 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h4><p>ssize_t read(int fd, void *buf, size_t count)</p><p>fd：要读取的文件描述符，读取文件之前要先用 open 函数打开文件，open 函数打开文件成 功以后会得到文件描述符</p><p>buf：数据读取到此 buf 中</p><p>count：要读取的数据长度，也就是字节数</p><p>返回值：读取成功的话返回读取到的字节数；如果返回 0 表示读取到了文件末尾；如果返 回负值，表示读取失败。在 Ubuntu 中输入“man 2 read”命令即可查看 read 函数的详细内容</p><h4 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a>write 函数</h4><p>ssize_t write(int fd, const void *buf, size_t count);</p><p>fd：要进行写操作的文件描述符，写文件之前要先用 open 函数打开文件，open 函数打开文 件成功以后会得到文件描述符</p><p>buf：要写入的数据</p><p>count：要写入的数据长度，也就是字节数 </p><p>返回值：写入成功的话返回写入的字节数；如果返回 0 表示没有写入任何数据；如果返回负值，表示写入失败</p><h4 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h4><p>int close(int fd);</p><p>fd：要关闭的文件描述符</p><p>返回值：0 表示关闭成功，负值表示关闭失败</p><h3 id="编译驱动程序"><a href="#编译驱动程序" class="headerlink" title="编译驱动程序"></a>编译驱动程序</h3><p>需要将其编译为.ko 模块，创建 Makefile 文件</p><p>Makefile：</p><p>KERNELDIR 表示开发板所使用的 Linux 内核源码目录，使用绝对路径，根据实际情况填写</p><p>CURRENT_PATH 表示当前路径，直接通过运行“pwd”命令来获取当前所处路 径</p><p>obj-m 表示将 chrdevbase.c 这个文件编译为 chrdevbase.ko 模块</p><p>具体的编译命令，后面的 modules 表示编译模块，-C 表示将当前的工作目录切换到指定目录中，也就是 KERNERLDIR 目录。M 表示模块源码目录，“make modules”命令 中加入 M=dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件</p><p>使用 arm-linux-gnueabihf-gcc 来编译， 输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc chrdevbaseApp.c -o chrdevbaseApp</span><br></pre></td></tr></table></figure><p>编译完成以后会生成一个叫做 chrdevbaseApp 的可执行程序，输入如下命令查看 chrdevbaseAPP 这个程序的文件信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file chrdevbaseApp</span><br></pre></td></tr></table></figure><p>输入如下命令加载 chrdevbase.ko 驱动文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insmod chrdevbase.ko</span><br><span class="line">或</span><br><span class="line">modprobe chrdevbase.ko</span><br></pre></td></tr></table></figure><p>modprobe 提示无法打开“modules.dep”这个文件，因此驱动挂载 失败了。我们不用手动创建 modules.dep 这个文件，直接输入 depmod 命令即可自动生成 modules.dep，有些根文件系统可能没有 depmod 这个命令，如果没有这个命令就只能重新配置 busybox，使能此命令，然后重新编译 busybox。输入“depmod”命令以后会自动生成 modules.alias、 modules.symbols 和 modules.dep 这三个文件</p><p>输入“lsmod”命令即可查看当前系统中存在的模块</p><p>输入如下命令查看当前 系统中有没有 chrdevbase 这个设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;devices</span><br></pre></td></tr></table></figure><p>驱动加载成功需要在/dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操 作这个设备节点文件来完成对具体设备的操作。输入如下命令创建/dev/chrdevbase 这个设备节 点文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod &#x2F;dev&#x2F;chrdevbase c 200 0</span><br></pre></td></tr></table></figure><p>其中“mknod”是创建节点命令，“/dev/chrdevbase”是要创建的节点文件，“c”表示这是个字符设备，“200”是设备的主设备号，“0”是设备的次设备号。创建完成以后就会存在 /dev/chrdevbase 这个文件，可以使用“ls /dev/chrdevbase -l”命令查看</p><p>如果 chrdevbaseAPP 想要读写 chrdevbase 设备，直接对/dev/chrdevbase 进行读写操作即可。 相当于/dev/chrdevbase 这个文件是 chrdevbase 设备在用户空间中的实现</p><p>输入如下命令卸载掉 chrdevbase 这 个设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmmod chrdevbase.ko</span><br></pre></td></tr></table></figure><blockquote><p>驱动给应用传递数据的时候需要用到copy_to_user函数</p><p>memcpy () 把一段内存(kerneldata)拷贝到另一段内存(readbuf)去,拷贝长度sizeof(kerneldata)</p><p>用户空间内存不能直接访问内核空间的内存，需要借助函数copy_from_user</p><p>./chrdevbaseAPP &lt; filename &gt; &lt;1 : 2&gt; 1表示读，2表示写</p><p>./chrdevbaseAPP /dev/chrdevbase 1 表示从驱动里面读数据</p><p>&lt; filename &gt; 即驱动文件</p><p>1是字符串，需要转变成数字1，通过函数atoi ()  </p></blockquote><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;字符设备驱动开发框架&quot;&gt;&lt;a href=&quot;#字符设备驱动开发框架&quot; class=&quot;headerlink&quot; title=&quot;字符设备驱动开发框架&quot;&gt;&lt;/a&gt;字符设备驱动开发框架</summary>
      
    
    
    
    
    <category term="驱动开发" scheme="https://www.chenzhan.club/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>note31.4-rootfs根文件系统</title>
    <link href="https://www.chenzhan.club/2021/03/27/note31-4-rootfs%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.chenzhan.club/2021/03/27/note31-4-rootfs%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-03-27T07:48:23.000Z</published>
    <updated>2021-04-12T13:33:25.706Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><p>Linux 中的根文件系统更像是一个文件夹或者叫做目录，在这个目录里面会有很多的子目录。根目录下和子目录中会有很多的文 件，这些文件是 Linux 运行所必须的，比如库、常用的软件和命令、设备文件、配置文件等等</p><p>根文件系统首先是内核启动时所 mount(挂载)的第一个文件系统，内核代码映像文件保存在 根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和 服务等加载到内存中去运行</p></li><li><p>如果不提供根文件系统，Linux 内核 在启动的时候就会提示内核崩溃(Kernel panic)的提示</p></li><li><table><thead><tr><th>/bin 目录</th><th>bin 文件就是可执行文件。此目录下存放着系统 需要的可执行文件，一般都是一些命令，比如 ls、mv 等命令。此目录下的命令所有的客户都可以使用</th></tr></thead><tbody><tr><td>/dev 目录</td><td>dev 是 device 的缩写，所以此目录下的文件都是和设备有关的，此目录下的文件都是设备文件。在 Linux 下一切皆文件，即使是硬件设备，也是以文件的形式存在的，比如 /dev/ttymxc0(I.MX6ULL 根目录会有此文件)就表示 I.MX6ULL 的串口 0，我们要想通过串口 0 发送或者接收数据就要操作文件/dev/ttymxc0，通过对文件/dev/ttymxc0 的读写操作来实现串口 0 的数据收发</td></tr><tr><td>/etc 目录</td><td>此目录下存放着各种配置文件，Ubuntu 的 etc 目录里面的配置文件非常多，但嵌入式 Linux 下此目录会很简洁</td></tr><tr><td>/lib 目录</td><td>lib 是 library 的简称，也就是库的意思，因此此目录下存放着 Linux 所必须的库文件。这些 库文件是共享库，命令和用户编写的应用程序要使用这些库文件</td></tr><tr><td>/mnt 目录</td><td>临时挂载目录，一般是空目录，可以在此目录下创建空的子目录，比如/mnt/sd、/mnt/usb， 这样就可以将 SD 卡或者 U 盘挂载到/mnt/sd 或者/mnt/usb 目录中</td></tr><tr><td>/proc 目录</td><td>此目录一般是空的，当 Linux 系统启动以后会将此目录作为 proc 文件系统的挂载点，proc 是个虚拟文件系统，没有实际的存储设备。proc 里面的文件都是临时存在的，一般用来存储系 统运行信息文件</td></tr><tr><td>/usr 目录</td><td>usr 不是 user 的缩写，是 Unix Software Resource 的缩写，也就是 Unix 操作系统软件资源目录。Linux 一般被成为类 Unix 操作系统，苹果的 MacOS 也是类 Unix 操作系统。因为是软件资源目录，因此/usr 目录下也存放着很多软件，一般系统安装完成以后此目录占用的空间最多</td></tr><tr><td>/var 目录</td><td>此目录存放一些可以改变的数据</td></tr><tr><td>/sbin 目录</td><td>此目录页用户存放一些可执行文件，但是此目录下的文件或者说命令只有管理员才能使用， 主要用户系统管理</td></tr><tr><td>/sys 目录</td><td>系统启动以后此目录作为 sysfs 文件系统的挂载点，sysfs 是一个类似于 proc 文件系统的特 殊文件系统，sysfs 也是基于 ram 的文件系统，也就是说它也没有实际的存储设备。此目录是系 统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息</td></tr><tr><td>/opt</td><td>可选的文件、软件存放区，由用户选择将哪些文件或软件放到此目录中</td></tr></tbody></table></li><li><p>BusyBox工具</p></li><li><p>busybox 中文字符支持</p></li><li><p>配置 busybox</p><p>defconfig，缺省配置，也就是默认配置选项</p><p>使用下面命令配置busybox</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make defconfig</span><br></pre></td></tr></table></figure><p>busybox 也支持图形化配置，通过图形化配置我们可以进一步选择自己想要的功能，输入 如下命令打开图形化配置界面：make menuconfig</p></li><li><p>编译busybox</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install CONFIG_PREFIX&#x3D;&#x2F;home&#x2F;chenzhan&#x2F;linux&#x2F;nfs&#x2F;rootfs</span><br></pre></td></tr></table></figure></li><li><p>向 rootfs 的“/lib”目录添加库文件</p></li><li><p>lib 库文件从交叉编译器中获取，前面我们搭建 交叉编译环境的时候将交叉编译器存放到了“/usr/local/arm/”目录中</p></li><li><p>目录下有很多的<em>so</em>(<em>是通配符)和.a 文件，这些就是库文件，将此目录下所有的</em>so*和.a 文件都拷贝到 rootfs/lib 目录中</p></li><li><p>后面的“-d”表示拷贝符号链接，这里有个比较特殊的库文件：ld-linux-armhf.so.3，此库文件也是个符号链接，相当于 Windows 下的快捷方式，ld-linux-armhf.so.3 后面有个“-&gt;”，表示其是个软连接文件，链接到文件 ld-2.19-2014.08-1-git.so，因为其是一个“快捷方式”，作为符号链接，在根文件系统中执行程序无法执行！我们需要将“快捷方式”变为“本尊”，就是重新复制 ld-linuxarmhf.so.3，只是不复制软链接即可，先将 rootfs/lib 中的 ld-linux-armhf.so.3 文件删除掉</p></li><li><p>/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/lib</p><p>/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linuxgnueabihf/libc/lib</p></li><li><p>向 rootfs 的“usr/lib”目录添加库文件</p></li><li><pre><code>setenv bootargs &#39;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.66:/home/chenzhan/linux/nfs/rootfs,proto=tcp rw ip=192.168.1.40:192.168.1.66:192.168.1.1:255.255.255.0::eth0:off&#39;saveenv<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- sleep 相当于 Linux 的延时函数，单位为 秒，所以 sleep(2)就是延时 2 秒</span><br><span class="line"></span><br><span class="line">- file hello &#x2F;&#x2F;查看 hello 的文件类型以及编码格式</span><br><span class="line"></span><br><span class="line">  hello: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked……</span><br><span class="line"></span><br><span class="line">  hello 是个 32 位的 LSB 可执行文件，ARM 架构的，并且是动态链接的。所以我们编译出 来的 hello 文件没有问题。将其拷贝到 rootfs&#x2F;drivers 目录下，在开发板中输入如下命令来执行这 个可执行文件：</span><br><span class="line"></span><br></pre></td></tr></table></figure>cd /drivers //进入 drivers 目录./hello //执行 hello<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  让一个软件进入后台，运行软件的时候加上“&amp;”即可，比如“.&#x2F;hello &amp;”就是让 hello 在后台运行。在后台运行的软件可以使用“kill -9 pid(进程 ID)”命令来关闭掉，首先使用“ps”命令查看要关闭的软件 PID 是多少，ps 命令用于查看所有当前正在运行的进程，并且会给出进程的 PID,可以得到hello对应的PID为78，使用如下命令关闭后台运行的hello软件，kill -9 78</span><br><span class="line"></span><br><span class="line">  因为 hello 在不断的输出“hello world”所以我们的输入看起来会被打断，其实是没有的， 因为我们是输入，而 hello 是输出。在数据流上是没有打断的，只是显示在 MobaXterm 上就好像被打断了，所以只管输入“kill -9 166”即可。hello 被 kill 以后会有提示</span><br><span class="line"></span><br><span class="line">- 开机自启动测试</span><br><span class="line"></span><br><span class="line">  进入根文件系统的时候 会运行&#x2F;etc&#x2F;init.d&#x2F;rcS 这个 shell 脚本，因此我们可以在这个脚本里面添加自启动相关内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>......15 #开机自启动16 cd /drivers17 ./hello &amp;18 cd /<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 我们需要配置域名解析服务器的 IP 地址，一般域名解析地址可以</span><br><span class="line">  设置为所处网络的网关地址，比如 192.168.1.1。也可以设置为 114.114.1144.114，这个是运营商</span><br><span class="line">  的域名解析服务器地址。</span><br><span class="line">  在 rootfs 中新建文件&#x2F;etc&#x2F;resolv.conf，然后在里面输入如下内容：</span><br><span class="line"></span><br></pre></td></tr></table></figure>nameserver 114.114.114.114nameserver 192.168.1.1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  设置很简单，nameserver 表示这是个域名服务器，设置了两个域名服务器地址： 114.114.114.114 和 192.168.1.1，大家也可以改为其他的域名服务器试试。如果使用“udhcpc”命 令自动获取 IP 地址，“udhcpc”命令会修改 nameserver 的值，一般是将其设置为对应的网关地 址</span><br><span class="line"></span><br><span class="line">- MfgTool 工具</span><br><span class="line"></span><br><span class="line">  将 uboot、linux kernel、.dtb(设备树)和 rootfs 这四个文件烧写到板子 上的 EMMC、NAND 或 QSPI Flash 等其他存储设备上，这样不管有没有网络我们的产品都可以 正常运行</span><br><span class="line"></span><br><span class="line">- 如果要烧写我们的系统，就需要用我们编译出来的 zImage、u-boot.imx 和 imx6ull-alientekemmc.dtb 这几个文件替换掉表中几个文件。但是名字要和表中的一致，因此需要将 u-boot.imx 重命名为 u-boot-imx6ull14x14evk_emmc.imx，将 imx6ull-alientek-emmc.dtb 重命名为 zImage-imx6ull-14x14-evk-emmc.dtb</span><br><span class="line"></span><br><span class="line">  | 脚本文件                          | 描述                                                         |</span><br><span class="line">  | --------------------------------- | ------------------------------------------------------------ |</span><br><span class="line">  | zImage                            | NXP 官方 I.MX6ULL EVK 开发板的 Linux 镜像文件                |</span><br><span class="line">  | u-boot-imx6ull14x14evk_emmc.imx   | NXP 官方 I.MX6ULL EVK 开发板的 uboot 文件                    |</span><br><span class="line">  | zImage-imx6ull-14x14-evk-emmc.dtb | NXP 官方 I.MX6ULL EVK 开发板的设备树                         |</span><br><span class="line">  | rootfs_nogpu.tar.bz2              | 根文件系统，注意和另外一个 rootfs.tar.bz2 根文件系 统区分开。nogpu 表示此根文件系统不包含 GPU 的内 容，I.MX6ULL 没有 GPU，因此要使用此根文件系统 |</span><br><span class="line"></span><br><span class="line">- 烧写 NXP 官方系统步骤如下：</span><br><span class="line"></span><br><span class="line">  1. 连接好 USB，拨码开关拨到 USB 下载模式</span><br><span class="line">  2. 弹出 TF 卡，然后按下开发板复位按键</span><br><span class="line">  3. 双击“mfgtool2-yocto-mx-evk-emmc.vbs”，打开下载软件，如果出现“符合 HID 标准 的供应商定义设备”等字样就说明下载软件已经准备就绪。点击“Start”按钮开发烧写 NXP 官方系统</span><br><span class="line"></span><br><span class="line">  启 动以后的系统是 NXP 官方给 I.MX6ULL EVK 开发板制作的，这个系统需要输入用户名，用户 名为“root”，没有密码</span><br><span class="line"></span><br><span class="line">- 烧写自制的系统</span><br><span class="line"></span><br><span class="line">  1. 自己移植编译出来的 uboot 可执行文件：u-boot.imx</span><br><span class="line"></span><br><span class="line">  2. 自己移植编译出来的 zImage 镜像文件和开发板对应的.dtb(设备树)，对于 I.MX6UALPHA 开发板来说就是 imx6ull-alientek-emmc.dtb</span><br><span class="line"></span><br><span class="line">  3. 自己构建的根文件系统 rootfs，这里我们需要对 rootfs 进行打包，进入到 Ubuntu 中的 rootfs 目录中，然后使用 tar 命令对其进行打包，命令如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>   cd rootfs/   tar -vcjf rootfs.tar.bz2 *</code></pre><p>   将 4 个文件都发送到 Windows 系统中</p><p>   重命名</p><table><thead><tr><th>原名字</th><th>重命名</th></tr></thead><tbody><tr><td>u-boot.imx</td><td>u-boot-imx6ull14x14evk_emmc.imx</td></tr><tr><td>zImage</td><td>zImage(不需要重命名)</td></tr><tr><td>imx6ull-alientek-emmc.dtb</td><td>zImage-imx6ull-14x14-evk-emmc.dtb</td></tr><tr><td>rootfs.tar.bz2</td><td>rootfs_nogpu.tar.bz2</td></tr></tbody></table><p>   接下来用我们的文件替换掉 NXP 官方的文件，先将 zImage、u-bootimx6ull14x14evk_emmc.imx 和 zImage-imx6ull-14x14-evk-emmc.dtb 这三个文件拷贝到 mfgtoolswith-rootfs/mfgtools/Profiles/Linux/OS Firmware/firmware 目录中，替换掉原来的文件。然后 4 个文件都拷贝到 mfgtools-with-rootfs/mfgtools/Profiles/Linux/OS Firmware/files 目录中，这两个操作完成以后我们就可以进行烧写了</p></li><li><p> 网络开机自启动设置</p></li><li><p>改造我们自己的烧写工具，改造 MfgTool</p><ol><li>针对不同的核心版，确定系统文件相关名字</li><li>新建我们自己的.vbs 文件</li><li>修改 ucl2.xml 文件</li></ol></li></ul><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux 中的根文件系统更像是一个文件夹或者叫做目录，在这个目录里面会有很多的子目录。根目录下和子目录中会有很多的文 件，这些文件是 Linux 运行所必须的，比</summary>
      
    
    
    
    
    <category term="系统移值" scheme="https://www.chenzhan.club/tags/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>note30.4-Linux内核移值</title>
    <link href="https://www.chenzhan.club/2021/03/23/note30-4-Linux%E5%86%85%E6%A0%B8%E7%A7%BB%E5%80%BC/"/>
    <id>https://www.chenzhan.club/2021/03/23/note30-4-Linux%E5%86%85%E6%A0%B8%E7%A7%BB%E5%80%BC/</id>
    <published>2021-03-23T12:54:25.000Z</published>
    <updated>2021-04-12T13:33:13.400Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><p>创建 VSCode 工程</p><p>重点是.vscode/settings.json 这个文件</p></li><li><p>修改顶层 Makefile</p><p>直接在顶层 Makefile 文件里面定义 ARCH 和 CROSS_COMPILE 这两 个的变量值为 arm 和 arm-linux-gnueabihf- 在编译的时候就不用输入很长的命令了</p></li><li><p>配置并编译 Linux 内核</p><ul><li><p>默认配置文件保存在 arch/arm/configs 目录中</p><p>比如：imx_v7_mfg_defconfig 这个默认配置文件，此配置文件默认支持 I.MX6UL 这款芯片， 此文件编译出来的 zImage 可以通过 NXP 官方提供的 MfgTool 工具烧写！imx_v7_mfg_defconfig 中的“mfg”的意思就是 MfgTool</p></li><li><p>进入到 Ubuntu 中的 Linux 源码根目录下，执行如下命令配置 Linux 内核（在修改完顶层Makefile 后）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean &#x2F;&#x2F;第一次编译 Linux 内核之前先清理一下</span><br><span class="line">make imx_v7_mfg_defconfig &#x2F;&#x2F;配置 Linux 内核</span><br></pre></td></tr></table></figure><p>配置完成以后就可以编译了，使用如下命令编译 Linux 内核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j16 &#x2F;&#x2F;编译 Linux 内核（j16指使用16核编译）</span><br></pre></td></tr></table></figure></li><li><p>Linux 内核编译完成以后会在 arch/arm/boot 目录下生成 zImage 镜像文件，如果使用设备树 的话还会在 arch/arm/boot/dts 目录下开发板对应的.dtb(设备树)文件</p></li></ul></li><li><p>根文件系统缺失错误</p><p>Linux 内核启动以后是需要根文件系统的，根文件系统存在哪里是由 uboot 的 bootargs 环境变 量指定 ， bootargs 会传递给 Linux 内核作为命令行参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br></pre></td></tr></table></figure><p>提示内核崩溃，因为 VFS(虚拟文件系统)不能挂载根文件系统，因为根文件系统目录不存在。即使根文件系统目录存在，如果根文件系统目录里面是空的依旧会提示内核崩溃。 这个就是根文件系统缺失导致的内核崩溃，但是内核是启动了的，只是根文件系统不存在而已</p></li><li><p>在 Linux 中添加自己的开发板</p><p>将 arch/arm/configs 目 录 下 的 imx_v7_mfg_defconfig 重新复制一份 ，命名为 imx_alientek_emmc_defconfig</p><p>以后 imx_alientek_emmc_defconfig 就是正点原子的 EMMC 版开发板默认配置文件了（我们的默认配置文件），以后就可以使用如下命令来配置正点原子 EMMC 版开发板对应的 Linux 内核了：make imx_alientek_emmc_defconfig</p></li><li><p>添加开发板对应的设备树文件</p><p>.dts 是设备树源码文件，编译 Linux 的时候会将其编译为.dtb 文件。imx6ull-alientek-emmc.dts （自己的设备树文件）创建好以后还需要修改文件 arch/arm/boot/dts/Makefile ， 找 到 “ dtb- $(CONFIG_SOC_IMX6ULL)”配置项，在此配置项中加入“imx6ull-alientek-emmc.dtb”</p></li><li><p>输入如下命令查看 cpu 信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure></li><li><p>vmlinux、Image，zImage、uImage 的区别</p><p>vmlinux 是 ELF 格式的文件，但是在实 际中我们不会使用 vmlinux，而是使用 zImage 或 uImage 这样的 Linux 内核镜像文件</p><ol><li>vmlinux 是编译出来的最原始的内核文件，是未压缩的</li><li>Image 是 Linux 内核镜像文件，但是 Image 仅包含可执行的二进制数据。Image 就是使 用 objcopy 取消掉 vmlinux 中的一些其他信息，比如符号表什么的。但是 Image 是没有压缩过 的，Image 保存在 arch/arm/boot 目录下</li><li>zImage 是经过 gzip 压缩后的 Image</li><li>uImage 是老版本 uboot 专用的镜像文件，uImag 是在 zImage 前面加了一个长度为 64 字节的“头”，这个头信息描述了该镜像文件的类型、加载位置、生成时间、大小等信息。但是 新的 uboot 已经支持了 zImage 启动！所以已经很少用到 uImage 了，除非你用的很古老的 uboot</li></ol><p>使用“make”、“make all”、“make zImage”这些命令就可以编译出 zImage 镜像</p></li><li><p>Linux 内核启动之前要求如下：</p><ol><li>关闭 MMU</li><li>关闭 D-cache</li><li>I-Cache 无所谓</li><li>r0=0</li><li>r1=machine nr(也就是机器 ID)</li><li>r2=atags 或者设备树(dtb)首地址</li></ol></li><li><p>Linux 内核的入口点 stext 其实相当于内核的入口函数</p></li><li><p>Linux 内核将每种处理器都抽象为一个 proc_info_list 结构体，每种处理器都对应一个 procinfo。因此可以通过处理器 ID 来找到对应的 procinfo 结构，__lookup_processor_type 函数找 到对应处理器的 procinfo 以后会将其保存到 r5 寄存器中</p></li><li><p>proc_info_list 在文件 arch/arm/include/asm/procinfo.h 中</p></li><li><p>start_kernel 通过调用众多的子函数来完成 Linux 启动之前的一些初始化工作</p></li><li><p>idle 空闲进程 就和空闲任务一样，当 CPU 没有事情做的时候就在 idle 空闲进程里面“瞎逛游”，当其他进程要工作的时候就会抢占 idle 进程，从而夺取 CPU 使用权</p></li><li><p>在 Linux 终端中输入“ps -A”就可以打印出当前系统中的所有进程，其中就能看到 init 进 程和 kthreadd 进程</p></li><li><p>kernel_init 函数就是 init 进程具体做的工作，定义在文件 init/main.c 中</p></li><li><p>调用函数 prepare_namespace 来挂载根文件系统。跟文件系统也是由命令行参数指定的，也就是 uboot 的 bootargs 环境变量</p></li><li><p>Linux 内核最终是需要和根文件系统打交道的，需要挂载根文件系统，并且执行根文件系统中的 init 程序，以此来进去用户态</p></li><li><p>在实际的产品中，禁止任何超频！务必严格按照 I.MX6ULL 手册上给出的标准工作频率来 运行！！如果想要更高的性能，请购买相应型号的处理器！</p></li><li><p>学习的时候为了高性能，大家可以使用 performance 模式。但是在以后的实际产品开发 中，从省电的角度考虑，建议大家使用 ondemand 模式，一来可以省电，二来可以减少发热</p></li><li><p>重新修改过默认配置文件，编译之前先清理一下工程！</p></li><li><p>图形化配置界面，一定不要清理工程！</p></li><li><p>使用命令“make dtbs”重新编译一 下设备树</p></li><li><p>网络驱动分两部分：内部 MAC+外部 PHY，内部 MAC 驱动是由 NXP 提供</p></li><li><pre><code>cp arch/arm/boot/zImage /home/chenzhan/linux/tftpboot/ -fcp arch/arm/boot/dts/imx6ull-alientek-emmc.dtb /home/chenzhan/linux/tftpboot/ -f<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>tftp 80800000 zImage tftp 83000000 imx6ull-alientek-emmc.dtbbootz 80800000 - 83000000</code></pre></li></ul><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建 VSCode 工程&lt;/p&gt;
&lt;p&gt;重点是.vscode/settings.json 这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改顶层 Makefile&lt;/</summary>
      
    
    
    
    
    <category term="系统移值" scheme="https://www.chenzhan.club/tags/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>note29.4-U-Boot内核移值启动</title>
    <link href="https://www.chenzhan.club/2021/03/17/note29-4-U-Boot%E5%86%85%E6%A0%B8%E7%A7%BB%E5%80%BC%E5%90%AF%E5%8A%A8/"/>
    <id>https://www.chenzhan.club/2021/03/17/note29-4-U-Boot%E5%86%85%E6%A0%B8%E7%A7%BB%E5%80%BC%E5%90%AF%E5%8A%A8/</id>
    <published>2021-03-17T07:01:00.000Z</published>
    <updated>2021-04-12T13:33:01.496Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><p>创建 VSCode 工程</p><ol><li>打开 VScode，选择：文件-&gt;打开文件夹…，选中 uboot 文件夹</li><li>点击“文件-&gt;将工作区另存为…”，打开保存工作区对话框，将工作区保存到 uboot 源码根 目录下，设置文件名为“uboot”</li><li>保存成功以后就会在 uboot 源码根目录下存在一个名为 uboot.code-workspace 的文件。这样 一个完整的 VSCode 工程就建立起来了。但是这个 VSCode 工程包含了 uboot 的所有文件，uboot 中有些文件是不需要的，比如 arch 目录下是各种架构的文件夹，在 arch 目录下，我们只需要 arm 文件夹，所以需要将其它的目录从 VSCode 中给屏蔽掉， 比如将 arch/avr32 这个目录给屏蔽掉</li><li>在 VSCode 上建名为“.vscode”的文件夹</li><li>在.vscode 文件夹中新建一个名为“settings.json”的文件，然后在 settings.json 中输入如下内 容：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 &#123;</span><br><span class="line">2 &quot;search.exclude&quot;: &#123;</span><br><span class="line">3 &quot;**&#x2F;node_modules&quot;: true,</span><br><span class="line">4 &quot;**&#x2F;bower_components&quot;: true,</span><br><span class="line">5 &#125;,</span><br><span class="line">6 &quot;files.exclude&quot;: &#123;</span><br><span class="line">7 &quot;**&#x2F;.git&quot;: true,</span><br><span class="line">8 &quot;**&#x2F;.svn&quot;: true,</span><br><span class="line">9 &quot;**&#x2F;.hg&quot;: true,</span><br><span class="line">10 &quot;**&#x2F;CVS&quot;: true,</span><br><span class="line">11 &quot;**&#x2F;.DS_Store&quot;: true, </span><br><span class="line">12 &#125;</span><br><span class="line">13 &#125;</span><br></pre></td></tr></table></figure><p>其中”search.exclude”里面是需要在搜索结果中排除的文件或者文件夹，”files.exclude”是左 侧工程目录中需要排除的文件或者文件夹</p><p>我们只是在”search.exclude”和”files.exclude”中加入了：arch/avr32”: true，冒号前面的是要排 除的文件或者文件夹，冒号后面为是否将文件排除，true 表示排除，false 表示不排除。用这种 方法即可将不需要的文件，或者文件夹排除掉</p></li></ul><ul><li>总结一下 NXP 官方 I.MX6ULL EVK 开发板的 uboot 在正点原子 EMMC 版本 I.MX6ULL  开发板上的运行情况：<ol><li>uboot 启动正常，DRAM 识别正确，SD 卡和 EMMC 驱动正常</li><li>uboot 里面的 LCD 驱动默认是给 4.3 寸 480x272 分辨率的，如果使用的其他分辨率的 屏幕需要修改驱动</li><li>网络不能工作，识别不出来网络信息，需要修改驱动</li><li>接下来我们要做的工作如下： <ol><li>前面我们一直使用着 NXP 官方开发板的 uboot 配置，接下来需要在 uboot 中添加我们 自己的开发板</li><li>解决 LCD 驱动和网络驱动的问题</li></ol></li></ol></li></ul><ul><li><p>LCD 驱动修改</p><p>一般 uboot 中修改驱动基本都是在 xxx.h 和 xxx.c 这两个文件中进行的，xxx 为板子名称， 比如 mx6ull_alientek_emmc.h 和 mx6ull_alientek_emmc.c 这两个文件。 一般修改 LCD 驱动重点注意以下几点： </p><ol><li>LCD 所使用的 GPIO，查看 uboot 中 LCD 的 IO 配置是否正确</li><li>LCD 背光引脚 GPIO 的配置</li><li>LCD 配置参数是否正确</li></ol></li></ul><ul><li>NXP 的 I.MX 系列芯片的所有板级文件夹都存放在 board/freescale 目录下</li><li>ctrl+p 转到文件</li><li><strong>include/configs/mx6ull_alientek_emmc.h</strong></li><li><strong>board/freescale/mx6ull_alientek_emmc/mx6ull_alientek_emmc.c</strong></li></ul><ul><li><p>开发板网络简介</p><p>I.MX6UL/ULL 内部有个以太网 MAC 外设，也就是 ENET，需要外接一个 PHY 芯片来实现网络通信功能，也就是内部 MAC+外部 PHY 芯片的方案。 DM9000 这个网络 芯片，在一些没有内部 MAC 的 CPU 中，比如三星的 2440，4412 等，就会采用 DM9000 来实现联网功能。DM9000 提供了一个类似 SRAM 的访问接口，主控 CPU 通过这个接口即可与 DM9000 进行通信，DM9000 就是一个 MAC+PHY 芯片。这个方案就相当于外部 MAC+外部 PHY</p></li><li><p>LAN8720A 内部是有寄存器的，I.MX6ULL 会读取 LAN8720 内部寄存器来判断当前的物 理链接状态、连接速度(10M 还是 100M)和双工状态(半双工还是全双工)。I.MX6ULL 通过 MDIO 接口来读取 PHY 芯片的内部寄存器，MDIO 接口有两个引脚，ENET_MDC 和 ENET_MDIO， ENET_MDC 提供时钟，ENET_MDIO 进行数据传输。一个 MIDO 接口可以管理 32 个 PHY 芯 片，同一个 MDIO 接口下的这些 PHY 使用不同的器件地址来做区分，MIDO 接口通过不同的 器件地址即可访问到相应的 PHY 芯片。I.MX6U-ALPHA 开发板 ENET1 上连接的 LAN8720A 器件地址为 0X0，所示我们要修改 ENET1 网络驱动的话重点就三点：</p><ol><li>ENET1 复位引脚初始化</li><li>LAN8720A 的器件 ID</li><li>LAN8720 驱动</li></ol></li></ul><ul><li><p>bootcmd 和 bootargs 环境变量</p><ul><li>bootcmd 在前面已经说了很多次了，bootcmd 保存着 uboot 默认命令，uboot 倒计时结束以 后就会执行 bootcmd 中的命令。这些命令一般都是用来启动 Linux 内核的，比如读取 EMMC 或 者 NAND Flash 中的 Linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 Linux 内核。可 以在 uboot 启动以后进入命令行设置 bootcmd 环境变量的值。如果 EMMC 或者 NAND 中没有 保存 bootcmd 的值，那么 uboot 就会使用默认的值，板子第一次运行 uboot 的时候都会使用默 认值来设置 bootcmd 环境变量。打开文件 include/env_default.h</li><li>bootargs 保存着 uboot 传递给 Linux 内核的参数， bootargs 环境变量是由 mmcargs 设置的</li></ul></li></ul><ul><li><p>uboot 启动 Linux 测试</p><ul><li><p>从 EMMC 启动 Linux 系统</p><p>从 EMMC 启动也就是将编译出来的 Linux 镜像文件 zImage 和设备树文件保存在 EMMC 中，uboot 从 EMMC 中读取这两个文件并启动，这个是产品最终的启动方式</p><p>先检查一下 EMMC 的分区 1 中有没有 zImage 文件和设备树文件，输入命令“ls mmc 1:1”</p><p>EMMC 分区 1 中存在 zimage 和 imx6ull-alientek-emmc.dtb</p><p>设置 bootargs 和 bootcmd 这两个环境变量，设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw&#39;</span><br><span class="line"></span><br><span class="line">setenv bootcmd &#39;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000;&#39;</span><br><span class="line"></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p><em>设置好以后直接输入 boot，或者 run bootcmd 即可启动 Linux 内核</em></p><p><em><u>先将当前设备切换到EMMC：</u></em></p><p><em><u>mmc dev 1  //切换到EMMC</u></em></p><p><em><u>fatls mmc 1:1 //查看EMMC分区1里面的文件</u></em></p><p><em><u>fatload mmc 1:1 80800000 zImage //将zimage下载到DDR的0x80800000处</u></em></p><p><em><u>fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb //将dtb读取到0X83000000</u></em></p><p><em><u>bootz 80800000 – 83000000 //启动内核</u></em></p><p><em><u>如果内核启动成功，说明uboot支持emmc启动，验证成功</u></em></p></li><li><p>从网络启动 Linux 系统</p><p>从网络启动 linux 系统的唯一目的就是为了调试！不管是为了调试 linux 系统还是 linux 下 的驱动。每次修改 linux 系统文件或者 linux 下的某个驱动以后都要将其烧写到 EMMC 中去测 试，这样太麻烦了。我们可以设置 linux 从网络启动，也就是将 linux 镜像文件和根文件系统都 放到 Ubuntu 下某个指定的文件夹中，这样每次重新编译 linux 内核或者某个 linux 驱动以后只 需要使用 cp 命令将其拷贝到这个指定的文件夹中即可，这样就不用需要频繁的烧写 EMMC， 这样就加快了开发速度。我们可以通过 nfs 或者 tftp 从 Ubuntu 中下载 zImage 和设备树文件，根文件系统的话也可以通过 nfs 挂载</p><p>从tftp服务器下载：参考正点原子文档30.4.4小节或上一章笔记</p><p>设置 bootargs 和 bootcmd 这两个环境变量，设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw&#39;</span><br><span class="line">setenv bootcmd &#39;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000&#39;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#39;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000&#39;</span><br><span class="line">saveenv</span><br><span class="line">boot</span><br></pre></td></tr></table></figure><p>直接输入 boot 命令即可从网络启动 Linux 系统</p><p><em><u>tftp 80800000 zImage     //从tftp服务器下载zimage</u></em></p><p><em><u>tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb //从tftp服务器下载.dtb</u></em>  </p><p><em><u>bootz 80800000 – 83000000 //启动系统</u></em></p></li></ul></li></ul><ul><li><h1 id="U-Boot-图形化配置及其原理"><a href="#U-Boot-图形化配置及其原理" class="headerlink" title="U-Boot 图形化配置及其原理"></a>U-Boot 图形化配置及其原理</h1></li></ul><p>在前两章中我们知道 uboot 可以通过 mx6ull_alientek_emmc_defconfig 来配置，或者通过文 件 mx6ull_alientek_emmc.h 来配置 uboot。还有另外一种配置 uboot 的方法，就是图形化配置</p><p>uboot 或 Linux 内核可以通过输入“make menuconfig”来打开图形化配置界面，menuconfig 是一套图形化的配置工具，需要 ncurses 库支持。ncurses 库提供了一系列的 API 函数供调用者 生成基于文本的图形界面，因此需要先在 Ubuntu 中安装 ncurses 库，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><p>menuconfig 重点会用到两个文件：.config 和 Kconfig，.config 文件前面已经说了，这个文 件保存着 uboot 的配置项，使用 menuconfig 配置完 uboot 以后肯定要更新.config 文件。Kconfig 文件是图形界面的描述文件，也就是描述界面应该有什么内容，很多目录下都会有 Kconfig 文 件</p><p>在打开图形化配置界面之前，要先使用“make xxx_defconfig”对 uboot 进行一次默认配置， 只需要一次即可。如果使用“make clean”清理了工程的话就那就需要重新使用“make xxx_defconfig”再对 uboot 进行一次配置。进入 uboot 根目录，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- mx6ull_alientek_emmc_defconfig</span><br><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- menuconfig</span><br></pre></td></tr></table></figure><p>如果已经在 uboot 的顶层 Makefile 中定义了 ARCH 和 CROSS_COMPILE 的值，那么上述 命令可以简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make mx6ull_alientek_emmc_defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>通过键盘上的“↑”和“↓”键来选择要配置的菜单，按下“Enter”键进入子菜单。菜单 中高亮的字母就是此菜单的热键，在键盘上按下此高亮字母对应的键可以快速选中对应的菜单。 选中子菜单以后按下“Y”键就会将相应的代码编译进 Uboot 中，菜单前面变为“&lt; * &gt;”。按下 “N”键不编译相应的代码，按下“M”键就会将相应的代码编译为模块，菜单前面变为“&lt; M &gt;”。 按两下“Esc”键退出，也就是返回到上一级，按下“?”键查看此菜单的帮助信息，按下“/”键打开搜索框，可以在搜索框输入要搜索的内容。 在配置界面下方会有五个按钮，这五个按钮的功能如下： ：选中按钮，和“Enter”键的功能相同，负责选中并进入某个菜单。 ：退出按钮，和按两下“Esc”键功能相同，退出当前菜单，返回到上一级。 ：帮助按钮，查看选中菜单的帮助信息。 ：保存按钮，保存修改后的配置文件。 ：加载按钮，加载指定的配置文件。</p><p>在图 34.1.1 中共有 13 个配置主配置项，通过键盘上的上下键调节配置项。后面跟着“—&gt;” 表示此配置项是有子配置项的，按下回车键就可以进入子配置项</p><p>……</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建 VSCode 工程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开 VScode，选择：文件-&amp;gt;打开文件夹…，选中 uboot 文件夹&lt;/li&gt;
&lt;li&gt;点击“文件-&amp;</summary>
      
    
    
    
    
    <category term="系统移值" scheme="https://www.chenzhan.club/tags/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>note28.4-U-Boot</title>
    <link href="https://www.chenzhan.club/2021/03/13/note28-4-U-Boot/"/>
    <id>https://www.chenzhan.club/2021/03/13/note28-4-U-Boot/</id>
    <published>2021-03-13T14:00:42.000Z</published>
    <updated>2021-04-12T13:32:50.118Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="U-Boot"><a href="#U-Boot" class="headerlink" title="U-Boot"></a>U-Boot</h1><h2 id="U-Boot-简介"><a href="#U-Boot-简介" class="headerlink" title="U-Boot 简介"></a>U-Boot 简介</h2><p>Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段 bootloader程序。这段bootloader程序会先初始化DDR等外设，然后将Linux内核从flash(NAND， NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核。bootloader 的实际工作要复杂的多，但主要的工作是启动 Linux 内核，bootloader 和 Linux 内核的关系跟 PC 上的 BIOS 和 Windows 的关系一样，bootloader 就相当于 BIOS</p><p>有很多现成的 bootloader 软件，比如 U-Boot、vivi、RedBoot 等，其中以 U-Boot 使用最为广泛</p><p>uboot 的全称是 Universal Boot Loader，uboot 是一个遵循 GPL 协议的开源软件，uboot 是一 个裸机代码，可以看作是一个裸机综合例程。现在的 uboot 已经支持液晶屏、网络、USB 等高级功能</p><h3 id="三种U-Boot"><a href="#三种U-Boot" class="headerlink" title="三种U-Boot"></a>三种U-Boot</h3><table><thead><tr><th>种类</th><th>描述</th></tr></thead><tbody><tr><td>uboot 官方的 uboot 代码</td><td>由 uboot 官方维护开发的 uboot 版本，版本更新快，基本包含所 有常用的芯片</td></tr><tr><td>半导体厂商的 uboot 代码</td><td>半导体厂商维护的一个 uboot，专门针对自家的芯片，在对自家 芯片支持上要比 uboot 官方的好</td></tr><tr><td>开发板厂商的 uboot 代码</td><td>开发板厂商在半导体厂商提供的 uboot 基础上加入了对自家开发 板的支持</td></tr></tbody></table><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译完成以后 uboot 源码多了一些文件，其中 u-boot.bin 就是编译出来的 uboot 二进制文件。uboot是个裸机程序，因此需要在其前面加上头部(IVT、DCD等数据)才能在I.MX6U 上执行，图 30.2.4 中的 u-boot.imx 文件就是添加头部以后的 u-boot.bin，u-boot.imx 就是我们最 终要烧写到开发板中的 uboot 镜像文件</p><h3 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h3><p>shell 脚本要求的，必须是“#!/bin/bash”或者“#!/bin/sh“</p><p><strong>512MB(DDR3)+8GB(EMMC)核心板</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">&#x2F;*ARCH，指定架构，这里是 arm；CROSS_COMPILE 用于指定编译器，只需指明编译器前缀，比如 arm-linux-gnueabihf-gcc 编译器的前缀就是“arm-linux-gnueabihf-”；最后一个参数 distclean 是清除工程*&#x2F;</span><br><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- distclean&#x2F;&#x2F;清理工程</span><br><span class="line"></span><br><span class="line">&#x2F;*mx6ull_14x14_ddr512_emmc_defconfig配置文件*&#x2F;</span><br><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig &#x2F;&#x2F;配置uboot</span><br><span class="line"></span><br><span class="line">&#x2F;*V&#x3D;1 用于设置编译过程的信息输出级别；-j 用于设置主机使用多少线程编译</span><br><span class="line">uboot，最好设置成我们虚拟机所设置的核心数*&#x2F;</span><br><span class="line">make V&#x3D;1 ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- -j12&#x2F;&#x2F;编译uboot</span><br></pre></td></tr></table></figure><p>使用 chmod 命令给予 mx6ull_alientek_emmc.sh 文件可执行权限，然后就使用这个 shell 脚本文件来重新编译 uboot，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;mx6ull_alientek_emmc.sh</span><br></pre></td></tr></table></figure><p><strong>256MB(DDR3)+256MB/512MB(NAND)核心板</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- mx6ull_14x14_ddr256_nand_defconfig</span><br><span class="line">make V&#x3D;1 ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- -j12</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;mx6ull_alientek_nand.sh</span><br></pre></td></tr></table></figure><h2 id="U-Boot-烧写与启动"><a href="#U-Boot-烧写与启动" class="headerlink" title="U-Boot 烧写与启动"></a>U-Boot 烧写与启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 imxdownload &#x2F;&#x2F;给予 imxdownload 可执行权限，一次即可</span><br><span class="line">.&#x2F;imxdownload u-boot.bin &#x2F;dev&#x2F;sdd</span><br></pre></td></tr></table></figure><p>等待烧写完成，完成以后将 SD 卡插到开发板上，BOOT 设置从 SD 卡启 动，使用 USB 线将 将开发板的串口 1 USB_TTL 连接到电脑上。打开 SecureCRT，设置好串口参数并打开，最后复位开发板。在 SecureCRT 上出现“Hit any key to  stop autoboot: ”倒计时的时候按下键盘上的回车键，默认是 3 秒倒计时，在 3 秒倒计时如果没有按下回车键的话 uboot 就会使用默认参数来启动 Linux 内核了。如果在 3 秒倒计时结束之前按下回车键，那么就会进入 uboot 的命令行模式</p><h4 id="uboot-默认输出信息"><a href="#uboot-默认输出信息" class="headerlink" title="uboot 默认输出信息"></a>uboot 默认输出信息</h4><p>具体解析查看【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.5.pdf    P689</p><h2 id="U-Boot-命令使用"><a href="#U-Boot-命令使用" class="headerlink" title="U-Boot 命令使用"></a>U-Boot 命令使用</h2><p>进入 uboot 的命令行模式以后输入“help”或者“？”，然后按下回车即可查看当前 uboot 所支持的命令</p><h3 id="信息查询命令"><a href="#信息查询命令" class="headerlink" title="信息查询命令"></a>信息查询命令</h3><ul><li>bdinfo 命令，用于查看板子信息，从中可以得出 DRAM 的起始地址和大小、启动参数保存起始地址、波特率、 sp(堆栈指针)起始地址等信息</li><li>printenv 命令，用于输出环境变量信息，uboot 中的环境变量都是字符串，比如 bootdelay 这个环境变量就表示 uboot 启动延时时间，默认 bootdelay=3，也就默认延时 3 秒</li><li>version 用于查看 uboot 的版本号</li></ul><h3 id="环境变量操作命令"><a href="#环境变量操作命令" class="headerlink" title="环境变量操作命令"></a>环境变量操作命令</h3><h4 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h4><p>命令 setenv 用于设置或者修改环境变 量的值。命令 saveenv 用于保存修改后的环境变量，一般环境变量是存放在外部 flash 中的，uboot 启动的时候会将环境变量从 flash 读取到 DRAM 中。所以使用命令 setenv 修改的是 DRAM 中的环境变量值，修改以后要使用 saveenv 命令将修改后的环境变量保存到 flash 中，否则的话 uboot 下一次重启会继续使用以前的环境变量值</p><p>比如我们要将环境变量 bootdelay 改为 5，就可以使用如下所示命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootdelay 5</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>有时候我们修改的环境变量值可能会有空格，比如 bootcmd、bootargs 等，这个时候环境变 量值就得用单引号括起来</p><h4 id="新建环境变量"><a href="#新建环境变量" class="headerlink" title="新建环境变量"></a>新建环境变量</h4><p>命令 setenv 也可以用于新建命令，用法就是修改环境变量一样</p><h4 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h4><p>删除环境变量也是使用命令 setenv， 要删除一个环境变量只要给这个环境变量赋空值即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv author</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><h3 id="内存操作命令"><a href="#内存操作命令" class="headerlink" title="内存操作命令"></a>内存操作命令</h3><p>内存操作命令就是用于直接对 DRAM 进行读写操作的，常用的内存操作命令有 md、nm、 mm、mw、cp 和 cmp</p><h4 id="md-命令"><a href="#md-命令" class="headerlink" title="md 命令"></a>md 命令</h4><p>md 命令用于显示内存值，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md[.b, .w, .l] address [# of objects]</span><br></pre></td></tr></table></figure><p>命令中的[.b .w .l]对应 byte、word 和 long，也就是分别以 1 个字节、2 个字节、4 个字节来显示内存值。address 就是要查看的内存起始地址，[# of objects]表示要查看的数据长度，这个数据长度单位不是字节，而是跟你所选择的显示格式有关。比如你设置要查看的内存长度为 20(十六进制为 0x14)，如果显示格式为.b 的话那就表示 20 个字节；如果显示格式为.w 的话就 表示 20 个 word，也就是 20* 2=40 个字节；如果显示格式为.l 的话就表示 20 个 long，也就是 20*4=80 个字节。另外要注意： uboot 命令中的数字都是十六进制的！不是十进制的！ 比如你想查看以 0X80000000 开始的 20 个字节的内存值，显示格式为.b 的话，应该使用如下所示命令：</p><p><em>md.b 80000000 14 而不是： md.b 80000000 20</em></p><p>uboot 命令里面的数字都是十六进制的，所以可以不用写“0x”前缀，十进制 的 20 其十六进制为 0x14，所以命令 md 后面的个数应该是 14，如果写成 20 的话就表示查看 32(十六进制为 0x20)个字节的数据</p><h4 id="nm-命令"><a href="#nm-命令" class="headerlink" title="nm 命令"></a>nm 命令</h4><p>nm 命令用于修改指定地址的内存值，命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm [.b, .w, .l] address</span><br></pre></td></tr></table></figure><p>nm 命令同样可以以.b、.w 和.l 来指定操作格式，比如现在以.l 格式修改 0x80000000 地址 的数据为 0x12345678。输入命令：</p><p><em>nm.l 80000000</em></p><p>80000000 表示现在要修改的内存地址，ffffff00 表示地址 0x80000000 现 在的数据，？后面就可以输入要修改后的数据 0x12345678，输入完成以后按下回车，然后再输 入‘q’即可退出</p><h4 id="mm-命令"><a href="#mm-命令" class="headerlink" title="mm 命令"></a>mm 命令</h4><p>mm 命令也是修改指定地址内存值的，使用 mm 修改内存值的时候地址会自增，而使用命 令 nm 的话地址不会自增</p><h4 id="mw-命令"><a href="#mw-命令" class="headerlink" title="mw 命令"></a>mw 命令</h4><p>命令 mw 用于使用一个指定的数据填充一段内存，命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mw [.b, .w, .l] address value [count]</span><br></pre></td></tr></table></figure><p>mw 命令同样可以以.b、.w 和.l 来指定操作格式，address 表示要填充的内存起始地址，value 为要填充的数据，count 是填充的长度</p><h4 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h4><p>cp 是数据拷贝命令，用于将 DRAM 中的数据从一段内存拷贝到另一段内存中，或者把 Nor  Flash 中的数据拷贝到 DRAM 中。命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [.b, .w, .l] source target count</span><br></pre></td></tr></table></figure><p>cp 命令同样可以以.b、.w 和.l 来指定操作格式，source 为源地址，target 为目的地址，count 为拷贝的长度</p><h4 id="cmp-命令"><a href="#cmp-命令" class="headerlink" title="cmp 命令"></a>cmp 命令</h4><p>cmp 是比较命令，用于比较两段内存的数据是否相等，命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp [.b, .w, .l] addr1 addr2 count</span><br></pre></td></tr></table></figure><p>cmp 命令同样可以以.b、.w 和.l 来指定操作格式，addr1 为第一段内存首地址，addr2 为第 二段内存首地址，count 为要比较的长度</p><h3 id="网络操作命令"><a href="#网络操作命令" class="headerlink" title="网络操作命令"></a>网络操作命令</h3><p>uboot 是支持网络的，我们在移植 uboot 的时候一般都要调通网络功能，因为在移植 linux kernel 的时候需要使用到 uboot 的网络功能做调试。uboot 支持大量的网络相关命令，比如 dhcp、 ping、nfs 和 tftpboot</p><table><thead><tr><th>环境变量</th><th>描述</th></tr></thead><tbody><tr><td>ipaddr</td><td>开发板 ip 地址，可以不设置，使用 dhcp 命令来从路由器获取 IP 地址</td></tr><tr><td>ethaddr</td><td>开发板的 MAC 地址，一定要设置</td></tr><tr><td>gatewayip</td><td>网关地址</td></tr><tr><td>netmask</td><td>子网掩码</td></tr><tr><td>serverip</td><td>服务器 IP 地址，也就是 Ubuntu 主机 IP 地址，用于调试代码</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv ipaddr 192.168.1.40</span><br><span class="line">setenv ethaddr 00:04:9f:04:d2:40</span><br><span class="line">setenv gatewayip 192.168.1.1</span><br><span class="line">setenv netmask 255.255.255.0</span><br><span class="line">setenv serverip 192.168.1.66</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>网络地址环境变量的设置要根据自己的实际情况，确保 Ubuntu 主机和开发板的 IP 地址在同一个网段内，比如开发板和电脑都在 192.168.1.0 这个网段内，所以设置开发板的 IP 地址为 192.168.1.50，Ubuntu 主机的地址为 192.168.1.250，因此 serverip 就是 192.168.1.250。ethaddr 为网络 MAC 地址，是一个 48bit 的地址，如果在同一个网段内有多个开发板的话一定要保证每个开发板的 ethaddr 是不同的</p><h4 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h4><p>开发板的网络能否使用，是否可以和服务器(Ubuntu 主机)进行通信，通过 ping 命令就可 以验证，直接 ping 服务器的 IP 地址即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.1.xxx</span><br></pre></td></tr></table></figure><p>只能在 uboot 中 ping 其他的机器，其他机器不能 ping uboot，因为 uboot 没有对 ping 命令做处理，如果用其他的机器 ping uboot 的话会失败！</p><h4 id="dhcp-命令"><a href="#dhcp-命令" class="headerlink" title="dhcp 命令"></a>dhcp 命令</h4><p>dhcp 用于从路由器获取 IP 地址，前提得开发连接到路由器上的，如果开发板是和电脑直 连的，那么 dhcp 命令就会失效。直接输入 dhcp 命令即可通过路由器获取到 IP 地址</p><p>DHCP 不单单是获取 IP 地址，其还会通过 TFTP 来 启动 linux 内核</p><h4 id="nfs-命令"><a href="#nfs-命令" class="headerlink" title="nfs 命令"></a>nfs 命令</h4><p>nfs(Network File System)网络文件系统，通过 nfs 可以在计算机之间通过网络来分享资源， 比如我们将 linux 镜像和设备树文件放到 Ubuntu 中，然后在 uboot 中使用 nfs 命令将 Ubuntu 中 的 linux 镜像和设备树下载到开发板的 DRAM 中。这样做的目的是为了方便调试 linux 镜像和设备树，也就是网络调试，通过网络调试是 Linux 开发中最常用的调试方法。原因是嵌入式 linux 开发不像单片机开发，可以直接通过 JLINK 或 STLink 等仿真器将代码直接烧写到单片机内部 的 flash 中，嵌入式 Linux 通常是烧写到 EMMC、NAND Flash、SPI Flash 等外置 flash 中，但是嵌入式 Linux 开发也没有 MDK，IAR 这样的 IDE，更没有烧写算法，因此不可能通过点击一个 “download”按钮就将固件烧写到外部 flash 中。虽然半导体厂商一般都会提供一个烧写固件的 软件，但是这个软件使用起来比较复杂，这个烧写软件一般用于量产的。其远没有 MDK、IAR 的一键下载方便，在 Linux 内核调试阶段，如果用这个烧写软件的话将会非常浪费时间，而这个时候网络调试的优势就显现出来了，可以通过网络将编译好的 linux 镜像和设备树文件下载到 DRAM 中，然后就可以直接运行</p><p>我们一般使用 uboot 中的 nfs 命令将 Ubuntu 中的文件下载到开发板的 DRAM 中，在使用之前需要开启 Ubuntu 主机的 NFS 服务，并且要新建一个 NFS 使用的目录，以后所有要通过 NFS 访问的文件都需要放到这个 NFS 目录中</p><p>uboot 中的 nfs 命令格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nfs [loadAddress] [[hostIPaddr:]bootfilename]</span><br></pre></td></tr></table></figure><p>loadAddress 是要保存的 DRAM 地址，[[hostIPaddr:]bootfilename]是要下载的文件地址</p><p>准备好以后就可以使用 nfs 命令来将 zImage 下载到开发板 DRAM 的 0X80800000 地址处， 命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nfs 80800000 192.168.1.250:&#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;nfs&#x2F;zImage</span><br></pre></td></tr></table></figure><p>命令中的“ 80800000 ” 表 示 zImage 保 存 地 址 ， “192.168.1.250:/home/chenzhan/linux/nfs/zImage”表示 zImage 在 192.168.1.250 这个主机中， 路径为/home/chenzhan/linux/nfs/zImage</p><p>会以“#”提示下载过程，下载完成以后会提示下载的数据大小</p><p>下载完成以后查看 0x80800000 地址处的数据，使用命令 md.b 来查看前 0x100 个字节的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md.b 80800000 100</span><br></pre></td></tr></table></figure><h4 id="tftp-命令"><a href="#tftp-命令" class="headerlink" title="tftp 命令"></a>tftp 命令</h4><p>tftp 命令的作用和 nfs 命令一样，都是用于通过网络下载东西到 DRAM 中，只是 tftp 命令 使用的 TFTP 协议，Ubuntu 主机作为 TFTP 服务器。因此需要在 Ubuntu 上搭建 TFTP 服务器， 需要安装 tftp-hpa 和 tftpd-hpa，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tftp-hpa tftpd-hpa</span><br><span class="line">sudo apt-get install xinetd</span><br></pre></td></tr></table></figure><p>和 NFS 一样，TFTP 也需要一个文件夹来存放文件，在用户目录下新建一个目录，命令如 下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;home&#x2F;chenzhan&#x2F;linux&#x2F;tftpboot</span><br><span class="line">chmod 777 &#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;tftpboot</span><br></pre></td></tr></table></figure><p>这 样 我 就 在 我 的 电 脑 上 创 建 了 一 个 名 为 tftpboot 的 目 录 ( 文件夹 ) ， 路 径 为 /home/chenzhan/linux/tftpboot。注意！我们要给 tftpboot 文件夹权限，否则的话 uboot 不能从 tftpboot 文件夹里面下载文件</p><p>最后配置 tftp，安装完成以后新建文件/etc/xinetd.d/tftp，如果没有/etc/xinetd.d 目录的话自行 创建，然后在里面输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server tftp</span><br><span class="line">&#123;</span><br><span class="line">socket_type &#x3D; dgram</span><br><span class="line">protocol &#x3D; udp</span><br><span class="line">wait &#x3D; yes</span><br><span class="line">user &#x3D; root</span><br><span class="line">server &#x3D; &#x2F;usr&#x2F;sbin&#x2F;in.tftpd</span><br><span class="line">server_args &#x3D; -s &#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;tftpboot&#x2F;</span><br><span class="line">disable &#x3D; no</span><br><span class="line">per_source &#x3D; 11</span><br><span class="line">cps &#x3D; 100 2</span><br><span class="line">flags &#x3D; IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完了以后启动 tftp 服务，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service tftpd-hpa start</span><br></pre></td></tr></table></figure><p>打开/etc/default/tftpd-hpa 文件，将其修改为如下所示内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;default&#x2F;tftpd-hpa</span><br><span class="line"></span><br><span class="line">TFTP_USERNAME&#x3D;&quot;tftp&quot;</span><br><span class="line">TFTP_DIRECTORY&#x3D;&quot;&#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;tftpboot&quot;</span><br><span class="line">TFTP_ADDRESS&#x3D;&quot;:69&quot; </span><br><span class="line">TFTP_OPTIONS&#x3D;&quot;-l -c -s&quot;</span><br></pre></td></tr></table></figure><p>TFTP_DIRECTORY 就是我们上面创建的 tftp 文件夹目录，以后我们就将所有需要通过 TFTP 传输的文件都放到这个文件夹里面，并且要给予这些文件相应的权限</p><p>最后输入如下命令， 重启 tftp 服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service tftpd-hpa restart</span><br></pre></td></tr></table></figure><p>tftp 服务器已经搭建好了，接下来就是使用了。将 zImage 镜像文件拷贝到 tftpboot 文件夹 中，并且给予 zImage 相应的权限，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp zImage &#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;tftpboot&#x2F;</span><br><span class="line">cd &#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;tftpboot&#x2F;</span><br><span class="line">chmod 777 zImage</span><br></pre></td></tr></table></figure><p>uboot 中的 tftp 命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tftpboot [loadAddress] [[hostIPaddr:]bootfilename]</span><br></pre></td></tr></table></figure><p>看起来和 nfs 命 令 格式 一 样 的 ， loadAddress 是文件在 DRAM 中 的存 放 地 址 ， [[hostIPaddr:]bootfilename]是要从 Ubuntu 中下载的文件。但是和 nfs 命令的区别在于，tftp 命令 不需要输入文件在 Ubuntu 中的完整路径，只需要输入文件名即可。比如我们现在将 tftpboot 文 件夹里面的 zImage 文件下载到开发板 DRAM 的 0X80800000 地址处，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tftp 80800000 zImage</span><br></pre></td></tr></table></figure><p>md.b 命令来查看前 100 个字节的数据</p><p>“TFTP error: ‘Permission denied’ (0)”这样的错误提示，提示没有权限，出现这个错误一般有两个原因：</p><ol><li>在 Ubuntu 中创建 tftpboot 目录的时候没有给予 tftboot 相应的权限</li><li>tftpboot 目录中要下载的文件没有给予相应的权限。 针对上述两个问题，使用命令“chmod 777 xxx”来给予权限，其中“xxx”就是要给予权限 的文件或文件夹</li></ol><h3 id="EMMC-和-SD-卡操作命令"><a href="#EMMC-和-SD-卡操作命令" class="headerlink" title="EMMC 和 SD 卡操作命令"></a>EMMC 和 SD 卡操作命令</h3><p>uboot 支持 EMMC 和 SD 卡，因此也要提供 EMMC 和 SD 卡的操作命令。一般认为 EMMC 和 SD 卡是同一个东西，所以没有特殊说明</p><p>uboot 中常用于操作 MMC 设备的命令为“mmc”</p><p>mmc 是一系列的命令，其后可以跟不同的参数，输入“？mmc”即可查看 mmc 有关的命 令</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>mmc info</td><td>输出MMC设备信息</td></tr><tr><td>mmc read</td><td>读取MMC中的数据</td></tr><tr><td>mmc wirte</td><td>向MMC设备写入数据</td></tr><tr><td>mmc rescan</td><td>扫描MMC设备</td></tr><tr><td>mmc  part</td><td>列出MMC设备的分区</td></tr><tr><td>mmc dev</td><td>切换MMC设备</td></tr><tr><td>mmc list</td><td>列出当前有效的所有 MMC 设备</td></tr><tr><td>mmc hwpartition</td><td>设置 MMC 设备的分区</td></tr><tr><td>mmc bootbus……</td><td>设置指定 MMC 设备的 BOOT_BUS_WIDTH 域的值</td></tr><tr><td>mmc bootpart……</td><td>设置指定 MMC 设备的 boot 和 RPMB 分区的大小</td></tr><tr><td>mmc partconf……</td><td>设置指定 MMC 设备的 PARTITION_CONFG 域的值</td></tr><tr><td>mmc rst</td><td>复位 MMC 设备</td></tr><tr><td>mmc setdsr</td><td>设置 DSR 寄存器的值</td></tr></tbody></table><h4 id="mmc-info-命令"><a href="#mmc-info-命令" class="headerlink" title="mmc info 命令"></a>mmc info 命令</h4><p>mmc info 命令用于输出当前选中的 mmc info 设备的信息</p><p>可以看出，当前选中的 MMC设备是 EMMC，版本为 4.5，容量为 3.7GiB(EMMC 为 4GB)，速度为 52000000Hz=52MHz，8 位宽的总线。还有一个与 mmc info 命令相同功能的命令：mmcinfo，“mmc”和“info”之间没有空格</p><h4 id="mmc-rescan-命令"><a href="#mmc-rescan-命令" class="headerlink" title="mmc rescan 命令"></a>mmc rescan 命令</h4><p>mmc rescan 命令用于扫描当前开发板上所有的 MMC 设备，包括 EMMC 和 SD 卡</p><h4 id="mmc-list-命令"><a href="#mmc-list-命令" class="headerlink" title="mmc list 命令"></a>mmc list 命令</h4><p>mmc list 命令用于来查看当前开发板一共有几个 MMC 设备</p><p>FSL_SDHC:0 是 SD 卡，FSL_SDHC:1(eMMC)是 EMMC，。默认会将 EMMC 设置为当前 MMC 设备，这就是为什么 输入“mmc info”查询到的是 EMMC 设备信息，而不是 SD 卡。要想查看 SD 卡信息，就要使 用命令“mmc dev”来将 SD 卡设置为当前的 MMC 设备</p><h4 id="mmc-dev-命令"><a href="#mmc-dev-命令" class="headerlink" title="mmc dev 命令"></a>mmc dev 命令</h4><p>mmc dev 命令用于切换当前 MMC 设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc dev [dev] [part]</span><br></pre></td></tr></table></figure><p>[dev]用来设置要切换的 MMC 设备号，[part]是分区号。如果不写分区号的话默认为分区 0。 使用如下命令切换到 SD 卡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 0 &#x2F;&#x2F;切换到 SD 卡，0 为 SD 卡，1 为 eMMC</span><br></pre></td></tr></table></figure><p>切换到 SD 卡成功，mmc0 为当前的 MMC 设备，输入命令“mmc info”即可查看 SD 卡的信息</p><h4 id="mmc-part-命令"><a href="#mmc-part-命令" class="headerlink" title="mmc part 命令"></a>mmc part 命令</h4><p>有时候 SD 卡或者 EMMC 会有多个分区，可以使用命令“mmc part”来查看其分区，比如 查看 EMMC 的分区情况，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 1 &#x2F;&#x2F;切换到 EMMC</span><br><span class="line">mmc part &#x2F;&#x2F;查看 EMMC 分区</span><br></pre></td></tr></table></figure><p>可以看出，此时 EMMC 有两个分区，扇区 20480<del>1024000 为第一个分区， 扇区 1228800</del>6504448 为第二个分区。如果 EMMC 里面烧写了 Linux 系统的话，EMMC 是有 3 个分区的，第 0 个分区存放 uboot，第 1 个分区存放 Linux 镜像文件和设备树，第 2 个分区存 放根文件系统。但是在图中只有两个分区，那是因为第 0 个分区没有格式化，所以识别不出来，实际上第 0 个分区是存在的。一个新的 SD 卡默认只有一个分区，那就是分区 0，所以前面讲解的 uboot 烧写到 SD 卡，其实就是将 u-boot.bin 烧写到了 SD 卡的分区 0 里面。后面再学习 Linux 内核移植的时候怎么在 SD 卡中创建并格式化第二个分区，并将 Linux 镜像 文件和设备树文件存放到第二个分区中</p><p>如果要将 EMMC 的分区 2 设置为当前 MMC 设置，可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 1 2</span><br></pre></td></tr></table></figure><h4 id="mmc-read-命令"><a href="#mmc-read-命令" class="headerlink" title="mmc read 命令"></a>mmc read 命令</h4><p>mmc read 命令用于读取 mmc 设备的数据，命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc read addr blk# cnt</span><br></pre></td></tr></table></figure><p>addr 是数据读取到 DRAM 中的地址，blk 是要读取的块起始地址(十六进制)，一个块是 512 字节，这里的块和扇区是一个意思，在 MMC 设备中我们通常说扇区，cnt 是要读取的块数量(十 六进制)。比如从 EMMC 的第 1536(0x600)个块开始，读取 16(0x10)个块的数据到 DRAM 的 0X80800000 地址处，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 1 0 &#x2F;&#x2F;切换到 MMC 分区 0</span><br><span class="line">mmc read 80800000 600 10 &#x2F;&#x2F;读取数据</span><br></pre></td></tr></table></figure><p>可以看到“D$..baudrate=115200.board_name=EVK.board_rev=14X14.”等字 样，这个就是 uboot 中的环境变量。EMMC 核心板 uboot 环境变量的存储起始地址就是 1536*512=786432</p><h4 id="mmc-write-命令"><a href="#mmc-write-命令" class="headerlink" title="mmc write 命令"></a>mmc write 命令</h4><p>要将数据写到 MMC 设备里面，可以使用命令“mmc write”，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc write addr blk# cnt</span><br></pre></td></tr></table></figure><p>addr 是要写入 MMC 中的数据在 DRAM 中的起始地址，blk 是要写入 MMC 的块起始地址 (十六进制)，cnt 是要写入的块大小，一个块为 512 字节。我们可以使用命令“mmc write”来升 级 uboot，也就是在 uboot 中更新 uboot。这里要用到 nfs 或者 tftp 命令，通过 nfs 或者 tftp 命令 将新的 u-boot.bin 下载到开发板的 DRAM 中，然后再使用命令“mmc write”将其写入到 MMC 设备中。我们就来更新一下 SD 中的 uboot，先查看一下 SD 卡中的 uboot 版本号，注意编译时间，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 0 &#x2F;&#x2F;切换到 SD 卡</span><br><span class="line">version &#x2F;&#x2F;查看版本号</span><br></pre></td></tr></table></figure><p>可以看出当前 SD 卡中的 uboot 是 2019 年 4 月 15 日 12:52:04 编译的。我们现在重新编译 一下 uboot，然后将编译出来的 u-boot.imx(u-boot.bin 前面加了一些头文件)拷贝到 Ubuntu 中的 tftpboot 目录下。最后使用 tftp 命令将其下载到 0x80800000 地址处，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tftp 80800000 u-boot.imx</span><br></pre></td></tr></table></figure><p>同理，如果要在 uboot 中更新 EMMC 对应的 uboot，可以使用如下所示命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 1 0 &#x2F;&#x2F;切换到 EMMC 分区 0</span><br><span class="line">tftp 80800000 u-boot.imx &#x2F;&#x2F;下载 u-boot.imx 到 DRAM</span><br><span class="line">mmc write 80800000 2 32E &#x2F;&#x2F;烧写 u-boot.imx 到 EMMC 中</span><br><span class="line">mmc partconf 1 1 0 0 &#x2F;&#x2F;分区配置，EMMC 需要这一步！</span><br></pre></td></tr></table></figure><p>千万不要写 SD 卡或者 EMMC 的前两个块(扇区)，里面保存着分区表！</p><h4 id="mmc-erase-命令"><a href="#mmc-erase-命令" class="headerlink" title="mmc erase 命令"></a>mmc erase 命令</h4><p>如果要擦除 MMC 设备的指定块就是用命令“mmc erase”，命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc erase blk# cnt</span><br></pre></td></tr></table></figure><p>blk 为要擦除的起始块，cnt 是要擦除的数量。没事不要用 mmc erase 来擦除 MMC 设备！！！</p><h3 id="FAT-格式文件系统操作命令"><a href="#FAT-格式文件系统操作命令" class="headerlink" title="FAT 格式文件系统操作命令"></a>FAT 格式文件系统操作命令</h3><p>有时候需要在 uboot 中对 SD 卡或者 EMMC 中存储的文件进行操作，这时候就要用到文件 操作命令，跟文件操作相关的命令有：fatinfo、fatls、fstype、fatload 和 fatwrite，但是这些文件 操作命令只支持 FAT 格式的文件系统！！</p><ul><li>fatinfo 命令用于查询指定 MMC 设置指定分区的文件系统信息</li><li>fatls 命令用于查询 FAT 格式设备的目录和文件信息</li><li>fstype 用于查看 MMC 设备某个分区的文件系统格式</li><li>fatload 命令用于将指定的文件读取到 DRAM 中</li><li>fatwirte 命令用于将 DRAM 中的数据写入到 MMC 设备中</li></ul><h3 id="EXT-格式文件系统操作命令"><a href="#EXT-格式文件系统操作命令" class="headerlink" title="EXT 格式文件系统操作命令"></a>EXT 格式文件系统操作命令</h3><p>uboot 有 ext2 和 ext4 这两种格式的文件系统的操作命令，常用的就四个命令，分别为： ext2load、ext2ls、ext4load、ext4ls 和 ext4write。这些命令的含义和使用与 fatload、fatls 和 fatwrit 一样，只是 ext2 和 ext4 都是针对 ext 文件系统的。比如 ext4ls 命令，EMMC 的分区 2 就是 ext4 格式的，使用 ext4ls 就可以查询 EMMC 的分区 2 中的文件和目录，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext4ls mmc 1:2</span><br></pre></td></tr></table></figure><h3 id="NAND-操作命令"><a href="#NAND-操作命令" class="headerlink" title="NAND 操作命令"></a>NAND 操作命令</h3><p>uboot 是支持 NAND Flash 的，所以也有 NAND Flash 的操作命令，前提是使用的 NAND 版 本的核心板，并且编译 NAND 核心板对应的 uboot，然后使用 imxdownload 软件将 u-boot.bin 烧 写到 SD 卡中，最后通过 SD 卡启动</p><p>一般情况下 NAND 版本的核心板已经烧写好了 uboot、 linux kernel 和 rootfs 这些文件，所以可以将 BOOT 拨到 NAND，然后直接从 NAND Flash 启动 即可</p><ul><li>nand info 命令此命令用户打印 NAND Flash 信息</li><li>nand device 用于切换 NAND Flash</li><li>nand erase 命令用于擦除 NAND Flash</li><li>nand write 此命令用于向 NAND 指定地址写入指定的数据，一般和“nand erase”命令配置使用来更新 NAND 中的 uboot、linux kernel 或设备树等文件</li><li>nand read 命令用于从 NAND 中的指定地址读取指定大小的数据到 DRAM 中</li></ul><h3 id="BOOT-操作命令"><a href="#BOOT-操作命令" class="headerlink" title="BOOT 操作命令"></a>BOOT 操作命令</h3><p>uboot 的本质工作是引导 Linux，所以 uboot 肯定有相关的 boot(引导)命令来启动 Linux。常 用的跟 boot 有关的命令有：bootz、bootm 和 boot</p><ul><li>bootz 命令用于启动 zImage 镜像文件</li><li>bootm 和 bootz 功能类似，但是 bootm 用于启动 uImage 镜像文件</li><li>boot 命令也是用来启动 Linux 系统的，只是 boot 会读取环境变量 bootcmd 来启动 Linux 系 统，bootcmd 是一个很重要的环境变量！</li></ul><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><p>uboot 中还有其他一些常用的命令，比如 reset、go、run 和 mtest 等。</p><ul><li>reset 命令是复位的，输入“reset”即可复位重启</li><li>go 命令用于跳到指定的地址处执行应用</li><li>run 命令用于运行环境变量中定义的命令</li><li>mtest 命令是一个简单的内存读写测试命令，可以用来测试自己开发板上的 DDR</li></ul><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;U-Boot&quot;&gt;&lt;a href=&quot;#U-Boot&quot; class=&quot;headerlink&quot; title=&quot;U-Boot&quot;&gt;&lt;/a&gt;U-Boot&lt;/h1&gt;&lt;h2 id=&quot;U-B</summary>
      
    
    
    
    
    <category term="系统移值" scheme="https://www.chenzhan.club/tags/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>note27.3-数据结构概念二</title>
    <link href="https://www.chenzhan.club/2021/03/08/note27-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E4%BA%8C/"/>
    <id>https://www.chenzhan.club/2021/03/08/note27-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E4%BA%8C/</id>
    <published>2021-03-08T13:44:00.000Z</published>
    <updated>2021-04-12T13:32:39.425Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="结构体基础知识"><a href="#结构体基础知识" class="headerlink" title="结构体基础知识"></a>结构体基础知识</h2><h3 id="结构体类型的定义"><a href="#结构体类型的定义" class="headerlink" title="结构体类型的定义"></a>结构体类型的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Person&#123;</span><br><span class="line">char name[64];</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct _PERSON&#123;</span><br><span class="line">char name[64];</span><br><span class="line">int age;</span><br><span class="line">&#125;Person;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值</p><h3 id="结构体变量的定义"><a href="#结构体变量的定义" class="headerlink" title="结构体变量的定义"></a>结构体变量的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Person&#123;</span><br><span class="line">char name[64];</span><br><span class="line">int age;</span><br><span class="line">&#125;p1; &#x2F;&#x2F;定义类型同时定义变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct&#123;</span><br><span class="line">char name[64];</span><br><span class="line">int age;</span><br><span class="line">&#125;p2; &#x2F;&#x2F;定义类型同时定义变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Person p3; &#x2F;&#x2F;通过类型直接定义</span><br></pre></td></tr></table></figure><h3 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h3><h3 id="结构体成员的使用"><a href="#结构体成员的使用" class="headerlink" title="结构体成员的使用"></a>结构体成员的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Person&#123;</span><br><span class="line">char name[64];</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">&#x2F;&#x2F;在栈上分配空间</span><br><span class="line">struct Person p1;</span><br><span class="line">strcpy(p1.name, &quot;John&quot;);</span><br><span class="line">p1.age &#x3D; 30;</span><br><span class="line">&#x2F;&#x2F;如果是普通变量，通过点运算符操作结构体成员</span><br><span class="line">printf(&quot;Name:%s Age:%d\n&quot;, p1.name, p1.age);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在堆上分配空间</span><br><span class="line">struct Person* p2 &#x3D; (struct Person*)malloc(sizeof(struct Person));</span><br><span class="line">strcpy(p2-&gt;name, &quot;Obama&quot;);</span><br><span class="line">p2-&gt;age &#x3D; 33;</span><br><span class="line">&#x2F;&#x2F;如果是指针变量，通过-&gt;操作结构体成员</span><br><span class="line">printf(&quot;Name:%s Age:%d\n&quot;, p2-&gt;name, p2-&gt;age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果有typedef， 定义结构体，那么后面跟着的单词是类型的别名</li><li>没有typedef，定义结构体，后面跟着的单词是一个结构体变量</li><li>结构体数组<ul><li>在栈上开辟</li><li>在堆区开辟</li></ul></li></ul><h3 id="结构体赋值问题以及解决"><a href="#结构体赋值问题以及解决" class="headerlink" title="结构体赋值问题以及解决"></a>结构体赋值问题以及解决</h3><p>相同的两个结构体变量可以相互赋值，把一个结构体变量的值拷贝给另一个结构体，这两个变量还是两个独立的变量</p><p>系统提供的赋值操作是简单的值拷贝，逐字节拷贝—- 浅拷贝</p><p>如果属性中有指向堆区的内容，在释放期间会导致堆区重复释放，并且还有内存泄露</p><p>解决方案：利用深拷贝，手动赋值</p><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;一个老师有N个学生</span><br><span class="line">typedef struct _TEACHER&#123;</span><br><span class="line">char* name;</span><br><span class="line">&#125;Teacher;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line"></span><br><span class="line">Teacher t1;</span><br><span class="line">t1.name &#x3D; malloc(64);</span><br><span class="line">strcpy(t1.name , &quot;John&quot;);</span><br><span class="line"></span><br><span class="line">Teacher t2;</span><br><span class="line">t2 &#x3D; t1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对手动开辟的内存，需要手动拷贝</span><br><span class="line">t2.name &#x3D; malloc(64);</span><br><span class="line">strcpy(t2.name, t1.name);</span><br><span class="line"></span><br><span class="line">if (t1.name !&#x3D; NULL)&#123;</span><br><span class="line">free(t1.name);</span><br><span class="line">t1.name &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">if (t2.name !&#x3D; NULL)&#123;</span><br><span class="line">free(t2.name);</span><br><span class="line">t1.name &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><h2 id="结构体嵌套指针"><a href="#结构体嵌套指针" class="headerlink" title="结构体嵌套指针"></a>结构体嵌套指针</h2><h3 id="结构体嵌套一级指针"><a href="#结构体嵌套一级指针" class="headerlink" title="结构体嵌套一级指针"></a>结构体嵌套一级指针</h3><ol><li>设计结构体 struct Person { char * name,int age }</li><li>在堆区创建 结构体指针数组  malloc(sizeof(struct Person *) * 3);</li><li>给每个结构体也分配到堆区</li><li>给每个结构体的姓名分配到堆区</li><li>打印数组中所有人的信息</li><li>释放堆区数据</li></ol><h3 id="结构体嵌套二级指针"><a href="#结构体嵌套二级指针" class="headerlink" title="结构体嵌套二级指针"></a>结构体嵌套二级指针</h3><h3 id="结构体成员偏移量"><a href="#结构体成员偏移量" class="headerlink" title="结构体成员偏移量"></a>结构体成员偏移量</h3><p>一旦结构体定义下来，则结构体中的成员内存布局就定下了</p><p>可以利用offsetof来计算结构体中属性的偏移</p><p>也可以通过地址的相加运算 计算偏移量</p><p>结构体嵌套结构体</p><h3 id="结构体字节对齐"><a href="#结构体字节对齐" class="headerlink" title="结构体字节对齐"></a>结构体字节对齐</h3><p>在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题</p><p>从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是事实上不是如此，实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是内存对齐</p><h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><h5 id="内存对齐原因"><a href="#内存对齐原因" class="headerlink" title="内存对齐原因"></a>内存对齐原因</h5><p>内存对齐原因：以空间换时间</p><p>内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取</p><p>但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等</p><p><em>非内存对齐和内存对齐的优缺点在哪？</em></p><p>内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)。如果没有对齐，为了访问一个变量可能产生二次访问</p><p><em>为什么要简单内存对齐？</em></p><p>提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量</p><p>某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统</p><h5 id="对于自定义数据类型对齐规则"><a href="#对于自定义数据类型对齐规则" class="headerlink" title="对于自定义数据类型对齐规则"></a>对于自定义数据类型对齐规则</h5><ol><li>从第一个属性开始 偏移为0 </li><li>第二个属性开始，地址要放在该类型整数倍与对齐模数比取小的值的整数倍上</li><li>所有的属性都计算结束后，整体再做二次对齐，整体需要放在属性中最大类型与对齐模数比取小的值的整数倍上</li></ol><h5 id="如何内存对齐"><a href="#如何内存对齐" class="headerlink" title="如何内存对齐"></a>如何内存对齐</h5><p>默认对齐模数  是8，可以将对齐模数改为 2的n次方</p><p>当结构体嵌套结构体时候，只需要看子结构体中最大数据类型就可以了</p><p>对于标准数据类型，它的地址只要是它的长度的整数倍。</p><p>对于非标准数据类型，比如结构体，要遵循一下对齐原则：</p><ul><li>数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为min（当前成员的大小，#pargama pack(n)）整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）</li><li> 结构体总的大小，也就是sizeof的结果，必须是min（结构体内部最大成员，#pargama pack(n)）的整数倍，不足要补齐</li><li>结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2</li></ul><p>手动设置对齐模数:</p><ul><li><p>#pragma  pack(show)</p><p>显示当前packing alignment的字节数，以warning message的形式被显示</p></li><li><p>#pragma pack(push)   </p><p>将当前指定的packing alignment数组进行压栈操作，这里的栈是the internal compiler stack,同事设置当前的packing  alignment为n；如果n没有指定，则将当前的packing alignment数组压栈</p></li><li><p>#pragma pack(pop)  </p><p>从internal compiler stack中删除最顶端的reaord; 如果没有指定n,则当前栈顶record即为新的packing alignement数值；如果指定了n，则n成为新的packing  alignment值 </p></li><li><p>#pragma pack(n) </p><p>指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16</p></li></ul><h4 id="内存对齐案例"><a href="#内存对齐案例" class="headerlink" title="内存对齐案例"></a>内存对齐案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(4)</span><br><span class="line"></span><br><span class="line">typedef struct _STUDENT&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">double c;</span><br><span class="line">float d;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line">typedef struct _STUDENT2&#123;</span><br><span class="line">char a;</span><br><span class="line">Student b; </span><br><span class="line">double c;</span><br><span class="line">&#125;Student2;</span><br><span class="line"></span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Student</span><br><span class="line">&#x2F;&#x2F;a从偏移量0位置开始存储</span><br><span class="line">&#x2F;&#x2F;b从4位置开始存储</span><br><span class="line">&#x2F;&#x2F;c从8位置开始存储</span><br><span class="line">&#x2F;&#x2F;d从12位置开存储</span><br><span class="line">&#x2F;&#x2F;所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24</span><br><span class="line"></span><br><span class="line">printf(&quot;sizeof Student:%d\n&quot;,sizeof(Student));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Student2 </span><br><span class="line">&#x2F;&#x2F;a从偏移量为0位置开始 </span><br><span class="line">&#x2F;&#x2F;b从偏移量为Student内部最大成员整数倍开始，也就是8开始</span><br><span class="line">&#x2F;&#x2F;c从8的整数倍地方开始,也就是32开始</span><br><span class="line">&#x2F;&#x2F;所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40</span><br><span class="line">printf(&quot;sizeof Student2:%d\n&quot;, sizeof(Student2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有关结构体的自身引用"><a href="#有关结构体的自身引用" class="headerlink" title="有关结构体的自身引用"></a>有关结构体的自身引用</h2><ul><li>结构体可以嵌套另外一个结构体的任何类型变量</li><li>结构体嵌套本结构体普通变量（不可以）。本结构体的类型大小无法确定，类型本质：固定大小内存块别名</li><li>结构体嵌套本结构体指针变量（可以）, 指针变量的空间能确定，32位， 4字节， 64位， 8字节</li></ul><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>文件在今天的计算机系统中作用是很重要的。文件用来存放程序、文档、数据、表格、图片和其他很多种类的信息。作为一名程序员，须学会使用编程来创建、写入和读取文件。编写程序从文件读取信息或者将结果写入文件是一种经常性的需求。C提供了强大的和文件进行通信的方法。使用这种方法我们可以在程序中打开文件，然后使用专门的I/O函数读取文件或者写入文件</p><h2 id="文件相关概念"><a href="#文件相关概念" class="headerlink" title="文件相关概念"></a>文件相关概念</h2><p>一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，是操作系统关心的事情。我们应该考虑如何在C程序中处理文件</p><h2 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h2><p>流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象</p><p>C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的</p><h3 id="文本流"><a href="#文本流" class="headerlink" title="文本流"></a>文本流</h3><p>文本流，也就是我们常说的以文本模式读取文件。文本流的有些特性在不同的系统中可能不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只使用一个换行符结尾</p><p>标准C把文本定义为零个或者多个字符，后面跟一个表示结束的换行符(\n).对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式和内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形势而操纵文本的能力简化了可移植程序的创建</p><h3 id="二进制流"><a href="#二进制流" class="headerlink" title="二进制流"></a>二进制流</h3><p>二进制流中的字节将完全根据程序编写它们的形式写入到文件中，而且完全根据它们从文件或设备读取的形式读入到程序中。它们并未做任何改变。这种类型的流适用于非文本数据，但是如果你不希望I/O函数修改文本文件的行末字符，也可以把它们用于文本文件</p><p>c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。</p><p><strong>我们程序中，经常看到的文本方式打开文件和二进制方式打开文件仅仅体现在换行符的处理上</strong></p><p>比如说，在widows下，文件的换行符是\r\n，而在Linux下换行符则是\n</p><p>当对文件使用文本方式打开的时候，读写的windows文件中的换行符\r\n会被替换成\n读到内存中，当在windows下写入文件的时候，\n被替换成\r\n再写入文件。如果使用二进制方式打开文件，则不进行\r\n和\n之间的转换。 那么由于Linux下的换行符就是\n,所以文本文件方式和二进制方式无区别</p><h2 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h2><h3 id="文件流总览"><a href="#文件流总览" class="headerlink" title="文件流总览"></a>文件流总览</h3><p>标准库函数是的我们在C程序中执行与文件相关的I/O任务非常方便。下面是关于文件I/O的一般概况</p><ol><li>程序为同时处于活动状态的每个文件声明一个指针变量，其类型为FILE*。这个指针指向这个FILE结构，当它处于活动状态时由流使用</li><li>流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式(读、写、或者读写)。Fopen和操作系统验证文件或者设备是否存在并初始化FILE</li><li>根据需要对文件进行读写操作</li><li>最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放FILE结构</li></ol><p>标准I/O更为简单，因为它们并不需要打开或者关闭</p><p>I/O函数以三种基本的形式处理数据：<strong>单个字符</strong>、<strong>文本行</strong>和<strong>二进制数据</strong>。对于每种形式都有一组特定的函数对它们进行处理</p><p><strong>输入/输出函数家族</strong></p><table><thead><tr><th>家族名</th><th>目的</th><th>可用于所有流</th><th>只用于stdin和stdout</th></tr></thead><tbody><tr><td>getchar</td><td>字符输入</td><td>fgetc、getc</td><td>getchar</td></tr><tr><td>putchar</td><td>字符输出</td><td>fputc、putc</td><td>putchar</td></tr><tr><td>gets</td><td>文本行输入</td><td>fgets</td><td>gets</td></tr><tr><td>puts</td><td>文本行输出</td><td>fputs</td><td>puts</td></tr><tr><td>scanf</td><td>格式化输入</td><td>fscanf</td><td>scanf</td></tr><tr><td>printf</td><td>格式化输出</td><td>fprintf</td><td>printf</td></tr></tbody></table><p>fgetc：函数从流中返回一个字符值</p><p>getc：从流中取字符</p><p>fputc：函数功能： 将<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6/4768913">字符</a>c写到文件指针fp所指向的文件的当前写指针的位置</p><p>putc：putc，原型是int fputc，功能是输出一字符到指定流中</p><p>fscanf：功能为根据数据格式(format)，从输入流(stream)中读入数据，存储到argument中，遇到空格和换行时结束。fscanf位于C标准库头文件&lt;stdio.h&gt;中</p><p>fprintf：是C/C++中的一个格式化库函数，位于头文件<cstdio>中，其作用是格式化输出到一个流文件中；fprintf()函数根据指定的格式(format)，向输出流(stream)写入数据(argument)</cstdio></p><p>stdin：标准输入流，一般指键盘输入到缓冲区里的东西</p><p>stdout：一个定义在&lt;stdio.h&gt;的宏（macro），它展开到一个 FILE* （“指向 FILE 的指针”）类型的表达式（不一定是常量），这个表达式指向一个与标准输出流（standard output stream）相关连的 FILE 对象</p><h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p>文件是由操作系统管理的单元。操作一个文件的时候，让操作系统帮我们打开文件，操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指针指向文件的信息。文件指针也可以理解为代指打开的文件。这个指针的类型为FILE类型。该类型定义在stdio.h头文件中。通过文件指针，我们就可以对文件进行各种操作</p><p>对于每一个ANSI C程序，运行时系统必须提供至少三个流-标准输入(stdin)、标准输出(stdout)、标准错误(stderr)，它们都是一个指向FILE结构的指针。标准输入是缺省情况下的输入来源，标准输出时缺省情况下的输出设置。具体缺省值因编译器而异，通常标准输入为键盘设备、标准输出为终端或者屏幕</p><p>ANSI C并未规定FILE的成员，不同编译器可能有不同的定义。VS下FILE信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct _iobuf &#123; </span><br><span class="line">        char  *_ptr;         &#x2F;&#x2F;文件输入的下一个位置 </span><br><span class="line">        int   _cnt;          &#x2F;&#x2F;剩余多少字符未被读取</span><br><span class="line">        char  *_base;        &#x2F;&#x2F;指基础位置(应该是文件的其始位置) </span><br><span class="line">        int   _flag;         &#x2F;&#x2F;文件标志 </span><br><span class="line">        int   _file;         &#x2F;&#x2F;文件的有效性验证 </span><br><span class="line">        int   _charbuf;      &#x2F;&#x2F;检查缓冲区状况,如果无缓冲区则不读取 </span><br><span class="line">        int   _bufsiz;       &#x2F;&#x2F;文件的大小 </span><br><span class="line">        char  *_tmpfname;    &#x2F;&#x2F;临时文件名 </span><br><span class="line">&#125;; </span><br><span class="line">typedef struct _iobuf FILE;</span><br></pre></td></tr></table></figure><h3 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h3><p>ANSI C标准采用“缓冲文件系统”处理数据文件 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量)</p><p><em>文件缓冲区有什么作用呢？</em></p><p>如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度</p><h2 id="文件读写回顾"><a href="#文件读写回顾" class="headerlink" title="文件读写回顾"></a>文件读写回顾</h2><ul><li><p>按照字符进行读写</p><ul><li>写文件 fputc</li><li>读文件 fgetc</li><li>文件结尾 EOF  END OF FILE</li></ul></li><li><p>按行读写</p><ul><li>写文件 fputs</li><li>读文件 fgets</li></ul></li><li><p>按块读写</p><ul><li>写文件 fwrite <ul><li>参数1 数据地址  参数2 块大小  参数3 块个数  参数4 文件指针</li></ul></li><li>读文件 fread</li></ul></li><li><p>按格式化读写</p><ul><li>写文件fprintf</li><li>读文件fscanf</li></ul></li><li><p>随机位置读写</p><ul><li>fseek （文件指针，偏移， 起始位置 SEEK_SET SEEK_END SEEK_CUR）</li><li>rewind （文件指针） 将文件光标置首</li><li>error宏 全局变量  perror打印宏的提示错误信息</li></ul></li><li><p>文件读写注意事项</p><ul><li>当按照字符的方式读文件时候，通常利用判断EOF获取是否读到文件尾</li><li>当对自定义数据类型写入文件时，不要将指针写入到文件里，要将指针指向的内容写入</li></ul></li><li><p>配置文件读写</p><ul><li>需求：将文件中的有效内容截取出来，并且放入到一个键值对的数组中<ul><li>struct ConfigInfo { char key[64] ; char value[64] };</li></ul></li><li>获取有效行数</li><li>判断当前行是否有效</li><li>解析数据 parseFile<ul><li>将有效数据放入到数组中，数组在堆区开辟</li></ul></li><li>根据key获取value  getInfoByKey</li><li>释放内存 freeSpace</li></ul></li></ul><h2 id="文件打开关闭"><a href="#文件打开关闭" class="headerlink" title="文件打开关闭"></a>文件打开关闭</h2><h3 id="文件打开-fopen"><a href="#文件打开-fopen" class="headerlink" title="文件打开(fopen)"></a>文件打开(fopen)</h3><p>文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FILE * fopen(const char * filename, const char * mode);</span><br><span class="line">功能：打开文件</span><br><span class="line">参数：</span><br><span class="line">  filename：需要打开的文件名，根据需要加上路径</span><br><span class="line">  mode：打开文件的权限设置</span><br><span class="line">返回值：</span><br><span class="line">  成功：文件指针</span><br><span class="line">  失败：NULL</span><br></pre></td></tr></table></figure><table><thead><tr><th>方式</th><th>含义</th></tr></thead><tbody><tr><td>“r”</td><td>打开，只读，文件必须已经存在</td></tr><tr><td>“w”</td><td>只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头</td></tr><tr><td>“a”</td><td>只能在文件末尾追加数据,如果文件不存在则创建</td></tr><tr><td>“rb”</td><td>打开一个二进制文件，只读</td></tr><tr><td>“wb”</td><td>打开一个二进制文件，只写</td></tr><tr><td>“ab”</td><td>打开一个二进制文件，追加</td></tr><tr><td>“r+”</td><td>允许读和写,文件必须已存在</td></tr><tr><td>“w+”</td><td>允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写</td></tr><tr><td>“a+”</td><td>允许读和追加数据,如果文件不存在则创建</td></tr><tr><td>“rb+”</td><td>以读/写方式打开一个二进制文件</td></tr><tr><td>“wb+”</td><td>以读/写方式建立一个新的二进制文件</td></tr><tr><td>“ab+”</td><td>以读/写方式打开一个二进制文件进行追加</td></tr></tbody></table><p>应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败</p><h3 id="文件关闭-fclose"><a href="#文件关闭-fclose" class="headerlink" title="文件关闭(fclose)"></a>文件关闭(fclose)</h3><p>文件操作完成后，如果程序没有结束，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fclose(FILE * stream);</span><br><span class="line">功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。</span><br><span class="line">参数：</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：-1</span><br></pre></td></tr></table></figure><p>它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值</p><h3 id="文件读写函数回顾"><a href="#文件读写函数回顾" class="headerlink" title="文件读写函数回顾"></a>文件读写函数回顾</h3><ol><li>按照字符读写文件：fgetc(), fputc()</li><li>按照行读写文件：fputs(), fgets()</li><li>按照块读写文件：fread(), fwirte()</li><li>按照格式化读写文件：fprintf(), fscanf()</li><li>按照随机位置读写文件：fseek(), ftell(), rewind()   </li></ol><h4 id="字符读写函数回顾"><a href="#字符读写函数回顾" class="headerlink" title="字符读写函数回顾"></a>字符读写函数回顾</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int fputc(int ch, FILE * stream);</span><br><span class="line">功能：将ch转换为unsigned char后写入stream指定的文件中</span><br><span class="line">参数：</span><br><span class="line">ch：需要写入文件的字符</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：成功写入文件的字符</span><br><span class="line">失败：返回-1</span><br><span class="line"></span><br><span class="line">int fgetc(FILE * stream);</span><br><span class="line">功能：从stream指定的文件中读取一个字符</span><br><span class="line">参数：</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：返回读取到的字符</span><br><span class="line">失败：-1</span><br><span class="line"></span><br><span class="line">int feof(FILE * stream);</span><br><span class="line">功能：检测是否读取到了文件结尾</span><br><span class="line">参数：</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">非0值：已经到文件结尾</span><br><span class="line">0：没有到文件结尾</span><br></pre></td></tr></table></figure><p>将把流指针fp指向的文件中的一个字符读出，并赋给ch，当执行fgetc()函数时，若当时文件指针指到文件尾，即遇到文件结束标志EOF(其对应值为-1)，该函数返回一个 -1 给ch，在程序中常用检查该函数返回值是否为 -1 来判断是否已读到文件尾，从而决定是否继续</p><h4 id="行读写函数回顾"><a href="#行读写函数回顾" class="headerlink" title="行读写函数回顾"></a>行读写函数回顾</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int fputs(const char * str, FILE * stream);</span><br><span class="line">功能：将str所指定的字符串写入到stream指定的文件中， 字符串结束符 &#39;\0&#39;  不写入文件。 </span><br><span class="line">参数：</span><br><span class="line">str：字符串</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：-1</span><br><span class="line"></span><br><span class="line">char * fgets(char * str, int size, FILE * stream);</span><br><span class="line">功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 &#39;\0&#39; 作为字符串结束。</span><br><span class="line">参数：</span><br><span class="line">str：字符串</span><br><span class="line">size：指定最大读取字符串的长度（size - 1）</span><br><span class="line">stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：成功读取的字符串</span><br><span class="line">读到文件尾或出错： NULL</span><br></pre></td></tr></table></figure><h4 id="块读写函数回顾"><a href="#块读写函数回顾" class="headerlink" title="块读写函数回顾"></a>块读写函数回顾</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式给文件写入内容</span><br><span class="line">参数：</span><br><span class="line">ptr：准备写入文件数据的地址</span><br><span class="line">size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小</span><br><span class="line">nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功写入文件数据的块数，此值和nmemb相等</span><br><span class="line">失败：0</span><br><span class="line"></span><br><span class="line">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式从文件中读取内容</span><br><span class="line">参数：</span><br><span class="line">ptr：存放读取出来数据的内存空间</span><br><span class="line">size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小</span><br><span class="line">nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。</span><br><span class="line">失败：0</span><br></pre></td></tr></table></figure><h4 id="格式化读写函数回顾"><a href="#格式化读写函数回顾" class="headerlink" title="格式化读写函数回顾"></a>格式化读写函数回顾</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int fprintf(FILE * stream, const char * format, ...);</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 &#39;\0&#39;  为止。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件</span><br><span class="line">format：字符串格式，用法和printf()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际写入文件的字符个数</span><br><span class="line">失败：-1</span><br><span class="line"></span><br><span class="line">int fscanf(FILE * stream, const char * format, ...);</span><br><span class="line">功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件</span><br><span class="line">format：字符串格式，用法和scanf()一样</span><br><span class="line">返回值：</span><br><span class="line">成功：实际从文件中读取的字符个数</span><br><span class="line">失败： - 1</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>fscanf遇到空格和换行时结束</strong></p><h4 id="随机读写函数回顾"><a href="#随机读写函数回顾" class="headerlink" title="随机读写函数回顾"></a>随机读写函数回顾</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int fseek(FILE *stream, long offset, int whence);</span><br><span class="line">功能：移动文件流（文件光标）的读写位置。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了 文件末尾，再次写入时将增大文件尺寸。</span><br><span class="line">whence：其取值如下：</span><br><span class="line">SEEK_SET：从文件开头移动offset个字节</span><br><span class="line">SEEK_CUR：从当前位置移动offset个字节</span><br><span class="line">SEEK_END：从文件末尾移动offset个字节</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：-1</span><br><span class="line"></span><br><span class="line">long ftell(FILE *stream);</span><br><span class="line">功能：获取文件流（文件光标）的读写位置。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：当前文件流（文件光标）的读写位置</span><br><span class="line">失败：-1</span><br><span class="line"></span><br><span class="line">void rewind(FILE *stream);</span><br><span class="line">功能：把文件流（文件光标）的读写位置移动到文件开头。</span><br><span class="line">参数：</span><br><span class="line">stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">无返回值</span><br></pre></td></tr></table></figure><h3 id="文件读写案例"><a href="#文件读写案例" class="headerlink" title="文件读写案例"></a>文件读写案例</h3><h4 id="读写配置文件"><a href="#读写配置文件" class="headerlink" title="读写配置文件"></a>读写配置文件</h4><p>配置文件格式如下：</p><p>正式的数据以 ‘:’冒号进行分割，冒号前为key起到索引作用，冒号后为value是实值。#开头的为注释，而不是正式数据</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表基本概念"><a href="#链表基本概念" class="headerlink" title="链表基本概念"></a>链表基本概念</h2><h3 id="链表引出"><a href="#链表引出" class="headerlink" title="链表引出"></a>链表引出</h3><p>数组有缺陷，是静态空间，一旦分配内存就不可以动态扩展，要不分配不够，要不分配过多，对于数组头部进行插入和删除效率低</p><h3 id="链表的组成"><a href="#链表的组成" class="headerlink" title="链表的组成"></a>链表的组成</h3><p>链表是由节点组成的</p><p>节点由 数据域 和 指针域组成</p><p>struct LinkNode { int num ; struct LinkNode * next; }</p><ul><li>链表是一种常用的数据结构，它通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的动态性（非顺序存储）</li><li>数据域用来存储数据，指针域用于建立与下一个结点的联系</li><li>建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据</li><li>链表的开销，主要是访问顺序性和组织链的空间损失</li></ul><p><strong>数组和链表的区别：</strong></p><ul><li>数组：一次性分配一块连续的存储区域</li></ul><p>优点：随机访问元素效率高  </p><p>缺点：需要分配一块连续的存储区域（很大区域，有可能分配失败），删除和插入某个元素效率低 </p><ul><li>链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系</li></ul><p>优点：不需要一块连续的存储区域 ，删除和插入某个元素效率高  </p><p>缺点：随机访问元素效率低  </p><h3 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h3><p>方式1 静态链表 动态链表</p><p>方式2 单向链表 双向链表 单向循环链表 双向循环链表</p><h3 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h3><p>如何表示一个包含了数据域和指针域的节点呢？</p><p>链表的节点类型实际上是结构体变量，此结构体包含数据域和指针域：</p><ul><li>数据域用来存储数据</li><li>指针域用于建立与下一个结点的联系，当此节点为尾节点时，指针域的值为NULL</li></ul><h3 id="链表的分类-1"><a href="#链表的分类-1" class="headerlink" title="链表的分类"></a>链表的分类</h3><p>链表分为：静态链表和动态链表</p><p>静态链表和动态链表是线性表链式存储结构的两种不同的表示方式：</p><ul><li>所有结点都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表称为“静态链表”</li><li>所谓动态链表，是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系</li></ul><h4 id="带头和不带头链表"><a href="#带头和不带头链表" class="headerlink" title="带头和不带头链表"></a>带头和不带头链表</h4><p>带头链表：固定一个节点作为头结点(数据域不保存有效数据)，起一个标志位的作用，以后不管链表节点如果改变，此头结点固定不变</p><p>不带头链表：头结点不固定，根据实际需要变换头结点(如在原来头结点前插入新节点，然后，新节点重新作为链表的头结点)</p><h4 id="单向链表、双向链表、循环链表"><a href="#单向链表、双向链表、循环链表" class="headerlink" title="单向链表、双向链表、循环链表"></a>单向链表、双向链表、循环链表</h4><h4 id="链表的基本使用"><a href="#链表的基本使用" class="headerlink" title="链表的基本使用"></a>链表的基本使用</h4><h5 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h5><p>使用结构体定义节点类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _LINKNODE</span><br><span class="line">&#123;</span><br><span class="line">int id; &#x2F;&#x2F;数据域</span><br><span class="line">struct _LINKNODE* next; &#x2F;&#x2F;指针域</span><br><span class="line">&#125;link_node;</span><br></pre></td></tr></table></figure><p>编写函数：link_node* init_linklist()</p><p>建立带有头结点的单向链表，循环创建结点，结点数据域中的数值从键盘输入，以 -1 作为输入结束标志，链表的头结点地址由函数值返回</p><h5 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h5><p>编写函数：void foreach_linklist(link_node* head)</p><p>顺序输出单向链表各项结点数据域中的内容</p><h5 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h5><p>编写函数: void insert_linklist(link_node* head,int val,int data).</p><p>在指定值后面插入数据data,如果值val不存在，则在尾部插入</p><h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><p>编写函数: void remove_linklist(link_node* head,int val)</p><p>删除第一个值为val的结点</p><h5 id="销毁链表"><a href="#销毁链表" class="headerlink" title="销毁链表"></a>销毁链表</h5><p>编写函数: void destroy_linklist(link_node* head)</p><p>销毁链表，释放所有节点的空间</p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ul><li>带头节点链表 好处在于 头节点永远都是固定的</li><li>初始化链表  struct LinkNode * pHeader = init_LinkList ()</li><li>遍历链表  void  foreach_LinkList( struct LinkNode * pHeader ) </li><li>插入链表  void insertLinkList( struct LinkNode*pHeader , int oldval ,int newval )<ul><li>在oldval前插入 newVal，如果没有oldval就进行尾插</li></ul></li><li>删除链表 void delete_LinkList( struct LinkNode*pHeader, int val )<ul><li>用户提供的有效数据 删除掉</li><li>无效数据 直接return </li></ul></li><li>清空链表 <ul><li>void clear_LinkList(struct LinkNode*pHeader ) </li><li>将所有有数据的节点释放掉</li></ul></li><li>销毁链表<ul><li>void destroy_LinkList(struct LinkNode*pHeader)</li><li>将整个链表都释放掉</li></ul></li></ul><h1 id="函数指针和回调函数"><a href="#函数指针和回调函数" class="headerlink" title="函数指针和回调函数"></a>函数指针和回调函数</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p><em>通过什么来区分两个不同的函数？</em></p><p>一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，函数名代表函数的入口地址</p><p>函数三要素： 名称、参数、返回值。C语言中的函数有自己特定的类型</p><p>c语言中通过typedef为函数类型重命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef int f(int, int);   &#x2F;&#x2F; f 为函数类型  </span><br><span class="line">typedef void  p(int);&#x2F;&#x2F; p 为函数类型 </span><br></pre></td></tr></table></figure><p> 和数组一样，因此我们可以用一个指针变量来存放这个入口地址，然后通过该指针变量调用函数。</p><p><strong>注意：</strong>通过函数类型定义的变量是不能够直接执行，因为没有函数体。只能通过类型定义一个函数指针指向某一个具体函数，才能调用</p><h3 id="函数指针的定义-指向函数的指针"><a href="#函数指针的定义-指向函数的指针" class="headerlink" title="函数指针的定义(指向函数的指针)"></a>函数指针的定义(指向函数的指针)</h3><ul><li>先定义出函数类型，再通过类型定义出函数指针<ul><li>typedef void(FUNC_TYPE)()</li><li>FUNC_TYPE * pFunc = func</li></ul></li><li>先定义出函数指针类型，再根据类型定义函数指针<ul><li>typedef void(*FUNC_TYPE)()</li><li>FUNC_TYPE pFunc = func</li></ul></li><li>直接定义函数指针变量<ul><li>void(* pFunc )() = func</li></ul></li></ul><h3 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h3><p>函数指针数组，每个元素都是函数指针</p><ul><li>函数指针和指针函数的区别<ul><li>函数指针 是指向函数的 指针 </li><li>指针函数 函数的返回值是一个指针的 函数</li></ul></li><li>函数指针的数组定义<ul><li>void(*pFunc[3])()</li></ul></li></ul><h3 id="函数指针做函数参数（-回调函数-）"><a href="#函数指针做函数参数（-回调函数-）" class="headerlink" title="函数指针做函数参数（ 回调函数 ）"></a>函数指针做函数参数（ 回调函数 ）</h3><p>函数参数除了是普通变量，还可以是函数指针变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;形参为普通变量</span><br><span class="line">void fun( int x )&#123;&#125;</span><br><span class="line">&#x2F;&#x2F;形参为函数指针变量</span><br><span class="line">void fun( int(*p)(int a) )&#123;&#125;</span><br></pre></td></tr></table></figure><p>函数指针变量常见的用途之一是把指针作为参数传递到其他函数，指向函数的指针也可以作为参数，以实现函数地址的传递</p><p>提供一个通用的函数，可以打印任意的数据类型</p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><h2 id="预处理的基本概念"><a href="#预处理的基本概念" class="headerlink" title="预处理的基本概念"></a>预处理的基本概念</h2><p>C语言对源程序处理的四个步骤：预处理、编译、汇编、链接。</p><p>预处理是在程序源代码被编译之前，由预处理器（Preprocessor）对程序源代码进行的处理。这个过程并不对程序的源代码语法进行解析，但它会把源代码分割或处理成为特定的符号为下一步的编译做准备工作</p><h2 id="文件包含指令-include"><a href="#文件包含指令-include" class="headerlink" title="文件包含指令(#include)"></a>文件包含指令(#include)</h2><h3 id="文件包含处理"><a href="#文件包含处理" class="headerlink" title="文件包含处理"></a>文件包含处理</h3><p>“文件包含处理”是指一个源文件可以将另外一个文件的全部内容包含进来。Ｃ语言提供了#include命令用来实现“文件包含”的操作</p><h3 id="incude-lt-gt-和-include””区别"><a href="#incude-lt-gt-和-include””区别" class="headerlink" title="#incude&lt;&gt;和#include””区别"></a>#incude&lt;&gt;和#include””区别</h3><ul><li>“” 表示系统先在file1.c所在的当前目录找file1.h，如果找不到，再按系统指定的目录检索</li><li>&lt; &gt; 表示系统直接按系统指定的目录检索</li></ul><p>注意：</p><ol><li>#include &lt;&gt;常用于包含库函数的头文件</li><li>#include “”常用于包含自定义的头文件</li><li>理论上#include可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含</li></ol><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="无参数的宏定义-宏常量"><a href="#无参数的宏定义-宏常量" class="headerlink" title="无参数的宏定义(宏常量)"></a>无参数的宏定义(宏常量)</h3><p>如果在程序中大量使用到了100这个值，那么为了方便管理，我们可以将其定义为：</p><p>const int num = 100</p><p>但是如果我们使用num定义一个数组，在不支持c99标准的编译器上是不支持的，因为num不是一个编译器常量，如果想得到了一个编译器常量，那么可以使用：</p><p>#define num 100</p><p>在编译预处理时，将程序中在该语句以后出现的所有的num都用100代替。这种方法使用户能以一个简单的名字代替一个长的字符串，在预编译时将宏名替换成字符串的过程称为“宏展开”。宏定义，只在宏定义的文件中起作用</p><p>说明：</p><ol><li>宏名一般用大写，以便于与变量区别</li><li>宏定义可以是常数、表达式等</li><li>宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错</li><li>宏定义不是C语言，不在行末加分号</li><li>宏名有效范围为从定义到本源文件结束</li><li>可以用#undef命令终止宏定义的作用域</li><li>在宏定义中，可以引用已定义的宏名</li></ol><p>不重视作用域、可以利用 #undef 卸载宏、宏常量 没有数据类型、宏函数 要注意表达式完整性</p><h3 id="带参数的宏定义-宏函数"><a href="#带参数的宏定义-宏函数" class="headerlink" title="带参数的宏定义(宏函数)"></a>带参数的宏定义(宏函数)</h3><p>在项目中，经常把一些短小而又频繁使用的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。</p><p>宏通过使用参数，可以创建外形和作用都与函数类似地类函数宏(function-like macro). 宏的参数也用圆括号括起来</p><p><strong>注意:</strong></p><ol><li>宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格</li><li>用括号括住每一个参数，并括住宏的整体定义</li><li>用大写字母表示宏的函数名</li><li>如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高</li></ol><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>一般情况下，源程序中所有的行都参加编译。但有时希望对部分源程序行只在满足一定条件时才编译，即对这部分源程序行指定编译条件</p><ul><li>测试存在：</li></ul><p>#ifdef    标识符</p><p>​        程序段 1</p><p>#else</p><p>​        程序段 2 </p><p>#endif</p><ul><li>测试不存在：</li></ul><p>#ifndef    标识符</p><p>​        程序段 1</p><p>#else</p><p>​        程序段 2</p><p>#endif</p><ul><li>自定义条件测试：</li></ul><p>#if</p><p>…同上</p><p><em>防止头文件被重复包含引用</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _SOMEFILE_H</span><br><span class="line">#define _SOMEFILE_H</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要声明的变量、函数</span><br><span class="line">&#x2F;&#x2F;宏定义</span><br><span class="line">&#x2F;&#x2F;结构体</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="一些特殊的预定宏"><a href="#一些特殊的预定宏" class="headerlink" title="一些特殊的预定宏"></a>一些特殊的预定宏</h2><p>C编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;__FILE__宏所在文件的源文件名 </span><br><span class="line">&#x2F;&#x2F;__LINE__宏所在行的行号</span><br><span class="line">&#x2F;&#x2F;__DATE__代码编译的日期</span><br><span class="line">&#x2F;&#x2F;__TIME__代码编译的时间</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s\n&quot;, __FILE__);</span><br><span class="line">printf(&quot;%d\n&quot;, __LINE__);</span><br><span class="line">printf(&quot;%s\n&quot;, __DATE__);</span><br><span class="line">printf(&quot;%s\n&quot;, __TIME__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态库的封装和使用"><a href="#动态库的封装和使用" class="headerlink" title="动态库的封装和使用"></a>动态库的封装和使用</h1><h2 id="库的基本概念"><a href="#库的基本概念" class="headerlink" title="库的基本概念"></a>库的基本概念</h2><p>库是已经写好的、成熟的、可复用的代码。每个程序都需要依赖很多底层库，不可能每个人的代码从零开始编写代码，因此库的存在具有非常重要的意义</p><p>在我们的开发的应用中经常有一些公共代码是需要反复使用的，就把这些代码编译为库文件</p><p>库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。像在Windows这样的平台上，最常用的c语言库是由集成按开发环境所附带的运行库，这些库一般由编译厂商提供</p><h2 id="windows下静态库创建和使用"><a href="#windows下静态库创建和使用" class="headerlink" title="windows下静态库创建和使用"></a>windows下静态库创建和使用</h2><h3 id="静态库的创建"><a href="#静态库的创建" class="headerlink" title="静态库的创建"></a>静态库的创建</h3><p>创建一个新项目，在已安装的模板中选择“常规”，在右边的类型下选择“空项目”，在名称和解决方案名称中输入staticlib。点击确定</p><p>在解决方案资源管理器的头文件中添加,mylib.h文件，在源文件添加mylib.c文件（即实现文件）</p><p>在mylib.h文件中添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef TEST_H</span><br><span class="line">#define TEST_H</span><br><span class="line"></span><br><span class="line">int myadd(int a,int b);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在mylib.c文件中添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;test.h&quot;</span><br><span class="line">int myadd(int a, int b)&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置项目属性。因为这是一个静态链接库，所以应在项目属性的“配置属性”下选择“常规”，在其下的配置类型中选择“静态库（.lib）。</p><p>编译生成新的解决方案，在Debug文件夹下会得到mylib.lib (对象文件库），将该.lib文件和相应头文件给用户，用户就可以使用该库里的函数了</p><p>即：</p><p>创建项目 — 配置属性 — 常规 —– 配置类型 — 静态库</p><p>重新生成项目 ，创建出后缀名为 .lib的静态库文件</p><p>测试静态库</p><h3 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h3><p>方法一：配置项目属性</p><ol><li>添加工程的头文件目录：工程—属性—配置属性—c/c++—常规—附加包含目录：加上头文件存放目录</li><li>添加文件引用的lib静态库路径：工程—属性—配置属性—链接器—常规—附加库目录：加上lib文件存放目录</li><li>然后添加工程引用的lib文件名：工程—属性—配置属性—链接器—输入—附加依赖项：加上lib文件名  </li></ol><p>方法二：使用编译语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma comment(lib,&quot;.&#x2F;mylib.lib&quot;)</span><br></pre></td></tr></table></figure><p>方法三：添加工程中</p><p>像添加.h和.c文件一样,把lib文件添加到工程文件列表中去.  切换到”解决方案视图”,—&gt;选中要添加lib的工程–&gt;点击右键–&gt;”添加”–&gt;”现有项”–&gt;选择lib文件–&gt;确定.  </p><h4 id="静态库优缺点"><a href="#静态库优缺点" class="headerlink" title="静态库优缺点"></a>静态库优缺点</h4><ul><li>静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系</li><li>程序在运行时与函数库再无瓜葛，移植方便</li><li>浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件</li></ul><h4 id="内存和磁盘空间"><a href="#内存和磁盘空间" class="headerlink" title="内存和磁盘空间"></a>内存和磁盘空间</h4><p>静态链接这种方法很简单，原理上也很容易理解，在操作系统和硬件不发达的早期，绝大部门系统采用这种方案。随着计算机软件的发展，这种方法的缺点很快暴露出来，那就是静态链接的方式对于计算机内存和磁盘空间浪费非常严重。特别是多进程操作系统下，静态链接极大的浪费了内存空间。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间</p><h4 id="程序开发和发布"><a href="#程序开发和发布" class="headerlink" title="程序开发和发布"></a>程序开发和发布</h4><p>空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也会带来很多麻烦。比如程序中所使用的mylib.lib是由一个第三方厂商提供的，当该厂商更新容量mylib.lib的时候，那么我们的程序就要拿到最新版的mylib.lib，然后将其重新编译链接后，将新的程序整个发布给用户。这样的做缺点很明显，即一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序</p><h2 id="windows下动态库创建和使用"><a href="#windows下动态库创建和使用" class="headerlink" title="windows下动态库创建和使用"></a>windows下动态库创建和使用</h2><p>要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想</p><h3 id="动态库的创建"><a href="#动态库的创建" class="headerlink" title="动态库的创建"></a>动态库的创建</h3><p>创建一个新项目，在已安装的模板中选择“常规”，在右边的类型下选择“空项目”，在名称和解决方案名称中输入mydll。点击确定。</p><p>在解决方案资源管理器的头文件中添加,mydll.h文件，在源文件添加mydll.c文件（即实现文件）。</p><p>在test.h文件中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef TEST_H</span><br><span class="line">#define TEST_H</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) int myminus(int a, int b);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在test.c文件中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;test.h&quot;</span><br><span class="line">__declspec(dllexport) int myminus(int a, int b)&#123;</span><br><span class="line">return a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置项目属性。因为这是一个动态链接库，所以应在项目属性的“配置属性”下选择“常规”，在其下的配置类型中选择“动态库（.dll）。</p><p>编译生成新的解决方案，在Debug文件夹下会得到mydll.dll (对象文件库），将该.dll文件、.lib文件和相应头文件给用户，用户就可以使用该库里的函数了</p><p>即：</p><p>运行阶段才去链接函数</p><p>配置流程： 创建项目 — 配置属性 – 常规 — 配置类型 — 动态库</p><p>重新生成解决方案，生成 .dll  .lib 库文件</p><p>导入函数  只能在当前项目下使用</p><p>导出函数  可以在外部使用 </p><p>__declspec (dllexport) int mySub(int a, int b);</p><p>测试 引入#pragma comment(lib,”./mydll.lib”)</p><p><em>疑问一：__declspec(dllexport)是什么意思？</em></p><p>动态链接库中定义有两种函数：导出函数(export function)和内部函数(internal function)。 导出函数可以被其它模块调用，内部函数在定义它们的DLL程序内部使用</p><p><em>疑问二：动态库的lib文件和静态库的lib文件的区别？</em></p><p>在使用动态库的时候，往往提供两个文件：一个引入库（.lib）文件（也称“导入库文件”）和一个DLL（.dll）文件。虽然引入库的后缀名也是“lib”，但是，动态库的引入库文件和静态库文件有着本质的区别，对一个DLL文件来说，其引入库文件（.lib）包含该DLL导出的函数和变量的符号名，而.dll文件包含该DLL实际的函数和数据。在使用动态库的情况下，在编译链接可执行文件时，只需要链接该DLL的引入库文件，该DLL中的函数代码和数据并不复制到可执行文件，直到可执行程序运行时，才去加载所需的DLL，将该DLL映射到进程的地址空间中，然后访问DLL中导出的函数。  </p><h3 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h3><p>方法一：隐式调用</p><p>创建主程序TestDll，将mydll.h、mydll.dll和mydll.lib复制到源代码目录下。  (P.S：头文件Func.h并不是必需的，只是C++中使用外部函数时，需要先进行声明)  在程序中指定链接引用链接库 : #pragma comment(lib,”./mydll.lib”)  </p><p> 方法二：显式调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hDll; &#x2F;&#x2F;声明一个dll实例文件句柄</span><br><span class="line">hDll &#x3D; LoadLibrary(&quot;mydll.dll&quot;); &#x2F;&#x2F;导入动态链接库</span><br><span class="line">MYFUNC minus_test; &#x2F;&#x2F;创建函数指针</span><br><span class="line">&#x2F;&#x2F;获取导入函数的函数指针</span><br><span class="line">minus_test &#x3D; (MYFUNC)GetProcAddress(hDll, &quot;myminus&quot;);</span><br></pre></td></tr></table></figure><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><h3 id="递归函数基本概念"><a href="#递归函数基本概念" class="headerlink" title="递归函数基本概念"></a>递归函数基本概念</h3><p>C通过运行时堆栈来支持递归函数的实现。递归函数就是直接或间接调用自身的函数</p><p>函数自身调用自身，必须有结束条件退出循环</p><h2 id="案例应用"><a href="#案例应用" class="headerlink" title="案例应用"></a>案例应用</h2><p>递归函数的调用</p><p>递归实现字符串反转</p><p>实现字符串逆序遍历</p><p>实现斐波那契数列</p><h1 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h1><p>……</p><hr><p>参考资料：黑马程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h1&gt;&lt;h2 id=&quot;结构体基础知识&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://www.chenzhan.club/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>note25.2-LCD背光调节</title>
    <link href="https://www.chenzhan.club/2021/03/05/note25-2-LCD%E8%83%8C%E5%85%89%E8%B0%83%E8%8A%82/"/>
    <id>https://www.chenzhan.club/2021/03/05/note25-2-LCD%E8%83%8C%E5%85%89%E8%B0%83%E8%8A%82/</id>
    <published>2021-03-05T14:40:09.000Z</published>
    <updated>2021-04-12T13:32:17.306Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="LCD-背光调节简介"><a href="#LCD-背光调节简介" class="headerlink" title="LCD 背光调节简介"></a>LCD 背光调节简介</h1><p>给背光控制引脚输入高电平就会点亮背光，输入低电平就会关闭背光。不断的打开和关闭背光，当速度足够快的时候 就不会感觉到背光关闭这个过程了。这个正好可以使用 PWM 来完成，PWM 全称是 PulseWidth Modulation，也就是脉冲宽度调制</p><p>PWM 信号有两个关键的术语：频率和占空比，频率就是开关速度，把一次开关算作一个周期，那么频率就是 1 秒内进行了多少次开关。占空比就是一个周期内高电平时间和低电平时间的比例，一个周期内高电平时间越长占空比就越大，反之占空比就越小。占空比用百分之表示， 如果一个周期内全是低电平那么占空比就是 0%，如果一个周期内全是高电平那么占空比就是 100%。 我们给 LCD 的背光引脚输入一个 PWM 信号，这样就可以通过调整占空比的方式来调整 LCD 背光亮度了。提高占空比就会提高背光亮度，降低占空比就会降低背光亮度。重点就在于 PWM 信号的产生和占空比的控制，I.MX6U 提供了 PWM 外设，可以配置 PWM 外设来产生 PWM 信号。 打开《I.MX6ULL 参考手册》的第 40 章“Chapter 40 Pulse Width Modulation(PWM)”，I.MX6U 一共有 8 路 PWM 信号，每个 PWM 包含一个 16 位的计数器和一个 4 x 16 的数据 FIFO，I.MX6U 的 PWM 外设结构如图 29.1.2 所示：</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note23-SPI实验\image-20210305225558314.png" alt="image-20210305225558314"></p><p>图中的各部分功能如下： ①、</p><ol><li>此部分是一个选择器，用于选择 PWM 信号的时钟源，一共有三种时钟源：ipg_clk、 ipg_clk_highfreq 和 ipg_clk_32k</li><li>是一个 12 位的分频器，可以对①中选择的时钟源进行分频</li><li>是 PWM 的 16 位计数器寄存器，保存着 PWM 的计数值</li><li>是 PWM 的 16 位周期寄存器，此寄存器用来控制 PWM 的频率</li><li>是 PWM 的 16 位采样寄存器，此寄存器用来控制 PWM 的占空比</li><li>此部分是 PWM 的中断信号，PWM 是提供中断功能的，如果使能了相应的中断的话就会产生中断</li><li>此部分是 PWM 对应的输出 IO，产生的 PWM 信号就会从对应的 IO 中输出，I.MX6UALPHA 开发板的 LCD 背光控制引脚连接在 I.MX6U 的 GPIO1_IO8 上，GPIO1_IO8 可以复用为 PWM1_OUT</li></ol><p>可以通过配置相应的寄存器来设置 PWM 信号的频率和占空比，PWM 的 16 位计数器是个向上计数器，此计数器会从 0X0000 开始计数，直到计数值等于寄存器 PWMx_PWMPR(x=1~8) + 1，然后计数器就会重新从 0X0000 开始计数，如此往复。所以寄存器 PWMx_PWMPR 可以设置 PWM 的频率</p><p>在一个周期内，PWM 从 0X0000 开始计数的时候，PWM 引脚先输出高电平(默认情况下， 可以通过配置输出低电平)。采样 FIFO 中保存的采样值会在每个时钟和计数器值进行比较，当采样值和计数器相等的话 PWM 引脚就会改为输出低电平(默认情况下，同样可以通过配置输出高电平)。计数器会持续计数，直到和周期寄存器 PWMx_PWMPR(x=1~8) + 1 的值相等，这样一个周期就完成了。所以，采样 FIFO 控制着占空比，而采样 FIFO 里面的值来源于采样寄存器 PWMx_PWMSAR，因此相当于 PWMx_PWMSAR 控制着占空比。至此，PWM 信号的频率和占空比设置我们就知道该如何去做了</p><p>PWM 开启以后会按照默认值运行，并产生 PWM 波形，而这个默认的 PWM 一般并不是我们需要的波形。如果这个 PWM 波形控制着设备的话就会导致设备因为接收到错误的 PWM 信号而运行错误，严重情况下可能会损坏设备，甚至人身安全。因此，在开启 PWM 之前最好设置好 PWMx_PWMPR 和 PWMx_PWMSAR 这两个寄存器，也就是设置好 PWM 的频率和占空 比</p><p>当向 PWMx_PWMSAR 寄存器写入采样值的时候，如果 FIFO 没满的话其值会被存储到 FIFO 中。如果 FIFO 满的时候写入采样值就会导致寄存器 PWMx_PWMSR 的位 FWE(bit6)置 1，表示 FIFO 写错误，FIFO 里面的值也并不会改变。FIFO 可以在任何时候写入，但是只有在 PWM 使能的情况下读取。寄存器 PWMx_SR 的位 FIFOAV(bit2:0)记录着当前 FIFO 中有多少个数据。从采样寄存器 PWMx_PWMSAR 读取一次数据，FIFO 里面的数据就会减一，每产生一个周期的 PWM 信号，FIFO 里面的数据就会减一，相当于被用掉了。PWM 有个 FIFO 空中断，当 FIFO 为空的时候就会触发此中断，可以在此中断处理函数中向 FIFO 写入数据</p><h2 id="PWM-几个寄存器"><a href="#PWM-几个寄存器" class="headerlink" title="PWM 几个寄存器"></a>PWM 几个寄存器</h2><ul><li>PWM1_PWMCR</li><li>PWM1_PWMIR 寄存器，这个是 PWM 的中断控制寄存器</li><li>状态寄存器 PWM1_PWMSR</li><li>PWM1_PWMPR 寄存器，PWM 周期寄存器</li></ul><p>PWM 的频率计算公式如下： </p><p>PWMO(Hz) = PCLK(Hz) / (PERIOD + 2) </p><p>其中 PCLK 是最终进入 PWM 的时钟频率，假如 PCLK 的频率为 1MHz，现在我们要产生 一个频率为 1KHz 的 PWM 信号，那么就可以设置 PERIOD = 1000000 / 1000 – 2 = 998</p><ul><li> PWM1_PWMSAR，这是采样寄存器，用于设置占空比</li></ul><p>通过这个采样值即可调整占空比，当计数器的值小于 SAMPLE 的时候输出高电平(或低电平)。当计数器值大于等于 SAMPLE，小于寄存器 PWM1_PWMPR 的 PERIO 的时候输出低电平(或高电平)。同样假如我们要设置 PWM 信号的占空比为 50%，那么就可以将 SAMPLE 设置为(PERIOD + 2) / 2 = 1000 / 2=500</p><h2 id="PWM1-的输出引脚为-GPIO1-IO8，配置步骤如下："><a href="#PWM1-的输出引脚为-GPIO1-IO8，配置步骤如下：" class="headerlink" title="PWM1 的输出引脚为 GPIO1_IO8，配置步骤如下："></a>PWM1 的输出引脚为 GPIO1_IO8，配置步骤如下：</h2><ol><li>配置引脚 GPIO1_IO8 配置 GPIO1_IO08 的复用功能，将其复用为 PWM1_OUT 信号线</li><li>初始化 PWM1 初始化 PWM1，配置所需的 PWM 信号的频率和默认占空比</li><li>设置中断 因为 FIFO 中的采样值每个周期都会少一个，所以需要不断的向 FIFO 中写入采样值，防止其为空。我们可以使能 FIFO 空中断，这样当 FIFO 为空的时候就会触发相应的中断，然后在中断处理函数中向 FIFO 写入采样值</li><li>使能 PWM1 配置好 PWM1 以后就可以开启了。</li></ol><h1 id="实验程序"><a href="#实验程序" class="headerlink" title="实验程序"></a>实验程序</h1><p>文件 bsp_blacklight.c 一共有 6 个函数，pwm1_irqhandler，是 PWM1 的中断处理函数。需要在此函数中处理 FIFO 空中断，当 FIFO 空中断发生以后需要向采样寄存器 PWM1_PWMSAR 写入采样数据，也就是占空比值，最后要清除相应的中断标志位。backlight_init，是背光初始化函数，在此函数里面会初始化背光引脚 GPIO1_IO08，将其复用为 PWM1_OUT。然后此函数初始化 PWM1，设置要产生的 PWM 信号频率和默认占空 比，接下来使能 FIFO 空中断，注册相应的中断处理函数，最后使能 PWM1。pwm1_enable，用于使能 PWM1。pwm1_setsample_value，用于设置采样值，也就是寄存器 PWM1_PWMSAR 的值。pwm1_setperiod_value，用于设置 PWM 信号的频率。pwm1_setduty，用于设置 PWM 的占空比，这个函数只有一个参数 duty， 也就是占空比值，单位为%，函数内部会根据百分值计算出寄存器 PWM1_PWMSAR 应该设置的值</p><p>调用函数 backlight_init 初始化屏幕背光 PWM。设置背光 PWM 默认占空比为 10%。在 main 函数中读取按键值，如果 KEY0 按下的话就将 PWM 信号的占空比增加 10%，当占空比超过 100%的时候就重回到 10%，重新开始</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;LCD-背光调节简介&quot;&gt;&lt;a href=&quot;#LCD-背光调节简介&quot; class=&quot;headerlink&quot; title=&quot;LCD 背光调节简介&quot;&gt;&lt;/a&gt;LCD 背光调节简介</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://www.chenzhan.club/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note24.2-多点电容触摸屏</title>
    <link href="https://www.chenzhan.club/2021/03/05/note24-2-%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F/"/>
    <id>https://www.chenzhan.club/2021/03/05/note24-2-%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F/</id>
    <published>2021-03-05T12:47:55.000Z</published>
    <updated>2021-04-12T13:32:10.418Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="多点电容触摸简介"><a href="#多点电容触摸简介" class="headerlink" title="多点电容触摸简介"></a>多点电容触摸简介</h1><p>电阻触摸屏，电阻触摸屏只能单点触摸，和电阻触摸屏相比，电容触摸屏最大的优点是支持多点触摸，电容屏只需要手指轻触即可，而电阻屏是需要手指 给予一定的压力才有反应，而且电容屏不需要校准。如今多点电容触摸屏已经得到了广泛的应用，如果要做人机交互设备的开发，多点电容触摸屏基本是不可能绕过去的。我们来学习一下如何使用多点触摸屏，如何获取到多点触摸值。 如何得到其多点触摸坐标值即可。ALIENTEK 的三款 RGB LCD 屏幕都是支持 5 点电容触摸屏的，以 ATK-7016 这款屏幕来讲解如何使用多点电容触摸屏</p><p>ATK-7016 这款屏幕其实是由 TFT LCD+触摸屏组合起来的。底下是 LCD 面板，上面是触摸面板，将两个封装到一起就成了带有触摸屏的 LCD 屏幕。电容触摸屏也是需要一个驱动 IC 的，驱动 IC 一般会提供一个 I2C 接口给主控制器，主控制器可以通过 I2C 接口来读取驱动 IC 里面的触摸坐标数据。ATK-7016、ATK-7084 这两款屏幕使用的触摸控制 IC 是 FT5426，ATK4342 使用的驱动 IC 是 GT9147。这三个电容屏触摸 IC 都是 I2C 接口的，使用方法基本一样。 FT5426 这款驱动 IC 采用 15*28 的驱动结构，也就是 15 个感应通道，28 个驱动通道，最 多支持 5 点电容触摸。ATK-7016 的电容触摸屏部分有 4 个 IO 用于连接主控制器：SCL、SDA、 RST 和 INT，SCL 和 SDA 是 I2C 引脚，RST 是复位引脚，INT 是中断引脚。一般通过 INT 引 脚来通知主控制器有触摸点按下，然后在 INT 中断服务函数中读取触摸数据。也可以不使用中断功能，采用轮询的方式不断查询是否有触摸点按下，我们使用中断方式来获取触摸数据</p><p>根所有的 I2C 器件一样，FT5426 也是通过读写寄存器来完成初始化和触摸坐标数据读取的，主要工作就是读写 FT5426 的寄存器。FT5426 的 I2C 设备地址为 0X38，FT5426 的寄存器有多</p><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a>实验程序编写</h1><p>文件 bsp_ft5xx6.c 中有 7 个函数，函数 ft5426_init， 此函数是 ft5426 的初始化函数，此函数先初始化 FT5426 所使用的 I2C2 接口引脚、复位引脚和中断引脚。接下来使能了 FT5426 所使用的中断，并且注册了中断处理函数，最后初始化了 I2C2 和 FT5426。 gpio1_io9_irqhandler，这个是 FT5426 的中断引脚中断处理函数，在 此函数中会读取 FT5426 内部的触摸数据。 ft5426_write_byte 和 ft5426_read_byte，函数 ft5426_write_byte 用于向 FT5426 的寄存器写入指定的值，函数 ft5426_read_byte 用于读取 FT5426 指定寄存器的值。 ft5426_read_len，此函数也 是从 FT5426 的指定寄存器读取数据，但是此函数是读取数个连续的寄存器。ft5426_read_tpnum，此函数用于获取 FT5426 当前有几个触摸点有效，也就是触摸点个数。 ft5426_read_tpcoord，此函数就是读取 FT5426 各个触摸点坐标值的</p><p>文件 main.c 调用函数 ft5426_init 初始化触摸屏，也就是 FT5426 这个触摸驱动 IC。最后在 main 函数的 while 循环中不断的显示获取到的触摸点数以及对应的触摸坐标值。因为采用中断方式读取 FT5426 的触摸数据，因此 main 函数中并没有读取 FT5426 的操作，只是显示触摸值</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;多点电容触摸简介&quot;&gt;&lt;a href=&quot;#多点电容触摸简介&quot; class=&quot;headerlink&quot; title=&quot;多点电容触摸简介&quot;&gt;&lt;/a&gt;多点电容触摸简介&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://www.chenzhan.club/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note23.2-SPI实验</title>
    <link href="https://www.chenzhan.club/2021/03/03/note23-2-SPI%E5%AE%9E%E9%AA%8C/"/>
    <id>https://www.chenzhan.club/2021/03/03/note23-2-SPI%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-03-03T13:08:21.000Z</published>
    <updated>2021-04-12T13:32:03.003Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="SPI-实验"><a href="#SPI-实验" class="headerlink" title="SPI 实验"></a>SPI 实验</h1><p>同 I2C 一样，SPI 是很常用的通信接口，也可以通过 SPI 来连接众多的传感器。相比 I2C 接 口，SPI 接口的通信速度很快，I2C 最多 400KHz，但是 SPI 可以到达几十 MHz。I.MX6U 也有 4 个 SPI 接口，可以通过这 4 个 SPI 接口来连接一些 I2C 外设。I.MX6U-ALPHA 使用 SPI3 接口连接了一个六轴传感器 ICM-20608，学习如何使用 I.MX6U 的 SPI 接口来驱动 ICM-20608，读取 ICM-20608 的六轴数据</p><h3 id="SPI-amp-ICM-20608-简介"><a href="#SPI-amp-ICM-20608-简介" class="headerlink" title="SPI &amp; ICM-20608 简介"></a>SPI &amp; ICM-20608 简介</h3><h3 id="SPI-简介"><a href="#SPI-简介" class="headerlink" title="SPI 简介"></a>SPI 简介</h3><p>I2C 是串行通信的一种，只需要两根线就可以完成主机和从机之间的通信，但是 I2C 的速度最高只能到 400KHz</p><p>SPI，SPI 全称是 Serial Perripheral Interface，也就是串行外围设备接口。SPI 是一种同步串行接口技术，是一种高速、全双工的同步通信总线，SPI 时钟频率相比 I2C 要高很多，最高可以工作在上百 MHz。SPI 以主从方式工作，通常是有一个主设备和一个或多个从设备，一般 SPI 需要 4 根线，但是也可以使用三根线(单向传输)</p><p>标准的 4 线 SPI，这四根线如下： </p><ol><li>CS/SS，Slave Select/Chip Select，这个是片选信号线，用于选择需要进行通信的从设备。 I2C 主机是通过发送从机设备地址来选择需要进行通信的从机设备的，SPI 主机不需要发送从机设备，直接将相应的从机设备片选信号拉低即可</li><li>SCK，Serial Clock，串行时钟，和 I2C 的 SCL 一样，为 SPI 通信提供时钟</li><li>MOSI/SDO，Master Out Slave In/Serial Data Output，简称主出从入信号线，这根数据线只能用于主机向从机发送数据，也就是主机输出，从机输入</li><li>MISO/SDI，Master In Slave Out/Serial Data Input，简称主入从出信号线，这根数据线只能用户从机向主机发送数据，也就是主机输入，从机输出</li></ol><p>SPI 通信都是由主机发起的，主机需要提供通信的时钟信号</p><p>SPI 有四种工作模式，通过串行时钟极性(CPOL)和相位(CPHA)的搭配来得到四种工作模式：</p><ol><li>CPOL=0，串行时钟空闲状态为低电平</li><li>CPOL=1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具体的传输协议</li><li>CPHA=0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据</li><li>CPHA=1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据</li></ol><p><img src="/Chenzhan666.github.io/.club//source_posts%5Cnote23-SPI%E5%AE%9E%E9%AA%8C%5Cimage-20210305193457567.png" alt="image-20210305193457567"></p><p>从SPI 的时序图可以看出，因为SPI 是全双工的，不像 I2C 那样要分为读时序和写时序，所以读写时序可以一起完成。时序图中，CS 片选信号先拉低，选中要通信的从设备，然后通过 MOSI 和 MISO 这两根数据线进行收发数据，MOSI 数据线发出了 0XD2 这个数据给从设备，同时从设备也通过 MISO 线给主设备返回了 0X66 这个数据</p><h3 id="I-MX6U-ECSPI-简介"><a href="#I-MX6U-ECSPI-简介" class="headerlink" title="I.MX6U ECSPI 简介"></a>I.MX6U ECSPI 简介</h3><p>I.MX6U 自带的 SPI 外设叫做 ECSPI，全称是 Enhanced Configurable Serial Peripheral Interface， 就是 SPI。ECSPI 有 64 * 32 个接收 FIFO(RXFIFO)和 64 * 32 个发送 FIFO(TXFIFO)，ECSPI 特性如下：</p><ol><li>全双工同步串行接口</li><li>可配置的主/从模式</li><li>四个片选信号，支持多从机</li><li>发送和接收都有一个 32x64 的 FIFO</li><li>片选信号 SS/CS，时钟信号 SCLK 极性可配置</li><li>支持 DMA</li></ol><p>I.MX6U 的 ECSPI 可以工作在主模式或从模式，I.MX6U 有 4 个 ECSPI，每个 ECSPI 支持四个片选信号，如果要使用 ECSPI 的硬件片选信号， 一个 ECSPI 可以支持 4 个外设。如果不使用硬件的片选信号就可以支持无数个外设，硬件片选信号只能使用指定的片选 IO，软件片选可以使用任意的 IO</p><h4 id="ECSPI-的重要的寄存器"><a href="#ECSPI-的重要的寄存器" class="headerlink" title="ECSPI 的重要的寄存器"></a>ECSPI 的重要的寄存器</h4><ul><li>ECSPIx_CONREG(x=1~4)寄存器，是 ECSPI 的控制寄存器</li><li>寄存器 ECSPIx_CONFIGREG，是 ECSPI 的配置寄存器</li><li>寄存器 ECSPIx_PERIODREG，是 ECSPI 的采样周期寄存器</li><li>寄存器 ECSPIx_STATREG</li><li>两个数据寄存器，ECSPIx_TXDATA 和 ECSPIx_RXDATA，这两个寄存器都是 32 位的，如果要发送数据就向寄存器 ECSPIx_TXDATA 写入数据，读取及存取 ECSPIx_RXDATA 里面的数据就可以得到刚刚接收到的数据</li></ul><h3 id="ICM-20608-简介"><a href="#ICM-20608-简介" class="headerlink" title="ICM-20608 简介"></a>ICM-20608 简介</h3><p>ICM-20608 是 InvenSense 出品的一款 6 轴 MEMS 传感器，包括 3 轴加速度和 3 轴陀螺仪。 ICM-20608 采用 16P 的 LGA 封装, 内部有一个 512 字节的 FIFO。陀螺仪的量程范围可以编程设置，可选择±250，±500，±1000 和±2000°/s， 加速度的量程范围也可以编程设置，可选择±2g，±4g，±4g，±8g 和±16g。陀螺仪和加速度计都是 16 位的 ADC，并且支持 I2C 和 SPI 两种协议，使用 I2C 接口的话通信速度最高可以达到 400KHz，使用 SPI 接口的话通信速度最高可达到 8MHz。ICM-20608 特性如下：</p><ol><li>陀螺仪支持 X,Y 和 Z 三轴输出，内部集成 16 位 ADC，测量范围可设置：±250，± 500，±1000 和±2000°/s</li><li>加速度计支持 X,Y 和 Z 轴输出，内部集成 16 位 ADC，测量范围可设置：±2g，±4g， ±4g，±8g 和±16g</li><li>用户可编程中断</li><li>内部包含 512 字节的 FIFO</li><li>内部包含一个数字温度传感器</li><li>耐 10000g 的冲击</li><li>支持快速 I2C，速度可达 400KHz</li><li>支持 SPI，速度可达 8MH</li></ol><p>使用 IIC 接口 ICM-20608 的 AD0 引脚决定 I2C 设备从地址的最后一位，如果 AD0 为 0 的话 ICM-20608 从设备地址是 0X68，如果 AD0 为 1 的话 ICM-20608 从设备地址为 0X69。使用 SPI 接口，ICM-20608 也是通过读写寄存器来配置和读取传感器数据，使用 SPI 接口读写寄存器需要 16 个时钟或者更多(如果读写操作包括多个字节的话)，第一个字节包含要读写的寄存器地址，寄存器地址最高位是读写标志位，如果是读的话寄存器地址最高位要为 1，如果是写的话寄存器地址最高位要为 0，剩下的 7 位才是实际的寄存器地址，寄存器地址后面跟着的就是读写的数据。关于 ICM-20608 的详细寄存器和位的介绍参考 ICM-20608 的寄存器手册</p><h2 id="实验程序"><a href="#实验程序" class="headerlink" title="实验程序"></a>实验程序</h2><p>文件 bsp_spi.c 中有两个函数：spi_init 和 spich0_readwrite_byte，函数 spi_init 是 SPI 初始化函数，此函数会初始化 SPI 的时钟，通道等。函数 spich0_readwrite_byte 是 SPI 收发函数， 通过此函数即可完成 SPI 的全双工数据收发</p><p>文件 bsp_icm20608.h 里面先定义了一个宏 ICM20608_CSN，这个是 ICM20608 的 SPI 片选引脚。接下来定义了一些 ICM20608 的 ID 和寄存器地址。定义了一个结构体 icm20608_dev_struc，这个结构体是 ICM20608 的设备结构体，里面的成员变量用来保存 ICM20608 的原始数据值和经过转换得到的实际值。实际值是有小数的</p><p>文件 bsp_imc20608.c 是 ICM20608 的驱动文件，里面有 7 个函数， icm20608_init，这个是 ICM20608 的初始化函数，此函数先初始化 ICM20608 所使用的 SPI 引脚，将其复用为 ECSPI3。因为我们的 SPI 片选采用软件控制的方式，所以 SPI 片选引脚设置成了普通的输出模式。设置完 SPI 所使用的引脚以后就是调用函数 spi_init 来初 始化 SPI3，最后初始化 ICM20608，就是配置 ICM20608 的寄存器。接下来函数分别是 icm20608_write_reg 和 icm20608_read_reg，这两个函数分别用于写/读 ICM20608 的指定寄存器。 icm20608_read_len，此函数也是读取 ICM20608 的寄存器值，但是此函数可 以读取连续多个寄存器的值，一般用于读取 ICM20608 传感器数据。 icm20608_gyro_scaleget 和 icm20608_accel_scaleget，这两个函数分别用于获取陀螺仪和加速度 计的分辨率，因为陀螺仪和加速度的测量范围设置的不同，其分辨率就不同，所以在计算实际值的时候要根据实际的量程范围来得到对应的分辨率。最后是 icm20608_getdata，此函数用于获取 ICM20608 的加速度计、陀螺仪和温度计的数据，并且会根据设置的测量范围计算出实际的值，比如加速度的 g 值、陀螺仪的角速度值和温度计的温度值</p><p>文件 main.c 一开始有两个函数 integer_display 和 decimals_display，这两个函数用于在 LCD 上显示获取到的 ICM20608 数据值，函数 integer_display 用于显示原始数据值，也就是整数值。 函数 decimals_display 用于显示实际值，实际值扩大了 100 倍，此函数会提取出实际值的整数部分和小数部分并显示在 LCD 上。另一个重要的函数是 imx6ul_hardfpu_enable，这个函数用于开启 I.MX6U 的 NEON 和硬件 FPU(浮点运算单元)，因为使用到了浮点运算，而 I.MX6U 的 Cortex-A7 是支持 NEON 和 FPU(VFPV4_D32)的，但是在使用 I.MX6U 的硬件 FPU 之前是先要开启的。 调用了函数 icm20608_init 来初始化 ICM20608，如果初始化失败的话就会在 LCD 上闪烁提示语句。最后在 main 函数的 while 循环中不断的调用函数 icm20608_getdata 获取 ICM20608 的传感器数据，并且显示在 LCD 上</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;SPI-实验&quot;&gt;&lt;a href=&quot;#SPI-实验&quot; class=&quot;headerlink&quot; title=&quot;SPI 实验&quot;&gt;&lt;/a&gt;SPI 实验&lt;/h1&gt;&lt;p&gt;同 I2C 一样</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://www.chenzhan.club/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note22.2-I2C实验</title>
    <link href="https://www.chenzhan.club/2021/03/02/note22-2-I2C%E5%AE%9E%E9%AA%8C/"/>
    <id>https://www.chenzhan.club/2021/03/02/note22-2-I2C%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-03-01T16:40:54.000Z</published>
    <updated>2021-04-12T13:31:55.817Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="I2C-amp-AP3216C-简介"><a href="#I2C-amp-AP3216C-简介" class="headerlink" title="I2C &amp; AP3216C 简介"></a>I2C &amp; AP3216C 简介</h1><h2 id="I2C-简介"><a href="#I2C-简介" class="headerlink" title="I2C 简介"></a>I2C 简介</h2><p>I2C 是一种总线协议，是 NXP 公司设计的，I2C 使用两条线在主控制器和从机之间进行数据通信。一条是 SCL(串行时钟线)，另外一条是 SDA(串行数据线)，这两条数据线需要接上拉电阻，总线空闲的时候 SCL 和 SDA 处于高电平。I2C 总线标准模式下速度可以 达到 100Kb/S，快速模式下可以达到 400Kb/S。I2C 总线工作是按照一定的协议来运行的，接下来就看一下 I2C 协议。 I2C 是支持多从机的，也就是一个 I2C 控制器下可以挂多个 I2C 从设备，这些不同的 I2C 从设备有不同的器件地址，这样 I2C 主控制器就可以通过 I2C 设备的器件地址访问指定的 I2C 设备</p><p>SDA 和 SCL 这两根线必须要接一个上拉电阻，一般是 4.7K。其余的 I2C 从器件都挂接到 SDA 和 SCL 这两根线上，这样就可以通过 SDA 和 SCL 这两根线来访问多个 I2C 设备</p><p>I2C协议术语</p><p><strong>起始位</strong> 就是 I2C 通信起始标志，通过这个起始位就可以告诉 I2C 从机，将开始进行 I2C 通信。在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位</p><p><strong>停止位</strong> 停止位就是停止 I2C 通信的标志位，和起始位的功能相反。在 SCL 位高电平的时候，SDA 出现上升沿就表示为停止位</p><p><strong>数据传输</strong> I2C 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，因此 SDA 上 的数据变化只能在 SCL 低电平期间发生</p><p><strong>应答信号</strong> 当 I2C 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 I2C 从机应答，也就是 等到 I2C 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败</p><p><strong>I2C 写时序</strong> 主机通过 I2C 总线与从机之间进行通信不外乎两个操作：写和读</p><p>写时序的具体步骤：</p><ol><li>开始信号</li><li>发送 I2C 设备地址，每个 I2C 器件都有一个设备地址，通过发送具体的设备地址来决定访问哪个 I2C 器件。这是一个 8 位的数据，其中高 7 位是设备地址，最后 1 位是读写位，为 1 的话表示这是一个读操作，为 0 的话表示这是一个写操作</li><li>I2C 器件地址后面跟着一个读写位，为 0 表示写操作，为 1 表示读操作</li><li>从机发送的 ACK 应答信号</li><li>重新发送开始信号</li><li>发送要写写入数据的寄存器地址</li><li>从机发送的 ACK 应答信号</li><li>发送要写入寄存器的数据</li><li>从机发送的 ACK 应答信号</li><li>停止信号</li></ol><p><strong>I2C 读时序</strong></p><p>I2C 单字节读时序比写时序要复杂一点，读时序分为 4 大步，第一步是发送设备地址，第二步是发送要读取的寄存器地址，第三步重新发送设备地址，最后一步就是 I2C 从器件输出要读取的寄存器值：</p><ol><li>主机发送起始信号</li><li>主机发送要读取的 I2C 从设备地址</li><li>读写控制位，因为是向 I2C 从设备发送数据，因此是写信号</li><li>从机发送的 ACK 应答信号</li><li>重新发送 START 信号</li><li>主机发送要读取的寄存器地址</li><li>从机发送的 ACK 应答信号</li><li>重新发送 START 信号</li><li>重新发送要读取的 I2C 从设备地址</li><li>读写控制位，这里是读信号，表示接下来是从 I2C 从设备里面读取数据</li><li>从机发送的 ACK 应答信号</li><li>从 I2C 器件里面读取到的数据</li><li>主机发出 NO ACK 信号，表示读取完成，不需要从机再发送 ACK 信号了</li><li>主机发出 STOP 信号，停止 I2C 通信</li></ol><p><strong>I2C 多字节读写时序</strong></p><p>有时候我们需要读写多个字节，多字节读写时序和单字节的基本一致，只是在读写数据的时候可以连续发送多个自己的数据，其他的控制时序都是和单字节一样的</p><h2 id="I-MX6U-I2C-简介"><a href="#I-MX6U-I2C-简介" class="headerlink" title="I.MX6U I2C 简介"></a>I.MX6U I2C 简介</h2><p>I.MX6U 提供了 4 个 I2C 外设，通过这四个 I2C 外设即可完成与 I2C 从器件进行通信， I.MX6U 的 I2C 外设特性如下：</p><ol><li>与标准 I2C 总线兼容</li><li>多主机运行 </li><li>软件可编程的 64 中不同的串行时钟序列</li><li>软件可选择的应答位</li><li>开始/结束信号生成和检测</li><li>重复开始信号生成</li><li>确认位生成</li><li>总线忙检测</li></ol><p>I.MX6U 的 I2C 支持两种模式：标准模式和快速模式，标准模式下 I2C 数据传输速率最高是 100Kbits/s，在快速模式下数据传输速率最高为 400Kbits/s</p><p>I2C 的几个重要的寄存器</p><ul><li>I2Cx_IADR(x=1~4)寄存器，这是 I2C 的地址寄存器，寄存器 I2Cx_IADR 只有 ADR(bit7:1)位有效，用来保存 I2C 从设备地址数据。当我们要访问某个 I2C 从设备的时候就需要将其设备地址写入到 ADR 里面</li><li>寄存器 I2Cx_IFDR，这个是 I2C 的分频寄存器，寄存器 I2Cx_IFDR 也只有 IC(bit5:0)这个位，用来设置 I2C 的波特率，I2C 的时钟源可以选 择 IPG_CLK_ROOT=66MHz，通过设置 IC 位既可以得到想要的 I2C 波特率</li><li>寄存器 I2Cx_I2CR，这个是 I2C 控制寄存器</li><li>寄存器就是 I2Cx_I2DR，这是 I2C 的数据寄存器，此寄存器只有低 8 位有效，当 要发送数据的时候将要发送的数据写入到此寄存器，如果要接收数据的话直接读取此寄存器即 可得到接收到的数据</li></ul><h2 id="AP3216C-简介"><a href="#AP3216C-简介" class="headerlink" title="AP3216C 简介"></a>AP3216C 简介</h2><p>通过 I2C1 连接了一个三合一环境传感器：AP3216C，AP3216C 是由敦南科技推出的一款传感器，其支持环境光强度(ALS)、接近距离(PS)和红外线强度(IR)这 三个环境参数检测。该芯片可以通过 IIC 接口与主控制相连，并且支持中断，AP3216C 的特点如下：</p><ol><li><p>I2C 接口，快速模式下波特率可以到 400Kbit/S </p></li><li><p>多种工作模式选择：ALS、PS+IR、ALS+PS+IR、PD 等等</p></li><li><p>内建温度补偿电路</p></li><li><p>宽工作温度范围(-30°C ~ +80°C)</p></li><li><p>超小封装，4.1mm x 2.4mm x 1.35mm </p></li><li><p>环境光传感器具有 16 位分辨率</p></li><li><p>接近传感器和红外传感器具有 10 位分辨率</p></li></ol><p>AP3216C 常被用于手机、平板、导航设备等，其内置的接近传感器可以用于检测是否有物 体接近，比如手机上用来检测耳朵是否接触听筒，如果检测到的话就表示正在打电话，手机就 会关闭手机屏幕以省电。也可以使用环境光传感器检测光照强度，可以实现自动背光亮度调节</p><p>AP3216 的设备地址为 0X1E，同几乎所有的 I2C 从器件一样，AP3216C 内部也有一些寄存 器，通过这些寄存器我们可以配置 AP3216C 的工作模式，并且读取相应的数据</p><p>0X00 这个寄存器是模式控制寄存器，用来设置 AP3216C 的工作模式， 一般开始先将其设置为 0X04，也就是先软件复位一次 AP3216C。接下来根据实际使用情况选 择合适的工作模式，比如设置为 0X03，也就是开启 ALS+PS+IR。从 0X0A~0X0F 这 6 个寄存 器就是数据寄存器，保存着 ALS、PS 和 IR 这三个传感器获取到的数据值。如果同时打开 ALS、 PS 和 IR 的读取间隔最少要 112.5ms，因为 AP3216C 完成一次转换需要 112.5ms。关于 AP3216C 的介绍就到这里，如果要想详细的研究此芯片的话，请大家自行查阅其数据手册。 本章实验中我们通过 I.MX6U 的 I2C1 来读取 AP3216C 内部的 ALS、PS 和 IR 这三个传感 器的值，并且在 LCD 上显示。开机会先检测 AP3216C 是否存在，一般的芯片是有个 ID 寄存 器，通过读取 ID 寄存器判断 ID 是否正确就可以检测芯片是否存在。但是 AP3216C 没有 ID 寄 存器，所以我们就通过向寄存器 0X00 写入一个值，然后再读取 0X00 寄存器，判断读出得到值 和写入的是否相等，如果相等就表示 AP3216C 存在，否则的话 AP3216C 就不存在</p><ol><li>初始化相应的 IO 初始化 I2C1 相应的 IO，设置其复用功能，如果要使用 AP3216C 中断功能的话，还需要设 置 AP3216C 的中断 IO</li><li>初始化 I2C1 初始化 I2C1 接口，设置波特率</li><li>初始化 AP3216C 初始化 AP3216C，读取 AP3216C 的数据</li></ol><p>文件bsp_i2c.c一共有8个函数，函数i2c_init， 用来初始化 I2C，重点是设置 I2C 的波特率，初始化完成以后开启 I2C。i2c_master_repeated_start函数用来发送一个重复开始信号，发送开始信号的时候也会顺带发送从设备地址。i2c_master_start 用于发送一个开始信号，发送开始信号的时候也顺带发送从设备地址。i2c_check_and_clear_error函数用于检查并清除错误。i2c_master_stop，用于产生一个停止信号。i2c_master_write 和 i2c_master_read，这两个函数分别用于完成向 I2C 从设备写数据和从 I2C 从设备读数据。i2c_master_transfer函数就是用户最终调用的，用于完成 I2C 通信的函数，此函数会使用前面的函数拼凑出 I2C 读/写时序。此函数就是按照  I2C 读写时序来编写的</p><p>文件 bsp_ap3216c.c 共有 4 个函数， ap3216c_init 函数用 于初始化 AP3216C，初始化成功的话返回 0，如果初始化失败就返回其他值。此函数先初始化所使用到的 IO，比如初始化 I2C1 的相关 IO，并设置其复用为 I2C1。然后此函数会调用 i2c_init 来初始化 I2C1，最后初始化 AP3216C。ap3216c_writeonebyte 和 ap3216c_readonebyte，这两个函数分别是向 AP3216C 写入数据和从 AP3216C 读取数据。这两个函数都通过调用 bsp_i2c.c 中的函数 i2c_master_transfer 来完成对 AP3216C 的读写。ap3216c_readdata函数用于读取 AP3216C 中的 ALS、PS 和 IR 传感器数据</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;I2C-amp-AP3216C-简介&quot;&gt;&lt;a href=&quot;#I2C-amp-AP3216C-简介&quot; class=&quot;headerlink&quot; title=&quot;I2C &amp;amp; </summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://www.chenzhan.club/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note21.2-RTC实时时钟</title>
    <link href="https://www.chenzhan.club/2021/03/01/note21-2-RTC%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F/"/>
    <id>https://www.chenzhan.club/2021/03/01/note21-2-RTC%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F/</id>
    <published>2021-03-01T06:52:25.000Z</published>
    <updated>2021-04-12T13:31:46.996Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="I-MX6U-RTC-简介"><a href="#I-MX6U-RTC-简介" class="headerlink" title="I.MX6U RTC 简介"></a>I.MX6U RTC 简介</h1><p>大多数MCU 或者 MPU 内部自带了实时时钟外设模块。如 I.MX6U 内部的 SNVS 就提供了 RTC 功能</p><p>SNVS 直译是安全的非易性存储，SNVS 里面主要是一些低功耗的外设，包括一个安全的实时计数器(RTC)、一个单调计数器(monotonic counter)和一些通用的寄存器，这里只使用实时计数器(RTC)。SNVS 里面的外设在芯片掉电以后由电池供电继续运行，I.MX6UALPHA 开发板上有一个纽扣电池，这个纽扣电池就是在主电源关闭以后为 SNVS 供电的</p><p>纽扣电池在掉电以后会继续给 SNVS 供电，因此实时计数器就会一直运行，这样的话时间信息就不会丢失。在有纽扣电池作为后备电源的情况下，不管系统主电源是否断电，SNVS 都正常运行。SNVS 有两部分：SNVS_HP 和 SNVS_LP，系统主电源断电以后 SNVS_HP 也会断电，但是在后备电源支持下，SNVS_LP 是不会断电的，而且 SNVS_LP 是和芯片复位隔离开的，因此 SNVS_LP 相关的寄存器的值会一直保存着。 SNVS 分为两个子模块：SNVS_HP 和 SNVS_LP，也就是高功耗域(SNVS_HP)和低功耗域 (SNVS_LP)，这两个域的电源来源如下： SNVS_LP：专用的 always-powered-on 电源域，系统主电源和备用电源都可以为其供电。 SNVS_HP：系统(芯片)电源。 SNVS 的这两个子模块的电源如图所示</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note21-RTC实时时钟\image-20210301145727911.png" alt="image-20210301145727911"></p><p>图中各个部分功能如下：</p><p>、VDD_HIGH_IN 是系统(芯片)主电源，这个电源会同时供给给 SNVS_HP 和 SNVS_LP</p><p>、VDD_SNVS_IN 是纽扣电池供电的电源，这个电源只会供给给 SNVS_LP，保证在系统主电源 VDD_HIGH_IN 掉电以后 SNVS_LP 会继续运行</p><p>、SNVS_HP 部分</p><p>、SNVS_LP 部分，此部分有个 SRTC，这个就是我们要使用的 RTC。</p><p>SNVS_HP 和 SNVS_LP，其内部都有一个 SRTC，但因为 SNVS_HP 在系统电源掉电以后就会关闭，所以我们使用的是 SNVS_LP 内部的 SRTC。SNVS_HP 在设备每次关闭以后时钟都被清零，然后开机以后先设置时钟</p><p>不管是 SNVS_HP 里面的 RTC，还是 SNVS_LP 里面的 SRTC，本质是一个定时 器，和 EPIT 定时器一样，只要提供时钟，就会一直运行。SRTC 需要外界提供一个 32.768KHz 的时钟，I.MX6U-ALPHA 核心板上的 32.768KHz 的晶振就是提供这个时钟的。寄存器 SNVS_LPSRTCMR 和 SNVS_LPSRTCLR 保存着秒数，直接读取这两个寄存器的值就知道过了多长时间了。一般以 1970 年 1 月 1 日为起点，加上经过的秒数即可得到现在的时间和日期。SRTC 带有闹钟功能的，可以在寄存器 SNVS_LPAR 中写入闹钟时间值，当时钟值和闹钟值匹配的时候就会产生闹钟中断，要使用时钟功能的话还需要进行一些设置</p><p>与 SRTC 相关的部分寄存器，首先是 SNVS_HPCOMR 寄存器，这个寄存器只用到了位：NPSWA_EN(bit31)，这个位是非特权软件访问控制位，如果非特权软件要访问 SNVS 的话此位必须为 1</p><p>寄存器SNVS_LPCR寄存器，此寄存器也只用到了一个位：SRTC_ENV(bit0)， 此位为 1 的话就使能 STC 计数器</p><p><del>寄存器 SNVS_SRTCMR 和 SNVS_SRTCLR，这两个寄存器保存着 RTC 的秒数，按照NXP官方的《6UL参考手册》中的说法，SNVS_SRTCMR保存着高15位，SNVS_SRTCLR 保存着低 32 位，因此 SRTC 的计数器一共是 47 位</del></p><p>但是！老师在编写驱动的时候发现按照手册上说的去读取计数器值是错误的！具体表现就是 时间是混乱的，因此老师在查找了 NXP 提供的 SDK 包中的 fsl_snvs_hp.c 以及 Linux 内核中的 rtcsnvs.c 这两个驱动文件以后发现《6UL 参考手册》上对 SNVS_SRTCMR 和 SNVS_SRTCLR 的 解释是错误的，经过查阅这两个文件，<strong>得到如下结论</strong>： </p><ol><li>SRTC 计数器是 32 位的，不是 47 位！</li><li>SNVS_SRTCMR 的 bit14:0 这 15 位是 SRTC 计数器的高 15 位</li><li>SNVS_SRTCLR 的 bit31:bit15 这 17 位是 SRTC 计数器的低 17 位</li></ol><p>按照上面的解释去读取这两个寄存器就可以得到正确的时间，如果要调整时间的话也是向这两个寄存器写入要设置的时间值对应的秒数就可以了，但是修改这两个寄存器的话要先关闭 SRTC。关于这些寄存器详细的描述，参考 《I.MX6UL 参考手册》第 2931 页的 46.7 小节</p><p>使用 I.MX6U 的 SNVS_LP 的 SRTC， 配置步骤如下</p><ol><li><p>初始化 SNVS_SRTC </p><p>初始化 SNVS_LP 中的 SRTC</p></li><li><p>设置 RTC 时间 </p><p>第一次使用 RTC 肯定要先设置时间</p></li><li><p>使能 RTC </p><p>配置好 RTC 并设置好初始时间以后就可以开启 RTC </p></li></ol><p>文件 bsp_rtc.c 里面一共有 9 个函数，函数 rtc_init 是初始化rtc的，主要是使能RTC，也可以在rtc_init函数里面设置时间。函数rtc_enable和rtc_disable 分别是 RTC 的使能和禁止函数。函数 rtc_isleapyear 用于判断某一年是否为闰年。函数 rtc_coverdate_to_seconds 负责将给定的日期和时间信息转换为对应的秒数。函数 rtc_setdatetime 用于设置时间，也就是设置寄存器 SNVS_LPSRTCMR 和 SNVS_LPSRTCLR 。 函 数 rtc_convertseconds_to_datetime 用于将给定的秒数转换为对应的时间值。函数 rtc_getseconds 获 取 SRTC 当前秒数，其实就是读取寄存器 SNVS_LPSRTCMR 和 SNVS_LPSRTCLR，然后将其 结合成 47 位的值。最后一个函数 rtc_getdatetime 是获取时间值</p><p>我们在 main 函数里面先初始化 RTC，然后进入 3S 倒计时， 如果这 3S 内按下了 KEY0 按 键，那么就设置 SRTC 的日期。如果 3S 倒计时结束以后没有按下 KEY0，也就是没有设置 SRTC 时间的话就进入 while 循环，然后读取 RTC 的时间值并且显示在 LCD 上</p><hr><p>参考资料：正点原子    《I.MX6UL 参考手册》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;I-MX6U-RTC-简介&quot;&gt;&lt;a href=&quot;#I-MX6U-RTC-简介&quot; class=&quot;headerlink&quot; title=&quot;I.MX6U RTC 简介&quot;&gt;&lt;/a&gt;I</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://www.chenzhan.club/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note20.2-RGBLCD显示</title>
    <link href="https://www.chenzhan.club/2021/03/01/note20-2-RGBLCD%E6%98%BE%E7%A4%BA/"/>
    <id>https://www.chenzhan.club/2021/03/01/note20-2-RGBLCD%E6%98%BE%E7%A4%BA/</id>
    <published>2021-02-28T16:02:57.000Z</published>
    <updated>2021-04-12T13:30:31.729Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="RGBLCD-显示"><a href="#RGBLCD-显示" class="headerlink" title="RGBLCD 显示"></a>RGBLCD 显示</h1><h2 id="LCD-和-eLCDIF-简介"><a href="#LCD-和-eLCDIF-简介" class="headerlink" title="LCD 和 eLCDIF 简介"></a>LCD 和 eLCDIF 简介</h2><h3 id="LCD-简介"><a href="#LCD-简介" class="headerlink" title="LCD 简介"></a>LCD 简介</h3><p>LCD 全称是 Liquid Crystal Display，是液晶显示器，LCD 的原理解释如下： LCD 的构造是在两片平行的玻璃基板当中放置液晶盒，下基板玻璃上设置 TFT（薄膜晶体管），上基板玻璃上设置彩色滤光片，通过 TFT 上的信号与电压改变来控制液晶分子的转动方向，从而达到控制每个像素点偏振光出射与否而达到显示目的</p><ul><li>分辨率</li></ul><p>LCD 显示器 720P、1080P、2K 或 4K ，就是 LCD 显示器分辨率。是由一个一个的像素点组成，像素点类似一个灯(在 OLED 显示器中，像素点就是一个小灯)，这个小灯是 RGB 灯，也就是由 R(红色)、G(绿色)和 B(蓝色)这三 种颜色组成的，而 RGB 就是光的三原色。1080P 的意思就是一个 LCD 屏幕上的像素数量是 1920*1080 个，也就是这个屏幕一列 1080 个像素点，一共 1920 列</p><p>1080P 显示器像素示意图中，X 轴就是 LCD 显示器的横轴，Y 轴就是显示器的竖轴。图中小方块就是像素点，一共有 1920*1080=2073600 个像素点。左上角的 A 点是第一个像素点，右下角的 C 点就是最后一个像素点。2K 就是 25601440 个像素点，4K 是 38402160 个像素点。在 LCD 尺寸不变的情况下，分辨率越高越清晰。分辨率不变的情况下，LCD 尺寸越小越清晰。衡量一款 LCD 的好坏，分辨率只是其中的一个参数，还有色彩还原程度、色彩偏离、亮 度、可视角度、屏幕刷新率等其他参数</p><ul><li>像素格式</li></ul><p>一个像素点相当于一个 RGB 小灯，通过控制 R、G、B 这三种颜色的亮度可以显示出各种各样的色彩。一般一个 R、 G、B 这三部分分别使用 8bit 的数据，那么一个像素点就是 8bit*3=24bit，也就是说一个像素点 3 个字节，这种像素格式称为 RGB888。如果在加入 8bit 的 Alpha(透明)通道的话一个像素点就是 32bit，也就是 4 个字节，这种像素格式称为 ARGB8888。ARGB8888 这种像素格式，一个像素占用 4 个字节的内存，这四个字节每个位的分配如图</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note20-RGBLCD显示\image-20210301001603955.png" alt="image-20210301001603955"></p><p>图中，一个像素点是 4 个字节，其中 bit31<del>bit24 是 Alpha 通道，bit23</del>bit16 是 RED 通道，bit15<del>bit14 是 GREEN 通道，bit7</del>bit0 是 BLUE 通道。所以红色对应的值就是 0X00FF0000，蓝色对应的值就是 0X000000FF，绿色对应的值为 0X0000FF00。通过调节 R、G、 B的比例可以产生其它的颜色，比如0X00FFFF00就是黄色，0X00000000就是黑色，0X00FFFFFF 就是白色</p><ul><li>LCD 屏幕接口</li></ul><p>LCD 屏幕即显示器有很多种接口，比如显示器上常见的 VGA、HDMI、DP 等等， 但I.MX6U-ALPHA开发板不支持这些接口。I.MX6U-ALPHA支持RGB接口的LCD，RGBLCD 接口的信号线如表所示</p><table><thead><tr><th>信号线</th><th>描述</th></tr></thead><tbody><tr><td>R[7:0]</td><td>8 根红色数据线</td></tr><tr><td>G[7:0]</td><td>8 根绿色数据线</td></tr><tr><td>B[7:0]</td><td>8 根蓝色数据线</td></tr><tr><td>DE</td><td>数据使能线</td></tr><tr><td>VSYNC</td><td>垂直同步信号线</td></tr><tr><td>HSYNC</td><td>水平同步信号线</td></tr><tr><td>PCLK</td><td>像素时钟信号线</td></tr></tbody></table><p>表是RGBLCD的信号线，R[7:0]、G[7:0]和B[7:0]这24根是数据线，DE、VSYNC、 HSYNC 和 PCLK 这四根是控制信号线。RGB LCD 一般有两种驱动模式：DE 模式和 HV 模式， 这两个模式的区别是 DE 模式需要用到 DE 信号线，而 HV 模式不需要用到 DE 信号线，在 DE 模式下是可以不需要 HSYNC 信号线的，即使不接 HSYNC 信号线 LCD 也可以正常工作。 ALIENTEK 一共有三款 RGB LCD 屏幕，型号分别为：ATK-4342(4.3 寸，480 * 272)、ATK7084(7 寸，800 * 480)和 ATK-7016(7 寸，1024 * 600)</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note20-RGBLCD显示\image-20210301002234070.png" alt="image-20210301002234070"></p><p> J1 是对外接口，是一个 40PIN 的 FPC 座（0.5mm 间距），通过 FPC 线，可以连接到 I.MX6U-ALPHA 开发板上面，从而实现和 I.MX6U 的连接。该接口十分完善，采用 RGB888 格式，并支持 DE&amp;HV 模式，还支持触摸屏和背光控制。右侧的几个电阻，可以用户自己选择。默认情况，R1 和 R6 焊接，设置 LCD_LR 和 LCD_UD，控制 LCD 的扫描方向，是从左到右，从上到下（横屏看）。而 LCD_R7/G7/B7 则用来设置 LCD 的 ID，由于 RGBLCD 没有读写寄存器，也就没有所谓的 ID，这里我们通过在模块上面，控制 R7/G7/B7 的 上/下拉，来自定义 LCD 模块的 ID，帮助 MCU 判断当前 LCD 面板的分辨率和相关参数，以提高程序兼容性。这几个位的设置关系如表所示：</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note20-RGBLCD显示\image-20210301002350840.png" alt="image-20210301002350840"></p><p>ATK-7016 模块，就设置 M2:M0=010 即可。这样，我们在程序里面，读取 LCD_R7/G7/B7， 得到 M0:M2 的值，从而判断 RGBLCD 模块的型号，并执行不同的配置，即可实现不同 LCD 模 块的兼容</p><ul><li>LCD 时间参数</li></ul><p>LCD 扫描一帧图像由一行一行组成的。HSYNC 是水平同步信号，也叫做行同步信号，当产生此信号的话就表示开始显示新的一行了，所以此信号都是在图的最左边。当 VSYNC 信号是垂直同步信号，也叫做帧同步信号，当产生此信号的话就表示开始显示新的一帧图像了，所以此信号在图的左上角。 在图可以看到有一圈“黑边”，真正有效的显示区域是中间的白色部分。CRT 显示器后面是个电子枪，电子枪打出的电子撞 击到屏幕上的荧光物质使其发光。只要控制电子枪从左到右扫完一行(也就是扫描一行)，然后从上到下扫描完所有行，这样一帧图像就显示出来。显示一帧图像电子枪是按照 ‘Z’形在运动，当扫描速度很快的时候看起来就是一幅完成的画面了。 当显示完一行以后会发出 HSYNC 信号，此时电子枪就会关闭，然后迅速的移动到屏幕的 左边，当 HSYNC 信号结束以后就可以显示新的一行数据了，电子枪就会重新打开。在 HSYNC 信号结束到电子枪重新打开之间会插入一段延时，这段延时就是图中的 HBP。当显示完一行以后就会关闭电子枪等待 HSYNC 信号产生，关闭电子枪到 HSYNC 信号产生之间会插入一段延时，这段延时就是图中的 HFP 信号。同理，当显示完一帧图像以后电子枪也会关闭，然后等到 VSYNC 信号产生，期间也会加入一段延时，这段延时就是图中的 VFP。 VSYNC 信号产生，电子枪移动到左上角，当 VSYNC 信号结束以后电子枪重新打开，中间也会加入一段延时，这段延时就是图中的 VBP</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note20-RGBLCD显示\image-20210301002857220.png" alt="image-20210301002857220"></p><p>HBP、HFP、VBP 和 VFP 是导致图 24.1.1.5 中黑边的原因，LCD 显示器， RGB LCD 屏幕内部是有一个 IC 的，发送一行或者一帧数据给 IC，IC 是需要反应时间的。通过这段反应 时间可以让 IC 识别到一行数据扫描完了，要换行了，或者一帧图像扫描完了，要开始下一帧图 像显示了。因此，在 LCD 屏幕中继续存在 HBP、HFP、VPB 和 VFP 这四个参数的主要目的是 为了锁定有效的像素数据。这四个时间是 LCD 重要的时间参数，后面编写 LCD 驱动的时候要 用到的，至于这四个时间参数具体值是多少，需要去查看所使用的 LCD 数据手册</p><ul><li>RGB LCD 屏幕时序</li></ul><p><img src="/Chenzhan666.github.io/.club//Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210301003541074.png" alt="image-20210301003541074"></p><p><strong>HSYNC</strong>8：行同步信号，当此信号有效的话就表示开始显示新的一行数据，查阅所使用的 LCD 数据手册可以知道此信号是低电平有效还是高电平有效，假设此时是低电平有效</p><p><strong>HSPW</strong>：有些地方也叫做 thp，是 HSYNC 信号宽度，也就是 HSYNC 信号持续时间</p><p>HSYNC 信号不是一个脉冲，而是需要持续一段时间才是有效的，单位为 CLK</p><p><strong>HBP</strong>：有些地方叫做 thb，前面已经讲过了，术语叫做行同步信号后肩，单位是 CLK </p><p><strong>HOZVAL</strong>：有些地方叫做 thd，显示一行数据所需的时间，假如屏幕分辨率为 1024*600， 那么 HOZVAL 就是 1024，单位为 CLK</p><p><strong>HFP</strong>：有些地方叫做 thf，前面已经讲过了，术语叫做行同步信号前肩，单位是 CLK</p><p>当 HSYNC 信号发出以后，需要等待 HSPW+HBP 个 CLK 时间才会接收到真正有效的像素数据。当显示完一行数据以后需要等待 HFP 个 CLK 时间才能发出下一个 HSYNC 信号，所以 显示一行所需要的时间就是：HSPW + HBP + HOZVAL + HFP，一帧图像就是由很多个行组成的</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note20-RGBLCD显示\image-20210301003753141.png" alt="image-20210301003753141"></p><p><strong>VSYNC</strong>：帧同步信号，当此信号有效的话就表示开始显示新的一帧数据，查阅所使用的 LCD 数据手册可以知道此信号是低电平有效还是高电平有效，假设此时是低电平有效</p><p><strong>VSPW</strong>：些地方也叫做 tvp，是 VSYNC 信号宽度，也就是 VSYNC 信号持续时间，单位为 1 行的时间</p><p><strong>VBP</strong>：有些地方叫做 tvb，前面已经讲过了，术语叫做帧同步信号后肩，单位为 1 行的时间 </p><p><strong>LINE</strong>：有些地方叫做 tvd，显示一帧有效数据所需的时间，假如屏幕分辨率为 1024*600， 那么 LINE 就是 600 行的时间</p><p><strong>VFP</strong>：有些地方叫做 tvf，前面已经讲过了，术语叫做帧同步信号前肩，单位为 1 行的时间</p><p>显示一帧所需要的时间就是：VSPW+VBP+LINE+VFP 个行时间，最终的计算公式： </p><p>T = (VSPW+VBP+LINE+VFP) * (HSPW + HBP + HOZVAL + HFP)</p><p>因此我们在配置一款 RGB LCD 的时候需要知道这几个参数：HOZVAL(屏幕有效宽度)、 LINE(屏幕有效高度)、HBP、HSPW、HFP、VSPW、VBP 和 VFP</p><ul><li>像素时钟</li></ul><p>像素时钟就是 RGB LCD 的时钟信号，以 ATK7016 这款屏幕为例，显示一帧图像所需要的时钟数就是： </p><p>= (VSPW+VBP+LINE+VFP) * (HSPW + HBP + HOZVAL + HFP) </p><p>= (3 + 20 + 600 + 12) * (20 + 140 + 1024 + 160) </p><p>= 635 * 1344 = 853440</p><p>显示一帧图像需要853440个时钟数，那么显示60帧就是：853440 * 60 = 51206400≈51.2M， 所以像素时钟就是 51.2MHz</p><p><strong>I.MX6U 的 eLCDIF 接口时钟图略</strong></p><p>以 ATK7016 屏幕所需的 51.2MHz 为例进行配置。 PLL5 频率设置涉及到四个寄存器：CCM_PLL_VIDEO、CCM_PLL_VIDEO_NUM、 CCM_PLL_VIDEO_DENOM 、 CCM_MISC2 。 其 中 CCM_PLL_VIDEO_NUM 和 CCM_PLL_VIDEO_DENOM 这两个寄存器是用于小数分频的，不使用小数分频，因此这两个寄存器设置为 0。 PLL5 的时钟计算公式如下： </p><p>PLL5_CLK = OSC24M * (loopDivider + (denominator / numerator)) / postDivider </p><p>不使用小数分频的话 PLL5 时钟计算公式就可以简化为 ： </p><p>PLL5_CLK = OSC24M * loopDivider / postDivider </p><p>OSC24M 就是 24MHz 的有源晶振</p><p>寄存器 CCM_PLL_VIDEO 用到的重要的位如下：</p><p>POST_DIV_SLECT(bit20:19)：此位和寄存器 CCM_ANALOG_CCMSC2 的 VIDEO_DIV 位共同决定了 postDivider，为 0 的话是 4 分频，为 1 的话是 2 分频，为 2 的话是 1 分频。设置为 2，也就是 1 分频</p><p>ENABLE(bit13)：PLL5(PLL_VIDEO)使能为 1 的话使能 PLL5，为 0 的话关闭 PLL5 DIV_SELECT(bit6:0)：loopDivider 值，范围为 27~54，设置为 32</p><p>寄存器 CCM_ANALOG_MISC2 的位 VIDEO_DIV(bit31:30)与寄存器 CCM_PLL_VIDEO 的位 POST_DIV_SLECT(bit20:19)共同决定了 postDivider，通过这两个的配合可以获得 2、4、8、16 分频。将 VIDEO_DIV 设置为 0，也就是 1 分频，因此 postDivider 就是 1，loopDivider 设 置为 32，PLL5 的时钟频率就是： </p><p>PLL5_CLK = OSC24M * loopDivider / postDivider </p><p>​                  = 24M * 32 / 1 </p><p>​                  = 768MHz</p><p>PLL5 此时为 768MHz，在经过图中的②和③进一步分频，设置②中为 3 分频，也 就是寄存器 CCM_CSCDR2 的位 LCDIF1_PRED(bit14:12)为 2。设置③中为 5 分频，就是寄存器 CCM_CBCMR 的位 LCDIF1_PODF(bit25:23)为 4。设置好以后最终进入到 LCDIF 的时钟频率就 是：768/3/5 =51.2MHz，这就是我们需要的像素时钟频率</p><ul><li>显存</li></ul><p>如果采用 ARGB8888 格式的话一个像素需要 4 个字节 的内存来存放像素数据，那么 1024 * 600 分辨率就需要 1024 * 600 * 4=2457600B≈2.4MB 内存。但 是 RGB LCD 内部是没有内存的，所以就需要在开发板上的 DDR3 中分出一段内存作为 RGB LCD 屏幕的显存，我们如果要在屏幕上显示什么图像的话直接操作这部分显存即可</p><h3 id="eLCDIF-接口"><a href="#eLCDIF-接口" class="headerlink" title="eLCDIF 接口"></a>eLCDIF 接口</h3><p>eLCDIF 是 I.MX6U 自带的液晶屏幕接口，用于连接 RGB LCD 接口的屏幕，eLCDIF 接口特性如下： </p><ol><li>支持 RGB LCD 的 DE 模式</li><li>支持 VSYNC 模式以实现高速数据传输</li><li>支持 ITU-R BT.656 格式的 4:2:2 的 YCbCr 数字视频，并且将其转换为模拟 TV 信号</li><li>支持 8/16/18/24/32 位 LCD</li></ol><p>eLCDIF 支持三种接口：MPU 接口、VSYNC 接口和 DOTCLK 接口，这三种接口区别如下： </p><ol><li><p>MPU 接口 MPU 接口用于在 I.MX6U 和 LCD 屏幕直接传输数据和命令，这个接口用于 6080/8080 接 口的 LCD 屏幕，如果寄存器 LCDIF_CTRL 的位 DOTCLK_MODE、DVI_MODE 和 VSYNC_MODE 都为 0 的话就表示 LCDIF 工作在 MPU 接口模式。关于 MPU 接口的详细信息以及时序参考《I.MX6ULL 参考手册》第 2150 页的“34.4.6 MPU Interface”小节</p></li><li><p>VSYNC 接口 VSYNC 接口时序和 MPU 接口时序基本一样， VSYNC 信号来作为帧同步，当 LCDIF_CTRL 的位 VSYNC_MODE 为 1 的时候此接口使能。关于 VSYNC 接口的详细信息请参 考《I.MX6ULL 参考手册》第 2152 页的“34.4.7 VSYNC Interface”小节</p></li><li><p>DOTCLK 接口DOTCLK 接口就是用来连接 RGB LCD 接口屏幕的， 它包括 VSYNC、HSYNC、DOTCLK 和 ENABLE(可选的)这四个信号，这样的接口通常被称为 RGB 接口</p></li></ol><ul><li>LCDIF_CTRL 寄存器</li><li>寄存器 LCDIF_CTRL1， 用 到 位 BYTE_PACKING_FORMAT(bit19:16)，此位用来决定在 32 位的数据中哪些字节的数据有效，默 认值为 0XF，也就是所有的字节有效，当为 0 的话表示所有的字节都无效</li><li>寄存器 LCDIF_TRANSFER_COUNT，用来设置所连接的 RGB LCD 屏幕分辨率大小</li><li>寄存器LCDIF_TRANSFER_COUNT分为两部分，高16位和低16位，高16位是V_COUNT， 是 LCD 的垂直分辨率</li><li>寄存器 LCDIF_VDCTRL0，这个寄存器是 VSYNC 和 DOTCLK 模式控制寄存器 0</li><li>寄存器 LCDIF_VDCTRL1，这个寄存器是 VSYNC 和 DOTCLK 模式控制寄 存器 1，此寄存器只有一个功能，用来设置 VSYNC 总周期，就是：屏幕高度+VSPW+VBP+VFP</li><li>寄存器 LCDIF_VDCTRL2，这个寄存器分为高 16 位和低 16 位两部分，高 16 位是 HSYNC_PULSE_WIDTH，用来设置 HSYNC 信号宽度，也就是 HSPW。低 16 位是 HSYNC_PERIOD，设置 HSYNC 总周期，就是：屏幕宽度+HSPW+HBP+HFP</li><li>寄存器 LCDIF_VDCTRL3</li><li>寄存器 LCDIF_VDCTRL4</li><li>寄存器 LCDIF_CUR_BUF 和 LCDIF_NEXT_BUF，这两个寄存器分别为当前 帧和下一帧缓冲区，也就是 LCD 显存。一般这两个寄存器保存同一个地址，也就是划分给 LCD 的显存首地址</li></ul><p>使用 I.MX6U 的 eLCDIF 接口来驱动 ALIENTEK 的 ATK7016 这款屏幕，配置步骤如下：</p><ol><li>初始化 LCD 所使用的 IO 首先肯定是初始化 LCD 所示使用的 IO，将其复用为 eLCDIF 接口 IO</li><li>设置 LCD 的像素时钟 查阅所使用的 LCD 屏幕数据手册，或者自己计算出的时钟像素，然后设置 CCM 相应的寄存器</li><li>配置 eLCDIF 接口 设置 LCDIF 的寄存器 CTRL、CTRL1、TRANSFER_COUNT、VDCTRL0~4、CUR_BUF 和 NEXT_BUF。根据 LCD 的数据手册设置相应的参数</li><li>编写 API 函数 驱动 LCD 屏幕的目的就是显示内容，所以需要编写一些基本的 API 函数，比如画点、画 线、画圆函数，字符串显示函数等</li></ol><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;RGBLCD-显示&quot;&gt;&lt;a href=&quot;#RGBLCD-显示&quot; class=&quot;headerlink&quot; title=&quot;RGBLCD 显示&quot;&gt;&lt;/a&gt;RGBLCD 显示&lt;/h1</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://www.chenzhan.club/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note19.2-DDR3内存芯片实验</title>
    <link href="https://www.chenzhan.club/2021/02/28/note19-2-DDR3%E5%86%85%E5%AD%98%E8%8A%AF%E7%89%87%E5%AE%9E%E9%AA%8C/"/>
    <id>https://www.chenzhan.club/2021/02/28/note19-2-DDR3%E5%86%85%E5%AD%98%E8%8A%AF%E7%89%87%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-02-28T03:17:12.000Z</published>
    <updated>2021-04-12T13:30:00.556Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="DDR3-内存简介"><a href="#DDR3-内存简介" class="headerlink" title="DDR3 内存简介"></a>DDR3 内存简介</h1><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p>随机存储器，可以随时进行读写操作，速度很快，掉电以后数据会丢失。比如内存 条、SRAM、SDRAM、DDR 等都是 RAM。RAM 一般用来保存程序数据、中间结果</p><p>可以随意的对 RAM 中任何地址的数据进行读写操作，不需要在乎具体的读写过程</p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>只读存储器，手机通常会是 4+64 或 6+128 配置，就是 RAM 为 4GB 或 6GB，ROM 为 64G 或 128GB。但是这个 ROM 是 Flash(flash memory闪存)，比如 EMMC 或 UFS 存储器，有些Flash 叫做 ROM。但 EMMC 和 UFS， NAND Flash，可以进行写操作的！只是写起来比较麻烦，要先发送要先进行擦除，然后在发送要写的地址或扇区，最后才是要写入的数据，相比于 RAM，向 ROM 或者 Flash 写入数据要复杂很多，因此意味着速度就会变慢(相比 RAM)， 但是 ROM 和 Flash 可以将容量做的很大，而且掉电以后数据不会丢失，适合用来存储资料，比如音乐、图片、视频等信息</p><p>综上所述，RAM 速度快，可以直接和 CPU 进行通信，但是掉电以后数据会丢失，容量不容易做大(和同价格的 Flash 相比)。ROM(目前来说，更适合叫做 Flash)速度虽然慢，但是容量大、适合存储数据</p><h2 id="SRAM-简介"><a href="#SRAM-简介" class="headerlink" title="SRAM 简介"></a>SRAM 简介</h2><p>Static Random-Access Memory静态随机存储器，这里的“静态” 说的是只要 SRAM 上电，那么 SRAM 里面的数据就会一直保存着，直到 SRAM 掉电。对于 RAM 而言需要可以随机的读取任意一个地址空间内的数据，因此采用了地址线和数据线分离的方式</p><p>IS62WV51216  是一颗 16 位宽(数据位为 16 位)、1MB 大小的 SRAM 芯片讲解一下 SRAM</p><p>主要分为三部分：</p><ol><li><p>地址线</p><p>一共 A0~A18，也就是 19 根地址线，因此可访问的地址大小就是 2^19=524288=512KB。又因为 IS62WV51216 是 16 位宽，也就是一次访问 2 个字节，因此需要对 512KB 进行乘 2 处理，得到 512KB*2=1MB。位宽一般有 8 位/16 位/32 位，根据实际需求选择即可，一般都是根据处理器的 SRAM 控制器位宽来选择 SRAM 位宽</p></li><li><p>数据线</p><p>根据 SRAM 位宽的不同，数据线的数量要不同，8 位宽就有 8 根数据线，16 位宽就有 16 根数据线。IS62WV51216 是 16 位宽 的 SRAM，有 16 根数据线，一次访问可以访问 16bit 的数据，也就是 2 个字节。因此就有高字节和低字节数据之分，其中 IO0<del>IO7 是低字节数据，IO8</del>IO15 是高字节数据</p></li><li><p>控制线</p><p>SRAM 工作需要控制线，CS2 和 CS1 是片选信号，低电平有效，在一个系统中可能会有多片 SRAM(目的是为了扩展 SRAM 大小或位宽)，这个时候就需要 CS 信号来选择当前使用哪片 SRAM。另外，有的 SRAM 内部其实是由两片 SRAM 拼接起来的，因此会提供两个片选信号</p><p>OE 是输出使能信号，低电平有效，也就是主控从 SRAM 读取数据</p><p>WE 是写使能信号，低电平有效，也就是主控向 SRAM 写数据</p><p>UB 和 LB 信号，这两根控制线都是低电平有效。UB 为低电平的话表示访问高字节，LB 为低电平的话表示访问低字节</p></li></ol><p>SRAM 价格贵但无需刷新(SDRAM 需要刷新，后面会讲解)，读写速度快， SRAM 通常作为 SOC 的内部 RAM 使用或 Cache 使用，I.MX6U 内部的 OCRAM 是 SRAM</p><h2 id="SDRAM-简介"><a href="#SDRAM-简介" class="headerlink" title="SDRAM 简介"></a>SDRAM 简介</h2><p>Synchronous Dynamic Random Access Memory 同步动态随机存储器，“同步”的意思是 SDRAM 工作需要时钟线，“动态”的意思是 SDRAM 中的数据需要不断的刷新来保证数据不会丢失，“随机” 的意思就是可以读写任意地址的数据</p><p>与 SRAM 相比，SDRAM 集成度高、功耗低、成本低、适合做大容量存储，但是需要定时刷新来保证数据不会丢失。因此 SDRAM 适合用来做内存条，SRAM 适合做高速缓存或 MCU 内部的 RAM。SDRAM 目前已经发展到了第四代，分别为：SDRAM、DDR SDRAM、DDR2 SDRAM、DDR3 SDRAM、DDR4 SDRAM。</p><p>W9825G6KH 是一款 16 位宽(数据位为 16 位)、32MB 的 SDRAM、速度一般为 133MHz、166MHz 或 200MHz，主要有这几部分：</p><ol><li><p>控制线 </p><p>SDRAM 需要很多控制线： </p><p>CLK：时钟线，SDRAM 是同步动态随机存储器，“同步”的意思就是时钟，因此需要一根额外的时钟线，这是和 SRAM 最大的不同，SRAM 没有时钟线 </p><p>CKE：时钟使能信号线，SRAM 没有 CKE 信号</p><p>CS：片选信号，这个和 SRAM 一样，都有片选信号 </p><p>RAS：行选通信号，低电平有效，SDRAM 和 SRAM 的寻址方式不同，SDRAM 按照行、 列来确定某个具体的存储区域。因此就有行地址和列地址之分，行地址和列地址共同复用同一 组地址线，要访问某一个地址区域，必须要发送行地址和列地址，指定要访问哪一行？哪一列？ RAS 是行选通信号，表示要发送行地址，行地址和列地址访问方式如图：</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note19-DDR3内存芯片实验\image-20210228133801189.png" alt="image-20210228133801189"></p><p>CAS：列选通信号，和 RAS 类似，低电平有效，选中以后就可以发送列地址了</p><p> WE：写使能信号，低电平有效</p></li><li><p>A10 地址线</p><p>A10 是地址线，还有另外一个作用，A10 还控制着 Auto-precharge，也就是预充电。这里又提到了预充电的概念，SDRAM 芯片内部会分为多个 BANK，关于 BANK 我们稍后会讲解。SDRAM 在读写完成以后，如果要对同一个 BANK 中的另一行进行寻址操作就必须将原来有效的行关闭，然后发送新的行/列地址，关闭现在工作的行，准备打开新行的操作就叫做预充电。一般 SDSRAM 都支持自动预充电的功能</p></li><li><p>地址线</p><p>对于 W9825G6KH 来说一共有 A0<del>A12，共 13 根地址线，但 SDRAM 寻址是按照行地址和列地址来访问的，因此这 A0</del>A12 包含了行地址和列地址。不同的 SDRAM 芯 片，根据其位宽、容量等的不同，行列地址数是不同的，这个在 SDRAM 的数据手册里面会也清楚的。比如 W9825G6KH 的 A0<del>A8 是列地址，一共 9 位列地址，A0</del>A12 是行地址，一共 13 位，因此可寻址范围为：2^9*2^13=4194304B=4MB，W9825G6KH 为 16 位宽(2 个字节)，因此需要对 4MB 进行乘 2 处理，得到 42=8MB，但是 W9825G6KH 是一个 32MB 的 SDRAM 算出来只有 8MB，仅仅为实际容量的 1/4。 8MB 只是一个 BANK 的容量，W9825G6KH 一共有 4 个 BANK</p></li><li><p>BANK 选择线</p><p>BS0 和 BS1 是 BANK 选择信号线，在一片 SDRAM 中因为技术、成本等原因，不可能做 一个全容量的 BANK。因为 SDRAM 的工作原理，单一的 BANK 会带来严重的寻址冲突，减低内存访问效率。为此，人们在一片 SDRAM 中分割出多块 BANK，一般都是 2 的 n 次 方，比如 2，4，8 等。每个 SDRAM 数据手册里面都会写清楚自己是几 BANK。计算出来一个 BANK 的大小为 8MB， 那么四个 BANK 的总容量就是 8MB*4=32MB。 既然有4个BANK，那么在访问的时候就需要告诉SDRAM，我们现在需要访问哪个BANK， BS0 和 BS1 就是为此而生的，4 个 BANK 刚好 2 根线，如果是 8 个 BANK 的话就需要三根线， 也就是 BS0~BS2。BS0、BS1 这两个线也是 SRAM 所没有的</p></li><li><p>BANK 区域</p></li><li><p>数据线</p><p>W9825G6KH 是 16 位宽的 SDRAM，因此有 16 根数据线，DQ0~DQ15，不同的位宽其数 据线数量不同</p></li><li><p>高低字节选择</p><p>W9825G6KH 是一个 16 位的 SDRAM，因此就分为低字节数据和高字节数据，LDQM 和 UDQM 就是低字节和高字节选择信号</p></li></ol><h2 id="DDR-简介"><a href="#DDR-简介" class="headerlink" title="DDR 简介"></a>DDR 简介</h2><p>DDR 内存是 SDRAM 的升级版本，SDRAM 分为 SDR SDRAM、 DDR SDRAM、DDR2 SDRAM、DDR3 SDRAM、DDR4 SDRAM。先来看一下 DDR，也就是 DDR1，为了提高 SDRAM 的速度，DDR SDRAM 诞生</p><p>DDR 全称是 Double Data Rate SDRAM，也就是双倍速率 SDRAM，DDR 的 速率(数据传输速率)比 SDRAM 高 1 倍！这 1 倍的速度不是简简单单的将 CLK(1.表示总线数据上计数器，一般为高电平时触发 2.表示计时器，在计算机以及网络领域中，多指处理器或总线等数字电路工作时的时间间隔信号，实质是指这种信号的频率 3.一种方波信号，使操作按顺序进行，有时称其为处理器时钟) 提高 1 倍， SDRAM 在一个 CLK 周期传输一次数据，DDR 在一个 CLK 周期传输两次数据，也就是在上升 沿和下降沿各传输一次数据，这个概念叫做预取(prefetch)，相当于 DDR 的预取为 2bit，因此 DDR 的速度直接加倍！比如 SDRAM 速度一般是 133<del>200MHz，对应的传输速度就是 133</del>200MT/s，在描述 DDR 速度的时候一般都使用 MT/s，也就是每秒多少兆次数据传输。 133MT/S 就是每秒 133M 次数据传输，MT/s 描述的是单位时间内传输速率。同样 133<del>200MHz 的频率，DDR 的传输速度就变为了 266</del>400MT/S，所以大家常说的 DDR266、DDR400 就是这 么来的</p><p>DDR2 的 IO 时钟是 DDR 的 2 倍，因此 DDR 内核时钟依旧是 133<del>200MHz 的时候，总线速度就是 266</del>400MHz。而且 DDR2 在 DDR 基础上进一步增加预取(prefetch)，增加到了 4bit， 相当于比 DDR 多读取一倍的数据，因此 DDR2 的数据传输速率就是 533~800MT/s，这个也就是大家常说的 DDR2 533、DDR2 800</p><p>DDR3 在 DDR2 的基础上将预取(prefetch)提高到 8bit，因此又获得了比 DDR2 高一倍的传输速率，因此在总线时钟同样为 266<del>400MHz 的情况下，DDR3 的传输速率就是 1066</del>1600MT/S。 I.MX6U 的 MMDC 外设用于连接 DDR，支持 LPDDR2、DDR3、DDR3L，最高支持 16 位数据位宽。总线速度为 400MHz(实际是 396MHz)，数据传输速率最大为 800MT/S</p><p>LPDDR3、DDR3 和 DDR3L 的区别，这三个都是 DDR3，但是区别主要在于工作电压，LPDDR3 叫做低功耗 DDR3，工作电压为 1.2V。DDR3 叫做标压 DDR3，工作电压为 1.5V，一般台式内存条都是 DDR3。DDR3L 是低压 DDR3，工作电压为 1.35V，一般手机、嵌入式、笔记本等都使用 DDR3L</p><p>NT5CC256M16EP-EK 是一款容量为 4Gb，也就是 512MB 大小、 16 位宽、1.35V、传输速率为 1866MT/S 的 DDR3L 芯片，结构如下</p><ol><li><p>控制线</p><p>ODT：片上终端使能，ODT 使能和禁止片内终端电阻</p><p>ZQ：输出驱动校准的外部参考引脚，此引脚应该外接一个 240 欧的电阻到 VSSQ 上，一般 就是直接接地了</p><p>RESET：复位引脚，低电平有效</p><p>CKE：时钟使能引脚</p><p>A12：A12 是地址引脚，但是有也有另外一个功能，因此也叫做 BC 引脚，A12 会在 READ 和 WRITE 命令期间被采样，以决定 burst chop 是否会被执行</p><p>CK 和 CK#：时钟信号，DDR3 的时钟线是差分时钟线，所有的控制和地址信号都会在 CK 对的上升沿和 CK#的下降沿交叉处被采集</p><p>CS#：片选信号，低电平有效。 RAS#、CAS#和 WE#：行选通信号、列选通信号和写使能信号</p></li><li><p>地址线</p><p>A[14:0]为地址线，A0<del>A14，一共 15 根地址线，根据 NT5CC256M16ER-EK 的数据手册可知，列地址为 A0</del>A9，共 10 根，行地址为 A0~A14，共 15 根，因此一个 BANK 的大小就是 2^10*2^152=32MB2=64MB，根据图 23.1.4.2 可知一共有 8 个 BANK，因此 DDR3L 的容量就 是 648=512MB</p></li><li><p>BANK 选择线</p><p>一片 DDR3 有 8 个 BANK，因此需要 3 个线才能实现 8 个 BANK 的选择，BA0~BA2 就是 用于完成 BANK 选择的</p></li><li><p>BANK 区域</p><p>DDR3 一般都是 8 个 BANK 区域</p></li><li><p>数据线</p><p>因为是 16 位宽的，因此有 16 根数据线，分别为 DQ0~DQ15</p></li><li><p>数据选通引脚</p><p>DQS 和 DQS#是数据选通引脚，为差分信号，读的时候是输出，写的时候是输入。LDQS(有的叫做 DQSL)和 LDQS#(有的叫做 DQSL#)对应低字节，也就是 DQ0<del>7，UDQS(有的叫做 DQSU) 和 UDQS#(有的叫做 DQSU#)，对应高字节，也就是 DQ8</del>15</p></li><li><p>数据输入屏蔽引脚</p><p>DM 是写数据收入屏蔽引脚</p></li></ol><h2 id="DDR3-关键时间参数"><a href="#DDR3-关键时间参数" class="headerlink" title="DDR3 关键时间参数"></a>DDR3 关键时间参数</h2><h3 id="传输速率MT-S"><a href="#传输速率MT-S" class="headerlink" title="传输速率MT/S"></a>传输速率MT/S</h3><p>决定了 DDR3 内 存的最高传输速率</p><h3 id="tRCD-参数"><a href="#tRCD-参数" class="headerlink" title="tRCD 参数"></a>tRCD 参数</h3><p>tRCD 全称是 RAS-to-CAS Delay，也就是行寻址到列寻址之间的延迟。DDR 的寻址流程是先指定 BANK 地址，然后在指定行地址，最后指定列地址确定最终要寻址的单元。BANK 地址和行地址是同时发出的，这个命令叫做“行激活”(Row Active)。行激活以后就发送列地址和具体的操作命令(读还是写)，这两个是同时发出的，因此一般也用“读/写命令”表示列寻址。在行有效(行激活)到读写命令发出的这段时间间隔叫做 tRCD</p><h3 id="CL-参数"><a href="#CL-参数" class="headerlink" title="CL 参数"></a>CL 参数</h3><p>当列地址发出以后就会触发数据传输，但是数据从存储单元到内存芯片 IO 接口上还需要一段时间，这段时间就是非常著名的 CL(CAS Latency)，也就是列地址选通潜伏期</p><h3 id="AL-参数"><a href="#AL-参数" class="headerlink" title="AL 参数"></a>AL 参数</h3><p>提出了一个前置 CAS 的概念，目的是为了解决 DDR 中的指令冲突， 它允许 CAS 信号紧随着 RAS 发送，相当于将 DDR 中的 CAS 前置了。但是读/写操作并没有因此提前，依旧要保证足够的延迟/潜伏期，为此引入了 AL(Additive Latency)，单位也是时钟周期数。AL+CL 组成了 RL(Read Latency)，从 DDR2 开始还引入了写潜伏期 WL(Write Latency)， WL 表示写命令发出以后到第一笔数据写入的潜伏期</p><p>tRCD，AL、CL、RL 为读潜伏期，RL=AL+CL</p><h3 id="tRC-参数"><a href="#tRC-参数" class="headerlink" title="tRC 参数"></a>tRC 参数</h3><p>RC 是两个 ACTIVE 命令，或者 ACTIVE 命令到 REFRESH 命令之间的周期</p><h3 id="tRAS-参数"><a href="#tRAS-参数" class="headerlink" title="tRAS 参数"></a>tRAS 参数</h3><p>tRAS 是 ACTIVE 命令到 PRECHARGE 命令之间的最小时间</p><h1 id="I-MX6U-MMDC-控制器"><a href="#I-MX6U-MMDC-控制器" class="headerlink" title="I.MX6U MMDC 控制器"></a>I.MX6U MMDC 控制器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MMDC 就是 I.MX6U 的内存控制器，MMDC 是一个多模的 DDR 控制器，可以连接 16 位宽的 DDR3/DDR3L、16 位 宽的 LPDDR2，MMDC 是一个可配置、高性能的 DDR 控制器。MMDC 外设包含一个内核 (MMDC_CORE)和 PHY(MMDC_PHY)，内核和 PHY 的功能如下： </p><p><strong>MMDC 内核</strong>：内核负责通过 AXI 接口与系统进行通信、DDR 命令生成、DDR 命令优化、 读/写数据路径</p><p><strong>MMDC PHY</strong>：PHY 负责时序调整和校准，使用特殊的校准机制以保障数据能够在 400MHz 被准确捕获</p><p>MMDC 的主要特性如下： </p><ol><li>支持 DDR3/DDR3Lx16、支持 LPDDR2x16，不支持 LPDDR1MDDR 和 DDR2</li><li>支持单片 256Mbit~8Gbit 容量的 DDR，列地址范围：8-12 位，行地址范围 11-16bit。2 个片选信号</li><li>对于 DDR3，最大支持 8bit 的突发访问</li><li>对于 LPDDR2 最大支持 4bit 的突发访问</li><li>MMDC 最大频率为 400MHz，因此对应的数据速率为 800MT/S</li><li>支持各种校准程序，可以自动或手动运行。支持 ZQ 校准外部 DDR 设备，ZQ 校准 DDR I/O 引脚、校准 DDR 驱动能力</li></ol><h2 id="MMDC-控制器信号引脚"><a href="#MMDC-控制器信号引脚" class="headerlink" title="MMDC 控制器信号引脚"></a>MMDC 控制器信号引脚</h2><p>DDR 对于硬件要求非常严格，因此 DDR 的引脚都是独立的，一般没有复用功能，只做为 DDR 引脚使用</p><p>DDR 引脚的电气属性寄存器和普通的外设引脚电气 属性寄存器不同</p><h2 id="MMDC-控制器时钟源"><a href="#MMDC-控制器时钟源" class="headerlink" title="MMDC 控制器时钟源"></a>MMDC 控制器时钟源</h2><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note19-DDR3内存芯片实验\image-20210228141132319.png" alt="image-20210228141132319"></p><p>MMDC 的时钟源路径图，主要分为 4 部分：</p><ol><li><p>pre_periph2 时钟选择器，也就是 periph2_clkd 的前级选择器，由 CBCMR 寄存器的 PRE_PERIPH2_CLK_SEL 位(bit22:21)来控制，一共有四种可选方案</p><table><thead><tr><th>PRE_PERIPH2_CLK_SEL(bit22:21)</th><th>时钟源</th></tr></thead><tbody><tr><td>00</td><td>PLL2</td></tr><tr><td>01</td><td>PLL2_PFD2</td></tr><tr><td>10</td><td>PLL2_PFD0</td></tr><tr><td>11</td><td>PLL4</td></tr></tbody></table></li></ol><ol start="2"><li><p>periph2_clk 时钟选择器，由 CBCDR 寄存器的 PERIPH2_CLK_SEL 位(bit26)来控制， 当为 0 的时候选择 pll2_main_clk 作为 periph2_clk 的时钟源，当为 1 的时候选择 periph2_clk2_clk 作为 periph2_clk 的时钟源。这里肯定要将 PERIPH2_CLK_SEL 设置为 0，也就是选择 pll2_main_clk 作为 periph2_clk 的时钟源，因此 periph2_clk=PLL2_PFD0=396MHz </p></li><li><p>最后就是分频器，由 CBCDR 寄存器的 FABRIC_MMDC_PODF 位(bit5:3)设置分频值， 可设置 0<del>7，分别对应 1</del>8 分频，要配置 MMDC 的时钟源为 396MHz，那么此处就要设置为 1 分频，因此 FABRIC_MMDC_PODF=0</p></li></ol><p>MMDC 的时钟源设置，说 DDR 的频率为 400MHz，但是实际只有 396MHz</p><h1 id="DDR3L初始化与测试"><a href="#DDR3L初始化与测试" class="headerlink" title="DDR3L初始化与测试"></a>DDR3L初始化与测试</h1><h2 id="dr-stress-tester配置文件"><a href="#dr-stress-tester配置文件" class="headerlink" title="dr_stress_tester配置文件"></a>dr_stress_tester配置文件</h2><p>excel配置文件，excel配置好以后realview.inc会同步的更新</p><h2 id="inc文件"><a href="#inc文件" class="headerlink" title=".inc文件"></a>.inc文件</h2><p>ddr_stress_tester工具需要用到.inc文件</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>ddr_stress_tester通过USB口将.inc中的配置信息下载到开发板里面。直接进行超频测试的话测试失败</p><h2 id="做校准"><a href="#做校准" class="headerlink" title="做校准"></a>做校准</h2><p>Write leveling calibration</p><p>MMDC_MPWLDECTRL0 ch0 (0x021b080c) = 0x00000000</p><p>MMDC_MPWLDECTRL1 ch0 (0x021b0810) = 0x00070007</p><p>Read DQS Gating calibration</p><p>MPDGCTRL0 PHY0 (0x021b083c) = 0x01380138</p><p>MPDGCTRL1 PHY0 (0x021b0840) = 0x00000000</p><p>Read calibration</p><p>MPRDDLCTL PHY0 (0x021b0848) = 0x40402E32</p><p>Write calibration</p><p>MPWRDLCTL PHY0 (0x021b0850) = 0x40403432</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;DDR3-内存简介&quot;&gt;&lt;a href=&quot;#DDR3-内存简介&quot; class=&quot;headerlink&quot; title=&quot;DDR3 内存简介&quot;&gt;&lt;/a&gt;DDR3 内存简介&lt;/h1</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://www.chenzhan.club/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note18.2-UART串口通信</title>
    <link href="https://www.chenzhan.club/2021/02/27/note18-2-UART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.chenzhan.club/2021/02/27/note18-2-UART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</id>
    <published>2021-02-27T02:44:38.000Z</published>
    <updated>2021-04-12T13:29:48.905Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="I-MX6U-串口简介"><a href="#I-MX6U-串口简介" class="headerlink" title="I.MX6U 串口简介"></a>I.MX6U 串口简介</h1><h2 id="UART-简介"><a href="#UART-简介" class="headerlink" title="UART 简介"></a>UART 简介</h2><h3 id="UART-通信格式"><a href="#UART-通信格式" class="headerlink" title="UART 通信格式"></a>UART 通信格式</h3><p>串口全称叫做串行接口，通常也叫做 COM 接口，串行接口指的是数据一个一个的顺序传输，通信线路简单。使用两条线即可实现双向通信，一条用于发送，一条用于接收。串口通信距离远，但是速度相对会低，串口是一种很常用的工业接口。I.MX6U 自带的 UART 外设就是串口的一种，UART 全称是 UniversalAsynchronous Receiver/Trasmitter，也就是异步串行收发器。还有 另 外一 个叫做 USART 的 东 西。 USART 的全称是 Universal Synchronous/Asynchronous Receiver/Transmitter，也就是同步/异步串行收发器。相比 UART 多了 一个同步的功能，在硬件上体现出来的就是多了一条时钟线。一般 USART 是可以作为 UART 使用的，也就是不使用其同步的功能。</p><p>UART 作为串口的一种，其工作原理也是将数据一位一位的进行传输，发送和接收各用一 条线，因此通过 UART 接口与外界相连最少只需要三条线：TXD(发送)、RXD(接收)和 GND(地线)</p><p><strong>空闲位：</strong>数据线在空闲状态的时候为逻辑“1”状态，也就是高电平，表示没有数据线空闲， 没有数据传输</p><p><strong>起始位：</strong>当要传输数据的时候先传输一个逻辑“0”，也就是将数据线拉低，表示开始数据传输</p><p><strong>数据位：</strong>数据位就是实际要传输的数据，数据位数可选择 5~8 位，我们一般都是按照字节传输数据的，一个字节 8 位，因此数据位通常是 8 位的。低位在前，先传输，高位最后传输</p><p><strong>奇偶校验位：</strong>这是对数据中“1”的位数进行奇偶校验用的，可以不使用奇偶校验功能</p><p><strong>停止位：</strong>数据传输完成标志位，停止位的位数可以选择 1 位、1.5 位或 2 位高电平，一般都 选择 1 位停止位</p><p><strong>波特率：</strong>波特率就是 UART 数据传输的速率，也就是每秒传输的数据位数，一般选择 9600、 19200、115200 等</p><h3 id="UART-电平标准"><a href="#UART-电平标准" class="headerlink" title="UART 电平标准"></a>UART 电平标准</h3><p>UART 一般的接口电平有 TTL 和 RS-232，一般开发板上都有 TXD 和 RXD 这样的引脚， 这些引脚低电平表示逻辑 0，高电平表示逻辑 1，这个就是 TTL 电平。RS-232 采用差分线，-3<del>- 15V 表示逻辑 1，+3</del>+15V 表示逻辑 0</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note18-UART串口通信\image-20210227105240199.png" alt="image-20210227105240199"></p><p>图中的模块就是 USB 转 TTL 模块，TTL 接口部分有 VCC、GND、RXD、TXD、 RTS 和 CTS。RTS 和 CTS 基本用不到，使用的时候通过杜邦线和其他模块的 TTL 接口相连即可</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note18-UART串口通信\image-20210227105332047.png" alt="image-20210227105332047"></p><p>RS-232 电平需要 DB9 接口</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note18-UART串口通信\image-20210227105426834.png" alt="image-20210227105426834"></p><p> USB 转串口 TTL 芯片，比如 CH340、PL2303 等。通过这些芯片就可以实现串口 TTL 转 USB。I.MX6UALPHA开发板就使用CH340 芯片来完成UART1和电脑之间的连接，只需要一条USB 线即可</p><h2 id="I-MX6U-UART-简介"><a href="#I-MX6U-UART-简介" class="headerlink" title="I.MX6U UART 简介"></a>I.MX6U UART 简介</h2><p>I.MX6U 一共 有 8 个 UART，其主要特性如下： </p><ol><li>兼容 TIA/EIA-232F 标准，速度最高可到 5Mbit/S</li><li>支持串行 IR 接口，兼容 IrDA，最高可到 115.2Kbit/s</li><li>支持 9 位或者多节点模式(RS-485)</li><li>1 或 2 位停止位</li><li>可编程的奇偶校验(奇校验和偶校验)</li><li>自动波特率检测(最高支持 115.2Kbit/S</li></ol><p>UART 的时钟源是由寄存器 CCM_CSCDR1 的 UART_CLK_SEL(bit)位来选择的，当为 0 的 时候 UART 的时钟源为 pll3_80m(80MHz)，如果为 1 的时候 UART 的时钟源为 osc_clk(24M)， 一般选择 pll3_80m 作为 UART 的时钟源。寄存器 CCM_CSCDR1 的 UART_CLK_PODF(bit5:0) 位是 UART 的时钟分频值，可设置 0<del>63，分别对应 1</del>64 分频，一般设置为 1 分频，因此最终 进入 UART 的时钟为 80MHz</p><h3 id="UART-几个重要的寄存器，-UART-的控制寄存器-1，即-UARTx-UCR1-x-1-8"><a href="#UART-几个重要的寄存器，-UART-的控制寄存器-1，即-UARTx-UCR1-x-1-8" class="headerlink" title="UART 几个重要的寄存器， UART 的控制寄存器 1，即 UARTx_UCR1(x=1~8)"></a>UART 几个重要的寄存器， UART 的控制寄存器 1，即 UARTx_UCR1(x=1~8)</h3><p>寄存器 UARTx_UCR1 我们用到的重要位如下：</p><p><strong>ADBR(bit14)：</strong>自动波特率检测使能位，为 0 的时候关闭自动波特率检测，为 1 的时候使 能自动波特率检测</p><p><strong>UARTEN(bit0)：</strong>UART 使能位，为 0 的时候关闭 UART，为 1 的时候使能 UART</p><h3 id="UART-的控制寄存器-2，即：UARTx-UCR2"><a href="#UART-的控制寄存器-2，即：UARTx-UCR2" class="headerlink" title="UART 的控制寄存器 2，即：UARTx_UCR2"></a>UART 的控制寄存器 2，即：UARTx_UCR2</h3><h3 id="UARTx-UCR3-寄存器"><a href="#UARTx-UCR3-寄存器" class="headerlink" title="UARTx_UCR3 寄存器"></a>UARTx_UCR3 寄存器</h3><h3 id="寄-存-器-UARTx-UFCR-、-UARTx-UBIR-和-UARTx-UBMR-，"><a href="#寄-存-器-UARTx-UFCR-、-UARTx-UBIR-和-UARTx-UBMR-，" class="headerlink" title="寄 存 器 UARTx_UFCR 、 UARTx_UBIR 和 UARTx_UBMR ，"></a>寄 存 器 UARTx_UFCR 、 UARTx_UBIR 和 UARTx_UBMR ，</h3><p>寄 存 器 UARTx_UFCR 中我们要用到的是位 RFDIV(bit9:7)，用来设置参考时钟分频</p><table><thead><tr><th>RFDIV(bit9:7)</th><th>分频值</th></tr></thead><tbody><tr><td>000</td><td>6 分频</td></tr><tr><td>001</td><td>5 分频</td></tr><tr><td>010</td><td>4 分频</td></tr><tr><td>011</td><td>3 分频</td></tr><tr><td>100</td><td>2 分频</td></tr><tr><td>101</td><td>1 分频</td></tr><tr><td>110</td><td>7 分频</td></tr><tr><td>111</td><td>保留</td></tr></tbody></table><p>通过这三个寄存器可以设置 UART 的波特率，波特率的计算公式如下：<br>$$<br>Baud Rate = 𝑅𝑒𝑓 𝐹𝑟𝑒𝑞 /(16 × （𝑈𝐵𝑀𝑅 + 1）/（ 𝑈𝐵𝐼𝑅 + 1） )<br>$$</p><table><thead><tr><th>Ref Freq</th><th>经过分频以后进入 UART 的最终时钟频率</th></tr></thead><tbody><tr><td>UBMR</td><td>寄存器 UARTx_UBMR 中的值</td></tr><tr><td>UBIR</td><td>寄存器 UARTx_UBIR 中的值</td></tr></tbody></table><p>通过 UARTx_UFCR 的 RFDIV 位、UARTx_UBMR 和 UARTx_UBIR 这三者的配合即可得 到我们想要的波特率。比如现在要设置 UART 波特率为 115200，那么可以设置 RFDIV 为 5(0b101)，也就是 1 分频，因此 Ref Freq=80MHz。设置 UBIR=71，UBMR=3124，根据上面的 公式可以得到：<br>$$<br>Baud Rate = 𝑅𝑒𝑓 𝐹𝑟𝑒𝑞 /(16 × （𝑈𝐵𝑀𝑅 + 1）/（ 𝑈𝐵𝐼𝑅 + 1） ) = 80000000 /(16 × （3124 + 1）/（ 71+ 1） ) = 115200<br>$$</p><h3 id="寄存器-UARTx-URXD-和-UARTx-UTXD，"><a href="#寄存器-UARTx-URXD-和-UARTx-UTXD，" class="headerlink" title="寄存器 UARTx_URXD 和 UARTx_UTXD，"></a>寄存器 UARTx_URXD 和 UARTx_UTXD，</h3><p>这两个寄存器分别为 UART 的接 收和发送数据寄存器，这两个寄存器的低八位为接收到的和要发送的数据。读取寄存器UARTx_URXD 即可获取到接收到的数据，如果要通过 UART 发送数据，直接将数据写入到寄 存器 UARTx_UTXD 即可</p><h2 id="UART1-的配置步骤如下"><a href="#UART1-的配置步骤如下" class="headerlink" title="UART1 的配置步骤如下"></a>UART1 的配置步骤如下</h2><ol><li>设置 UART1 的时钟源 设置 UART 的时钟源为 pll3_80m，设置寄存器 CCM_CSCDR1 的 UART_CLK_SEL 位为 0 即可</li><li>初始化 UART1 初始化 UART1 所使用 IO，设置 UART1 的寄存器 UART1_UCR1~UART1_UCR3，设置内容包括波特率，奇偶校验、停止位、数据位等等</li><li>使能 UART1 UART1 初始化完成以后就可以使能 UART1 了，设置寄存器 UART1_UCR1 的位 UARTEN 为 1</li><li>编写 UART1 数据收发函数 编写两个函数用于 UART1 的数据收发操作</li></ol><p>6ULL的UART_URXD寄存器保存这串口接收到的数据。</p><p>UART_UTXD寄存器为发送数据寄存器，如果需要通过串口发送数据，只需要将数据写入到UART_UTXD寄存器里面。</p><p>UART_UCR1~UCR4都是串口的控制寄存器。UART_UCR1的bit0是UART的使能位，为1的时候使能UART。Bit14为自动检测波特率使能位，为1的时候使能波特率自动检测。</p><p>UART_UCR2的bit0为软件复位位。为0的时候复位UART。Bit1使能UART的接收，我们要配置为1。Bit2为发送使能，要设置为1。Bit5设置数据位，0的话表示7位数据位，1的话表示8位数据位。Bit6设置停止位，0的话表示1位停止位，1的话表示2位。Bit7奇偶校验位，为0的时候是偶校验，为1的时候是计校验。Bit8校验使能位，为0的时候关闭校验。</p><p>UART_UCR3的bit2必须为1！！！</p><p>UART_UFCR寄存器的bit9~7设置分频值，UART的时钟源=PLL3/6=480/6=80MHz。CSCDR1寄存器的UART_CLK_SEL位设置UART的时钟源，为0的时候UART时钟源为80MHz</p><p>,为1的时候UART时钟源为24M晶振。CSCDR1寄存器的UART_CLK_PODF位控制分频，一般设置为1分频，因此UART_CLK_ROOT=80MHZ</p><p>UART_UFCR、UART_UBIR和UART_UBMR这三个寄存器决定了串口波特率。</p><p>UART_USR2寄存器的bit0为1的时候表示有数据可以读取。Bit3为1的时候表示数据发送完成</p><p>UART1_TXD使用的IO为UART1_TX_DATA，UART1_RXD所使用的IO为UART1_RX_DATA。</p><p> Putc和puts编译的时候会提示吧报错，要在Makefile中添加-fno-builtin</p><p> SecuCRT打开以后串口接收到乱码，因为Linux默认用UTF-8编码，因此我们需要设置SecureCRT的编码模式为UTF-8</p><p>我们移植的printf不支持浮点计算和输出！！！！！</p><p>文件 bsp_uart.c 中共有 10 个函数，第一个函数 是 uart_init，这个函数是 UART1 初始化函数，用于初始化 UART1 相关的 IO、并且设置 UART1 的波特率、字长、停止位和校验模式等，初始化完成以后就使能 UART1。第二个函数是 uart_io_init，用于初始化 UART1 所使用的 IO。第三个函数是 uart_setbaudrate，这个函数是从 NXP 官方的 SDK 包里面移植过来的，用于设置波特率。只需将要设置的波特率告诉此函 数，此函数就会使用逐次逼近方式来计算出寄存器 UART1_UFCR 的 FRDIV 位、寄存器 UART1_UBIR 和寄存器 UART1_UBMR 这三个的值。第四和第五这两个函数为 uart_disable 和 uart_enable，分别是使能和关闭 UART1。第 6 个函数是 uart_softreset，用于软件复位指定的 UART。 第七个函数是putc，用于通过UART1发送一个字节的数据。第八个函数是puts，用于通过UART1 发送一串数据。第九个函数是 getc，用于通过 UART1 获取一个字节的数据，最后一个函数是 raise，这是一个空函数，防止编译器报错</p><h2 id="I-MX6U-ALPHA-开发板串口-1-硬件原理图"><a href="#I-MX6U-ALPHA-开发板串口-1-硬件原理图" class="headerlink" title="I.MX6U-ALPHA 开发板串口 1 硬件原理图"></a>I.MX6U-ALPHA 开发板串口 1 硬件原理图</h2><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note18-UART串口通信\image-20210227111151868.png" alt="image-20210227111151868"></p><h2 id="编译下载验证"><a href="#编译下载验证" class="headerlink" title="编译下载验证"></a>编译下载验证</h2><p>Makefile 文件在链接的时候加入了数学库， 因为在 bsp_uart.c 中有个函数 uart_setbaudrate，在此函数中使用到了除法运算，因此在链接的时候需要将编译器的数学库也链 接进来。第9行的变量LIBPATH就是数学库的目录，在第56行链接的时候使用了变量LIBPATH。 要用到一些第三方库，那么在连接程序的时候就需要指定这些第三方库所在的目录，Makefile 在链接的时候使用选项“-L”来指定库所在的目录，比如“示 例代码 21.4.1”中第 9 行的变量 LIBPATH 就是指定了我们所使用的编译器库所在的目录</p><p>打开快速连接设置界面，设置好相应的串口参数:</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note18-UART串口通信\image-20210227111602010.png" alt="image-20210227111602010"></p><h1 id="串口格式化函数移植"><a href="#串口格式化函数移植" class="headerlink" title="串口格式化函数移植"></a>串口格式化函数移植</h1><h2 id="串口格式化函数简介"><a href="#串口格式化函数简介" class="headerlink" title="串口格式化函数简介"></a>串口格式化函数简介</h2><p>格式化函数说的是 printf、sprintf 和 scanf 这样的函数，分为格式化输入和格式化输出两类函数。学习 C 语言的时候常常通过 printf 函数在屏幕上显示字符串，通过 scanf 函数从键盘获取输入。这样就有了输入和输出了，实现了最基本的人机交互。在 I.MX6U-ALPHA 开发板上可以将 printf 和 scanf 映射到串口上，就可以使用 SecureCRT 作为开发板的终端，完成与开发板的交互。也可以使用 printf 和 sprintf 来实现各种各样的格式化字符串，方便后续的开发。串口驱动我们上已经编写完成了，而且实现了最基本的字节收发，本章我们就通过移植网上别人已经做好的文件来实现格式化函数</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;I-MX6U-串口简介&quot;&gt;&lt;a href=&quot;#I-MX6U-串口简介&quot; class=&quot;headerlink&quot; title=&quot;I.MX6U 串口简介&quot;&gt;&lt;/a&gt;I.MX6U </summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://www.chenzhan.club/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note17.2-EPIT定时器，按键消抖，高精度延时</title>
    <link href="https://www.chenzhan.club/2021/02/26/note17-2-EPIT%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/"/>
    <id>https://www.chenzhan.club/2021/02/26/note17-2-EPIT%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-02-25T17:03:15.000Z</published>
    <updated>2021-04-12T13:29:37.266Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="EPIT-定时器简介"><a href="#EPIT-定时器简介" class="headerlink" title="EPIT 定时器简介"></a>EPIT 定时器简介</h1><p>EPIT 的全称是：Enhanced Periodic Interrupt Timer，直译过来就是增强的周期中断定时器， 它主要是完成周期性中断定时的</p><ol><li>EPIT是32位的一个向下计数器</li><li>EPIT的时钟源可以选择，我们选择ipg_clk=66MHz</li><li>可以对时钟源进行分频，12位的分频器，0<del>4095分别代表1</del>4096分频</li><li>开启定时器以后，计数寄存器会每个时钟减1，如果和比较寄存器里面的值相等的话就会触发中断</li></ol><p>EPIT有两种工作模式：Set-add-forget，一个是free-runing</p><ol start="5"><li>6ULL有两个EPIT定时器</li></ol><p>EPIT_CR寄存器用于配置EPIT</p><p>EPIT 是一个 32 位定时器，在处理器几乎不用介入的情况下提供精准的定时中断，软件使 能以后 EPIT 就会开始运行，EPIT 定时器有如下特点：</p><ol><li>时钟源可选的 32 位向下计数器</li><li>12 位的分频值</li><li>当计数值和比较值相等的时候产生中断</li></ol><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note17-EPIT定时器实验\image-20210226011448197.png" alt="image-20210226011448197"></p><p>①、这是个多路选择器，用来选择 EPIT 定时器的时钟源，EPIT 共有 3 个时钟源可选择， ipg_clk、ipg_clk_32k 和 ipg_clk_highfreq</p><p>②、这是一个 12 位的分频器，负责对时钟源进行分频，12 位对应的值是 0<del>4095，对应着 1</del>4096 分频</p><p>③、经过分频的时钟进入到 EPIT 内部，在 EPIT 内部有三个重要的寄存器：计数寄存器 (EPIT_CNR)、加载寄存器(EPIT_LR)和比较寄存器(EPIT_CMPR)，这三个寄存器都是 32 位的。 EPIT 是一个向下计数器，也就是说给它一个初值，它就会从这个给定的初值开始递减，直到减为 0，计数寄存器里面保存的就是当前的计数值。如果 EPIT 工作在 set-and-forget 模式下，当计数寄存器里面的值减少到 0，EPIT 就会重新从加载寄存器读取数值到计数寄存器里面，重新开 始向下计数。比较寄存器里面保存的数值用于和计数寄存器里面的计数值比较，如果相等的话 就会产生一个比较事件</p><p>④、比较器</p><p>⑤、EPIT 可以设置引脚输出，如果设置了的话就会通过指定的引脚输出信号</p><p>⑥、产生比较中断，也就是定时中断。 EPIT 定时器有两种工作模式：set-and-forget 和 free-running，这两个工作模式的区别如下： set-and-forget 模式：EPITx_CR(x=1，2)寄存器的 RLD 位置 1 的时候 EPIT 工作在此模式 下，在此模式下 EPIT 的计数器从加载寄存器 EPITx_LR 中获取初始值，不能直接向计数器寄存器写入数据。不管什么时候，只要计数器计数到 0，那么就会从加载寄存器 EPITx_LR 中重新加载数据到计数器中，周而复始。 free-running 模式：EPITx_CR 寄存器的 RLD 位清零的时候 EPIT 工作在此模式下，当计数器计数到0以后会重新从0XFFFFFFFF开始计数，并不是从加载寄存器EPITx_LR中获取数据</p><p>EPIT_CR bit0为1，设置EPIT使能，bit1为1，设置计数器的初始值为记载寄存器的值。Bit2为1使能比较中断，bit3为1设置定时器工作在set-and-forget模式下。Bit15~bit4设置分频值。Bit25:24设置时钟源的选择，我们设置为1，那么EPIT的时钟源就为ipg_clock=66MHz </p><p>EPIT_SR寄存器，只有bit0有效，表示中断状态，写1清零。当OCIF位为1的时候表示中断发生，为0的时候表示中断未发生。我们处理完定时器中断以后一定要清除中断标志位</p><p>EPIT_LR寄存器设置计数器的加载值。计数器每次计时到0以后就会读取LR寄存器的值重新开始计时</p><p>CMPR比较计数器，当计数器的值和CMPR相等以后就会产生比较中断</p><p>使用EPIT实现500ms周期的定时器。我们在EPIT中断服务函数里面让LED灯亮灭</p><h1 id="EPIT-的配置寄存器-EPITx-CR"><a href="#EPIT-的配置寄存器-EPITx-CR" class="headerlink" title="EPIT 的配置寄存器 EPITx_CR"></a>EPIT 的配置寄存器 EPITx_CR</h1><p>CLKSRC(bit25:24)：EPIT 时钟源选择位，为 0 的时候关闭时钟源，1 的时候选择选择 Peripheral 时钟(ipg_clk)，为 2 的时候选择 High-frequency 参考时钟(ipg_clk_highfreq)，为 3 的时 候选择 Low-frequency 参考时钟(ipg_clk_32k)。我们设置为1，也就是选择 ipg_clk 作为 EPIT 的时钟源，ipg_clk=66MHz</p><p>PRESCALAR(bit15:4)：EPIT 时钟源分频值，可设置范围 0<del>4095，分别对应 1</del>4096 分频RLD(bit3)：EPIT 工作模式，为 0 的时候工作在 free-running 模式，为 1 的时候工作在 setand-forget 模式，设置为 1，也就是工作在 set-and-forget 模式</p><p>OCIEN(bit2)：比较中断使能位，为 0 的时候关闭比较中断，为 1 的时候使能比较中断，要使能比较中断</p><p>ENMOD(bit1)：设置计数器初始值，为 0 时计数器初始值等于上次关闭 EPIT 定时器以后计数器里面的值，为 1 的时候来源于加载寄存器</p><p>EN(bit0)：EPIT 使能位，为 0 的时候关闭 EPIT，为 1 的时候使能 EPIT。 </p><p>寄存器 EPITx_SR 结构体：寄存器 EPITx_SR 只有一个位有效，那就是 OCIF(bit0)，这个位是比较中断标志位，为 0 的时候表示没有比较事件发生，为 1 的时候表示有比较事件发生。当比较中断发生以后需要手动清除此位，此位是写 1 清零的</p><p>寄存器 EPITx_LR、EPITx_CMPR 和 EPITx_CNR 分别为加载寄存器、比较寄存器和计数寄存器，这三个寄存器都是用来存放数据的</p><p>EPIT 的配置步骤如下：</p><ol><li>设置 EPIT1 的时钟源 设置寄存器 EPIT1_CR 寄存器的 CLKSRC(bit25:24)位，选择 EPIT1 的时钟源</li><li>设置分频值设置寄存器 EPIT1_CR 寄存器的 PRESCALAR(bit15:4)位，设置分频值</li><li>设置工作模式设置寄存器 EPIT1_CR 的 RLD(bit3)位，设置 EPTI1 的工作模式</li><li>设置计数器的初始值来源设置寄存器 EPIT1_CR 的 ENMOD(bit1)位，设置计数器的初始值来源</li><li>使能比较中断我们要使用到比较中断，因此需要设置寄存器 EPIT1_CR 的 OCIEN(bit2)位，使能比较中断</li><li>设置加载值和比较值设置寄存器 EPIT1_LR 中的加载值和寄存器 EPIT1_CMPR 中的比较值，通过这两个寄存器就可以决定定时器的中断周期</li><li>EPIT1 中断设置和中断服务函数编写 使能 GIC 中对应的 EPIT1 中断，注册中断服务函数，如果需要的话还可以设置中断优先 级。最后编写中断服务函数</li><li>使能 EPIT1 定时器 配置好 EPIT1 以后就可以使能 EPIT1 了，通过寄存器 EPIT1_CR 的 EN(bit0)位来设置。 通过以上几步我们就配置好 EPIT 了，通过 EPIT 的比较中断来实现 LED0 的翻转</li></ol><h1 id="定时器按键消抖"><a href="#定时器按键消抖" class="headerlink" title="定时器按键消抖"></a>定时器按键消抖</h1><p>直接用延时函数来实现消抖会浪费 CPU 性能，因为在延时函数里面 CPU 什么都做不了。 如果按键使用中断的话更不能在中断里面使用延时函数，因为中断服务函数要快进快出</p><p>Linux 驱动里面按键消抖的做法—使用定时器来实现按键消抖</p><h2 id="定时器按键消抖简介"><a href="#定时器按键消抖简介" class="headerlink" title="定时器按键消抖简介"></a>定时器按键消抖简介</h2><p>在按键按下以后延时一段时间再 去读取按键值，如果此时按键值还有效那就表示这是一次有效的按键，中间的延时就是消抖, EPIT 定时器设置好定时时间，然后 CPU 可以做其他事情，定时时间到了以后就会触发中断，然后在中断中做相应的处理即可</p><p>即借助定时器来实现消抖，按键采用中断驱动方式，当按键按下以后触发按键中断，在 按键中断中开启一个定时器，定时周期为 10ms，当定时时间到了以后就会触发定时器中断，最 后在定时器中断处理函数中读取按键的值，如果按键值还是按下状态那就表示这是一次有效的按键</p><p>设置按键为下降沿触发，因 此会在 t1、t2 和 t3 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中 断，所以会在 t1、t2 和 t3 这三个时刻开器定时器中断。但是 t1<del>t2 和 t2</del>t3 这两个时间段是小于 我们设置的定时器中断周期(也就是消抖时间，比如 10ms)，所以虽然 t1 开启了定时器，但是定 时器定时时间还没到呢 t2 时刻就重置了定时器，最终只有 t3 时刻开启的定时器能完整的完成 整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现 按键防抖的原理，Linux 里面的按键驱动用的就是这个原理</p><p>使用 EPIT1 来配合按键 KEY 来实现具体的消抖，步骤如下：</p><ol><li>配置按键 IO 中断</li><li>初始化消抖用的定时器</li><li>编写中断处理函数</li></ol><p>文件 bsp_keyfilter.c 一共有 6 个函数。filterkey_init 是初始化函数，首先初始化了 KEY 所使用的 UART1_CTS 这个 IO，设置这个 IO 的中断模式，并且注册中断处理函数，最后调用函数 filtertimer_init 初始化定时器 EPIT1 定时周期为 10ms。函数 filtertimer_init 是定时器 EPIT1的初始化函数。函数 filtertimer_stop 和 filtertimer_restart 分别是 EPIT1 的关闭和重启函数。 filtertimer_irqhandler 是 EPTI1 的中断处理函数，此函数里面就是按键要做的工作。函数 gpio1_16_31_irqhandler 是 GPIO1_IO18 的中断处理函数，工作是重启定时器 EPIT1</p><h1 id="高精度延时"><a href="#高精度延时" class="headerlink" title="高精度延时"></a>高精度延时</h1><p>延时函数是很常用的 API 函数，但是使用循环来实现的延时函数不准确，误差会很大。延时函数肯定是越精确越好，这样延时函数就可 以使用在某些对时序要求严格的场合。要求严格的话就使用硬件定时器</p><h2 id="GPT-定时器"><a href="#GPT-定时器" class="headerlink" title="GPT 定时器"></a>GPT 定时器</h2><p>GPT 定时器是一个 32 位向上定时器(也就是从 0X00000000 开始向上递增计数)，GPT 定时 器也可以跟一个值进行比较，当计数器值和这个值相等的话就发生比较事件，产生比较中断。 GPT 定时器有一个 12 位的分频器，可以对 GPT 定时器的时钟源进行分频，GPT 定时器特性如下：</p><ol><li>一个可选时钟源的 32 位向上计数器</li><li>两个输入捕获通道，可以设置触发方式</li><li>三个输出比较通道，可以设置输出模式</li><li>可以生成捕获中断、比较中断和溢出中断</li><li>计数器可以运行在重新启动(restart)或(自由运行)free-run 模式</li></ol><p>共有五个时钟源，分别为：ipg_clk_24M、GPT_CLK(外部时钟)、 ipg_clk、ipg_clk_32k 和 ipg_clk_highfreq</p><h3 id="重新启动-restart-模式"><a href="#重新启动-restart-模式" class="headerlink" title="重新启动(restart)模式"></a>重新启动(restart)模式</h3><p>当 GPTx_CR(x=1，2)寄存器的 FRR 位清零的时候 GPT 工作在此 模式。在此模式下，当计数值和比较寄存器中的值相等的话计数值就会清零，然后重新从 0X00000000 开始向上计数，只有比较通道 1 才有此模式！向比较通道 1 的比较寄存器写入任何 数据都会复位 GPT 计数器。对于其他两路比较通道（通道 2 和 3），当发生比较事件以后不会 复位计数器</p><h3 id="自由运行-free-run-模式"><a href="#自由运行-free-run-模式" class="headerlink" title="自由运行(free-run)模式"></a>自由运行(free-run)模式</h3><p>当 GPTx_CR(x=1，2)寄存器的 FRR 位置 1 时候 GPT 工作在此模 式下，此模式适用于所有三个比较通道，当比较事件发生以后并不会复位计数器，而是继续计 数，直到计数值为 0XFFFFFFFF，然后重新回滚到 0X00000000</p><h3 id="GPT-定时器几个重要的寄存器"><a href="#GPT-定时器几个重要的寄存器" class="headerlink" title="GPT 定时器几个重要的寄存器"></a>GPT 定时器几个重要的寄存器</h3><h4 id="GPT-的配置寄存器-GPTx-CR"><a href="#GPT-的配置寄存器-GPTx-CR" class="headerlink" title="GPT 的配置寄存器 GPTx_CR"></a>GPT 的配置寄存器 GPTx_CR</h4><p>重要的位：</p><p>SWR(bit15)：复位 GPT 定时器</p><p>FRR(bit9)：运行模式选择</p><p>CLKSRC(bit8:6)：GPT 定时器时钟源选择位</p><p>ENMOD(bit1)：GPT 使能模式</p><p>EN(bit)：GPT 使能位</p><h4 id="GPT-定时器的分频寄存器-GPTx-PR"><a href="#GPT-定时器的分频寄存器-GPTx-PR" class="headerlink" title="GPT 定时器的分频寄存器 GPTx_PR"></a>GPT 定时器的分频寄存器 GPTx_PR</h4><p>重要的位</p><p>PRESCALER(bit11:0)：这就是 12 位分频值， 可设置 0<del>4095，分别对应 1</del>4096 分频</p><h4 id="GPT-定时器的状态寄存器-GPTx-SR"><a href="#GPT-定时器的状态寄存器-GPTx-SR" class="headerlink" title="GPT 定时器的状态寄存器 GPTx_SR"></a>GPT 定时器的状态寄存器 GPTx_SR</h4><p>重要的位</p><p>ROV(bit5：回滚标志位</p><p>IF2~IF1(bit4:3)：输入捕获标志位</p><p>OF3~OF1(bit2:0)：输出比较中断标志位</p><h4 id="GPT-定时器的计数寄存器-GPTx-CNT"><a href="#GPT-定时器的计数寄存器-GPTx-CNT" class="headerlink" title="GPT 定时器的计数寄存器 GPTx_CNT"></a>GPT 定时器的计数寄存器 GPTx_CNT</h4><p>寄存器保存着 GPT 定时器的当前 计数值</p><h4 id="GPT-定时器的输出比较寄存器-GPTx-OCR"><a href="#GPT-定时器的输出比较寄存器-GPTx-OCR" class="headerlink" title="GPT 定时器的输出比较寄存器 GPTx_OCR"></a>GPT 定时器的输出比较寄存器 GPTx_OCR</h4><p>每个输出比较通道对应一个 输出比较寄存器，因此一个 GPT 定时器有三个 OCR 寄存器</p><h2 id="定时器实现高精度延时原理"><a href="#定时器实现高精度延时原理" class="headerlink" title="定时器实现高精度延时原理"></a>定时器实现高精度延时原理</h2><p>高精度延时函数的实现要借助硬件定时器。如果设置 GPT 定时器的时钟源为 ipg_clk=66MHz，设置 66 分频，那么进入 GPT 定时器的最终时钟频率就是 66/66=1MHz，周期为 1us。GPT 的计数器每计一个数就表示“过去” 了 1us。如果计 10 个数就表示“过去”了 10us。通过读取寄存器 GPTx_CNT 中的值就知道计了几个数，比如现在要延时 100us，那么进入延时函数以后纪录下寄存器 GPTx_CNT 中的值为 200， 当 GPTx_CNT 中的值为 300 (过去了100个数)的时候就表示 100us 过去了，也就是延时结束。GPTx_CNT 是个 32 位寄存器，如果时钟为 1MHz 的话，GPTx_CNT 最多可以实现 0XFFFFFFFFus=4294967295us ≈4294s≈72min。也就是说 72 分钟以后 GPTx_CNT 寄存器就会回滚到 0X00000000，也就是溢出，所以需要在延时函数中要处理溢出的情况。高精度延时的实现步骤如下：</p><ol><li>设置 GPT1 定时器 首先设置 GPT1_CR 寄存器的 SWR(bit15)位来复位寄存器 GPT1。复位完成以后设置寄存器 GPT1_CR 寄存器的 CLKSRC(bit8:6)位，选择 GPT1 的时钟源为 ipg_clk。设置定时器 GPT1 的工作模式</li><li>设置 GPT1 的分频值 设置寄存器 GPT1_PR 寄存器的 PRESCALAR(bit111:0)位，设置分频值</li><li>设置 GPT1 的比较值 如果要使用 GPT1 的输出比较中断，那么 GPT1 的输出比较寄存器 GPT1_OCR1 的值可以 根据所需的中断时间来设置。如不使用比较输出中断，所以将 GPT1_OCR1 设置为最大值，即：0XFFFFFFFF</li><li>使能 GPT1 定时器 设置好 GPT1 定时器以后就可以使能了，设置 GPT1_CR 的 EN(bit0)位为 1 来使能 GPT1 定时器</li><li>编写延时函数 GPT1定时器已经开始运行了，可以根据前面介绍的高精度延时函数原理来编写延时函数， 针对 us 和 ms 延时分别编写两个延时函数</li></ol><p>文件 bsp_delay.c 中一共有 5 个函数，分别为：delay_init、delayus、delayms 、delay_short 和 delay。函数 delay_init 是延时初始化函数，主要用于初始化 GPT1 定时器，设置其时钟源、分频值和输出比较寄存器值。 GPT1 的中断处理函数 gpt1_irqhandler。函数 delayus 和 delayms 就是 us 级和 ms 级的高精度延时函数，delayus 函数处理 GPT1 计数器溢出的情况。函数 delayus 只有一个参数 usdelay，这个参数就是要延时的 us 数。delayms 函数很简单，就是对 delayus(1000)的多次叠加，此函数也只有一个参数 msdelay，也就是要延时的 ms 数</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;EPIT-定时器简介&quot;&gt;&lt;a href=&quot;#EPIT-定时器简介&quot; class=&quot;headerlink&quot; title=&quot;EPIT 定时器简介&quot;&gt;&lt;/a&gt;EPIT 定时器简介</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://www.chenzhan.club/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note16.2 GPIO中断实验</title>
    <link href="https://www.chenzhan.club/2021/02/21/note16-2-GPIO%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C%E5%AE%9E%E9%AA%8C/"/>
    <id>https://www.chenzhan.club/2021/02/21/note16-2-GPIO%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-02-20T17:16:28.000Z</published>
    <updated>2021-04-12T13:29:24.390Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Cortex-A7-中断系统详解"><a href="#Cortex-A7-中断系统详解" class="headerlink" title="Cortex-A7 中断系统详解"></a>Cortex-A7 中断系统详解</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>中断向量表是一个表，这个表里面存放的是中断向量。中断服务程序的入口地址或存放中断服务程序的首地址成为中断向量，因此中断向量表是一系列中断服务程序入口地址组成的表。这些中断服务程序(函数)在中断向量表中的位置是由半导体厂商定好的，当某个中断被触发以后就会自动跳转到中断向量表中对应的中断服务程序(函数)入口地址处。中断向量表在整个程序的最前面</p><p>中断向量表都是链接到代码的最前面，比如一般 ARM 处理器都是从地址 0X00000000 开始执行指令的，那么中断向量表就是从 0X00000000 开始存放的。第一条中断向量，存放的是栈顶指针，接下来是第 2 行复位中断复位函数 Reset_Handler 的入口地址，依次类推</p><p>Cortex-A中断向量表有8个中断，其中重点关注IRQ。Cortex-A的中断向量表需要用户自己去定义</p><table><thead><tr><th>向量地址</th><th>中断类型</th><th>中断模式</th></tr></thead><tbody><tr><td>0X00</td><td>复位中断(Rest)</td><td>特权模式(SVC)</td></tr><tr><td>0X04</td><td>未定义指令中断(Undefined Instruction)</td><td>未定义指令中止模式(Undef)</td></tr><tr><td>0X08</td><td>软中断(Software Interrupt,SWI)</td><td>特权模式(SVC)</td></tr><tr><td>0X0C</td><td>指令预取中止中断(Prefetch Abort)</td><td>中止模式</td></tr><tr><td>0X10</td><td>数据访问中止中断(Data Abort)</td><td>中止模式</td></tr><tr><td>0X14</td><td>未使用(Not Used)</td><td>未使用</td></tr><tr><td>0X18</td><td>IRQ 中断(IRQ Interrupt)</td><td>外部中断模式(IRQ)</td></tr><tr><td>0X1C</td><td>FIQ 中断(FIQ Interrupt)</td><td>快速中断模式(FIQ)</td></tr></tbody></table><p>IRQ 中断， Cortex-A 内核 CPU 的所有外部中 断都属于这个 IQR 中断，当任意一个外部中断发生的时候都会触发 IRQ 中断。在 IRQ 中断服 务函数里面就可以读取指定的寄存器来判断发生的具体是什么中断，进而根据具体的中断做出相应的处理</p><ul><li>外部中断和 IRQ 中断关系</li></ul><ol><li>复位中断(Rest)，CPU 复位以后就会进入复位中断，我们可以在复位中断服务函数里面 做一些初始化工作，比如初始化 SP 指针、DDR 等等</li><li>未定义指令中断(Undefined Instruction)，如果指令不能识别的话就会产生此中断</li><li>软中断(Software Interrupt,SWI)，由 SWI 指令引起的中断，Linux 的系统调用会用 SWI 指令来引起软中断，通过软中断来陷入到内核空间</li><li>指令预取中止中断(Prefetch Abort)，预取指令的出错的时候会产生此中断</li><li>数据访问中止中断(Data Abort)，访问数据出错的时候会产生此中断</li><li>IRQ 中断(IRQ Interrupt)，外部中断，前面已经说了，芯片内部的外设中断都会引起此 中断的发生</li><li>FIQ 中断(FIQ Interrupt)，快速中断，如果需要快速处理中断的话就可以使用此中</li></ol><h3 id="中断向量偏移"><a href="#中断向量偏移" class="headerlink" title="中断向量偏移"></a>中断向量偏移</h3><p>一般ARM从0X000000000地址开始运行，对于STM32我们设置连接首地址为0X8000000</p><p>如果代码需要从0X8000000开始运行，那么需要告诉一下soc内核。也就是设置中断向量偏移。设置SCB的VTOR寄存器为新的中断向量表起始地址即可</p><h3 id="GIC-内嵌向量中断控制器"><a href="#GIC-内嵌向量中断控制器" class="headerlink" title="GIC(内嵌向量中断控制器)"></a>GIC(内嵌向量中断控制器)</h3><p>Holds the physical base address of the memory-mapped GIC registers保存内存映射的GIC寄存器的物理基址（首地址）</p><p>NVIC就是中断管理机构。使能和关闭指定的中断、设置中断优先级</p><p>GIC 接收众多的外部中断，然后对其进行处理，最终就只通过四个信号 报给 ARM 内核，这四个信号的含义如下</p><table><thead><tr><th>VFIQ</th><th>虚拟快速FIQ</th></tr></thead><tbody><tr><td>VIRQ</td><td>虚拟快速IRQ</td></tr><tr><td>FIQ</td><td>快速中断IRQ</td></tr><tr><td>IRQ</td><td>外部中断IRQ</td></tr></tbody></table><p>左侧部分就是中断源，中间部分就是 GIC 控制器，最右侧就是中断控制器向处理器内核发送中断信息，GIC 将众多的中断源分为分为三类</p><ol><li>SPI(Shared Peripheral Interrupt),共享中断，顾名思义，所有 Core 共享的中断，这个是最 常见的，那些外部中断都属于 SPI 中断(注意！不是 SPI 总线那个中断) 。比如按键中断、串口 中断等等，这些中断所有的 Core 都可以处理，不限定特定 Core</li><li>PPI(Private Peripheral Interrupt)，私有中断，我们说了 GIC 是支持多核的，每个核肯定 有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断</li><li>SGI(Software-generated Interrupt)，软件中断，由软件触发引起的中断，通过向寄存器 GICD_SGIR 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信</li></ol><h4 id="中断ID"><a href="#中断ID" class="headerlink" title="中断ID"></a>中断ID</h4><p>中断源有很多，为了区分这些不同的中断源肯定要给他们分配一个唯一 ID，这些 ID 就是 中断 ID。每一个 CPU 最多支持 1020 个中断 ID，中断 ID 号为 ID0~ID1019。这 1020 个 ID 包 含了 PPI、SPI 和 SGI</p><ul><li><p>1020 个 ID 分 配如下：</p><table><thead><tr><th>ID0~ID15</th><th>这 16 个 ID 分配给 SG</th></tr></thead><tbody><tr><td>ID16~ID31</td><td>这 16 个 ID 分配给 PPI</td></tr><tr><td>ID32~ID1019</td><td>这 988 个 ID 分配给 SPI，像 GPIO 中断、串口中断等这些外部中断</td></tr></tbody></table></li></ul><p>I.MX6U 的总共 使用了 128 个中断 ID，加上前面属于 PPI 和 SGI 的 32 个 ID，I.MX6U 的中断源共有 128+32=160 个，这 128 个中断 ID 对应的中断在《I.MX6ULL 参考手册》的“3.2 CortexA7 interrupts”小节</p><ul><li><p>部分中断源查阅自 《I.MX6ULL 参考手册》</p><table><thead><tr><th>IRQ</th><th>ID</th><th>中断源</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>32</td><td>boot</td><td>用于在启动异常的时候通知内核</td></tr><tr><td>1</td><td>33</td><td>ca7_platform</td><td>DAP中断，调试端口访问请求中断</td></tr><tr><td>2</td><td>34</td><td>sdma</td><td>SDMA中断</td></tr><tr><td>3</td><td>35</td><td>tsc</td><td>TSC(触摸)中断</td></tr><tr><td>4</td><td></td><td>snvs_lp_wrapper   snvs_hp_wrapper</td><td>SNVS中断</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>124</td><td>156</td><td>无</td><td>保留</td></tr><tr><td>125</td><td>157</td><td>无</td><td>保留</td></tr><tr><td>126</td><td>158</td><td>无</td><td>保留</td></tr><tr><td>127</td><td>159</td><td>pmu</td><td>PMU中断</td></tr></tbody></table></li></ul><h4 id="GIC-逻辑分块"><a href="#GIC-逻辑分块" class="headerlink" title="GIC 逻辑分块"></a>GIC 逻辑分块</h4><p>GIC 架构分为了两个逻辑块：Distributor 和 CPU Interface，也就是分发器端和 CPU 接口端</p><ul><li><p>Distributor(分发器端)：此逻辑块负责处理各个中断事件的分发问题，也就是中断事件应该发送到哪个 CPU Interface 上去。分发器收集所有的中断源，可以控制每个中断的优先级，它总是将优先级最高的中断事件发送到 CPU 接口端。分发器端要做的主要工作如下：</p><ol><li>全局中断使能控制</li><li>控制每一个中断的使能或者关闭</li><li>设置每个中断的优先级</li><li>设置每个中断的目标处理器列表</li><li>设置每个外部中断的触发模式：电平触发或边沿触发</li><li>设置每个中断属于组 0 还是组 1</li></ol></li><li><p>CPU Interface(CPU 接口端)：CPU 接口端是和 CPU Core 相连接的，因此每个 CPU Core 都可以在 GIC 中找到一个与之对应的 CPU Interface。CPU 接口端就是分发器和 CPU Core 之间的桥梁，CPU 接口端主要工作如下： ①、</p><ol><li>使能或者关闭发送到 CPU Core 的中断请求信号</li><li>应答中断</li><li>通知中断处理完成</li><li>设置优先级掩码，通过掩码来设置哪些中断不需要上报给 CPU Core</li><li>定义抢占策略</li><li>当多个中断到来的时候，选择优先级最高的中断通知给 CPU Core</li></ol></li></ul><p>结构体 GIC_Type 就是 GIC 控制器，列举出了 GIC 控制器的所有寄存器，可以通过结构体 GIC_Type 来访问 GIC 的所有寄存器。GIC 的分发器端相关寄存器，其相对于 GIC 基地址偏移为 0X1000，因此我们获取到 GIC 基地址以后只需要加上 0X1000 即可访问 GIC 分发器端寄存器</p><h4 id="CP15-协处理器"><a href="#CP15-协处理器" class="headerlink" title="CP15 协处理器"></a>CP15 协处理器</h4><p>CP15 协处理器一般用于存储系统管理，但是在中断中也会使用到，CP15 协处理器一共有 16 个 32 位寄存器。CP15 协处理器的访问通过如下另个指令完成：</p><table><thead><tr><th>MRC</th><th>将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中</th></tr></thead><tbody><tr><td>MCR</td><td>将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中</td></tr></tbody></table><p>MCR 指令格式如下</p><p><code>MCR&#123;cond&#125; p15,&lt; opcl &gt;,&lt; Rt &gt;,&lt; CRn &gt;,&lt; CRm &gt;,&lt; opc2 &gt;</code></p><table><thead><tr><th>cond</th><th>指令执行的条件码，如果忽略的话就表示无条件执行</th></tr></thead><tbody><tr><td>opcl</td><td>协处理器要执行的操作码</td></tr><tr><td>Rt</td><td>ARM 源寄存器，要写入到 CP15 寄存器的数据就保存在此寄存器中</td></tr><tr><td>CRn</td><td>CP15 协处理器的目标寄存器</td></tr><tr><td>CRm</td><td>协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将 CRm 设置为 C0，否则结果不可预测</td></tr><tr><td>opc2</td><td>可选的协处理器特定操作码，当不需要的时候要设置为 0</td></tr></tbody></table><p>MRC 的指令格式和 MCR 一样，只不过在 MRC 指令中 Rt 就是目标寄存器，也就是从 CP15 指定寄存器读出来的数据会保存在 Rt 中。而 CRn 就是源寄存器，也就是要读取的写处 理器寄存器。 假如我们要将 CP15 中 C0 寄存器的值读取到 R0 寄存器中，那么就可以使用如下命令：</p><p><code>MRC p15, 0, r0, c0, c0, 0</code></p><p>CP15 协处理器有 16 个 32 位寄存器，c0~c15，在使用 MRC 或者 MCR 指令访问这 16 个 寄存器的时候，指令中的 CRn、opc1、CRm 和 opc2 通过不同的搭配，其得到的寄存器含义是 不同的，来看一下 c0、c1、c12 和 c15 这四个寄存器</p><h5 id="c0-寄存器"><a href="#c0-寄存器" class="headerlink" title="c0 寄存器"></a>c0 寄存器</h5><p>当 MRC/MCR 指令中的 CRn=c0，opc1=0，CRm=c0，opc2=0 的时候就表示 此时的 c0 就是 MIDR 寄存器，也就是主 ID 寄存器，这个也是 c0 的基本作用。对于 Cortex-A7 内核来说，c0 作为 MDIR 寄存器的时候其含义如图所示：</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note16-GPIO中断实验实验\image-20210225164458052.png" alt="image-20210225164458052"></p><table><thead><tr><th>bit31:24</th><th>厂商编号，0X41，ARM</th></tr></thead><tbody><tr><td>bit23:20</td><td>内核架构的主版本号，ARM 内核版本一般使用 rnpn 来表示，比如 r0p1，其中 r0 后面的 0 就是内核架构主版本号</td></tr><tr><td>bit19:16</td><td>架构代码，0XF，ARMv7 架构</td></tr><tr><td>bit15:4</td><td>内核版本号，0XC07，Cortex-A7 MPCore 内核</td></tr><tr><td>bit3:0</td><td>内核架构的次版本号，rnpn 中的 pn，比如 r0p1 中 p1 后面的 1 就是次版本号</td></tr></tbody></table><h5 id="c1-寄存器"><a href="#c1-寄存器" class="headerlink" title="c1 寄存器"></a>c1 寄存器</h5><p>原理省略</p><p>如果要读写 SCTLR 的话，就可以使用如下命令： </p><p><code>MRC p15, 0, , c1, c0, 0 ;读取 SCTLR 寄存器，数据保存到 Rt 中</code></p><p><code>MCR p15, 0, , c1, c0, 0 ;将 Rt 中的数据写到 SCTLR(c1)寄存器中</code></p><h5 id="c12-寄存器"><a href="#c12-寄存器" class="headerlink" title="c12 寄存器"></a>c12 寄存器</h5><p>原理省略</p><p>设置 VBAR 为 0X87800000，设置命令如下：</p><p> <code>ldr r0, =0X87800000 ; r0=0X87800000</code> </p><p><code>MCR p15, 0, r0, c12, c0, 0 ;将 r0 里面的数据写入到 c12 中，即 c12=0X87800000</code></p><h5 id="c15-寄存器"><a href="#c15-寄存器" class="headerlink" title="c15 寄存器"></a>c15 寄存器</h5><p>原理省略</p><p>获取到 GIC 基地址：</p><p> <code>MRC p15, 4, r1, c15, c0, 0 ; 获取 GIC 基础地址，基地址保存在 r1 中</code></p><p>获取当前中断 ID 的代码如下： </p><p><code>MRC p15, 4, r1, c15, c0, 0 ;获取 GIC 基地址</code> </p><p><code>ADD r1, r1, #0X2000 ;GIC 基地址加 0X2000 得到 CPU 接口端寄存器起始地址</code></p><p>`LDR r0, [r1, #0XC] ;读取 CPU 接口端起始地址+0XC 处的寄存器值，也就是寄存器 GIC_IAR 的值</p><h4 id="中断使能"><a href="#中断使能" class="headerlink" title="中断使能"></a>中断使能</h4><p>中断使能包括两部分，一个是 IRQ 或者 FIQ 总中断使能，另一个就是 ID0~ID1019 这 1020 个中断源的使能</p><h5 id="IRQ-和-FIQ-总中断使能"><a href="#IRQ-和-FIQ-总中断使能" class="headerlink" title="IRQ 和 FIQ 总中断使能"></a>IRQ 和 FIQ 总中断使能</h5><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>cpsid i</td><td>禁止 IRQ 中断</td></tr><tr><td>cpsie i</td><td>使能 IRQ 中断</td></tr><tr><td>cpsid f</td><td>禁止 FIQ 中断</td></tr><tr><td>cpsie f</td><td>使能 FIQ 中断</td></tr></tbody></table><h5 id="ID0-ID1019-中断使能和禁止"><a href="#ID0-ID1019-中断使能和禁止" class="headerlink" title="ID0~ID1019 中断使能和禁止"></a>ID0~ID1019 中断使能和禁止</h5><p>GIC 寄存器 GICD_ISENABLERn 和 GICD_ ICENABLERn 用来完成外部中断的使能和禁 止，对于 Cortex-A7 内核来说中断 ID 只使用了 512 个。一个 bit 控制一个中断 ID 的使能，那么 就需要 512/32=16 个 GICD_ISENABLER 寄存器来完成中断的使能。同理，也需要 16 个 GICD_ICENABLER 寄存器来完成中断的禁止。其中 GICD_ISENABLER0 的 bit[15:0]对应 ID15<del>0 的 SGI 中断，GICD_ISENABLER0 的 bit[31:16]对应 ID31</del>16 的 PPI 中断。剩下的 GICD_ISENABLER1~GICD_ISENABLER15 就是控制 SPI 中断的</p><h4 id="中断优先级设置"><a href="#中断优先级设置" class="headerlink" title="中断优先级设置"></a>中断优先级设置</h4><h5 id="优先级数配置"><a href="#优先级数配置" class="headerlink" title="优先级数配置"></a>优先级数配置</h5><p>Cortex-A7 的中断优先级可以分为抢占优先级和子优先级，Cortex-A7 最多可以支持 256 个优先级，数字越小，优先级越高！I.MX6U 选择了 32 个优先级。在使用中断的时候需要初始化 GICC_PMR 寄存器，此寄存器用来决定使用几级优先级，寄存器结构如图 17.1.6.1 所示</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note16-GPIO中断实验实验\image-20210225171259807.png" alt="image-20210225171259807"></p><p>GICC_PMR 寄存器只有低 8 位有效，这 8 位最多可以设置 256 个优先级，其他优先级数设 置如表 17.1.6.1 所示：</p><table><thead><tr><th>bit7:0</th><th>优先级数</th></tr></thead><tbody><tr><td>11111111</td><td>256 个优先级</td></tr><tr><td>11111110</td><td>128 个优先级</td></tr><tr><td>11111100</td><td>64 个优先级</td></tr><tr><td>11111000</td><td>32 个优先级</td></tr><tr><td>11110000</td><td>16 个优先级</td></tr></tbody></table><p>I.MX6U 支持 32 个优先级，所以 GICC_PMR 要设置为 0b11111000</p><h5 id="抢占优先级和子优先级位数设置"><a href="#抢占优先级和子优先级位数设置" class="headerlink" title="抢占优先级和子优先级位数设置"></a>抢占优先级和子优先级位数设置</h5><p>抢占优先级和子优先级各占多少位是由寄存器 GICC_BPR 来决定的，GICC_BPR 寄存器结构如图</p><p><img src="/Chenzhan666.github.io/.club//Personalwebsite\blog\myBlog\source_posts\note16-GPIO中断实验实验\image-20210225171613112.png" alt="image-20210225171613112"></p><p>寄存器 GICC_BPR 只有低 3 位有效，其值不同，抢占优先级和子优先级占用的位数也不同， 配置如表如图：</p><table><thead><tr><th>Binary Point</th><th>抢占优先级域</th><th>子优先级域</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>[7:1]</td><td>[0]</td><td>7 级抢占优先级，1 级子优先级</td></tr><tr><td>1</td><td>[7:2]</td><td>[1:0]</td><td>6 级抢占优先级，2 级子优先级</td></tr><tr><td>2</td><td>[7:3]</td><td>[2:0]</td><td>5 级抢占优先级，3 级子优先级</td></tr><tr><td>3</td><td>[7:4]</td><td>[3:0]</td><td>4 级抢占优先级，4 级子优先级</td></tr><tr><td>4</td><td>[7:5]</td><td>[4:0]</td><td>3 级抢占优先级，5 级子优先级</td></tr><tr><td>5</td><td>[7:6]</td><td>[5:0]</td><td>2 级抢占优先级，6 级子优先级</td></tr><tr><td>6</td><td>[7:7]</td><td>[6:0]</td><td>1 级抢占优先级，7 级子优先级</td></tr><tr><td>7</td><td>无</td><td>[7:0]</td><td>0 级抢占优先级，8 级子优先级</td></tr></tbody></table><p>为了简单起见，一般将所有的中断优先级位都配置为抢占优先级，比如 I.MX6U 的优先级 位数为 5(32 个优先级)，所以可以设置 Binary point 为 2，表示 5 个优先级位全部为抢占优先级</p><h5 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h5><p>某个中断 ID 的中断优先级设置由寄存器 D_IPRIORITYR 来完成，前面说了 Cortex-A7 使用了 512 个中断 ID，每个中断 ID 配有一个优 先级寄存器，所以一共有 512 个 D_IPRIORITYR 寄存器。如果优先级个数为 32 (11111000)的话，使用寄存器 D_IPRIORITYR 的 bit7:4 (第四位开始是1）来设置优先级，也就是说实际的优先级要左移 3 位（把1移过去）。比如要设置 ID40 中断的优先级为 5，示例代码如下：</p><p><code>GICD_IPRIORITYR[40] = 5 &lt;&lt; 3;</code></p><h5 id="优先级设置主要有三部分："><a href="#优先级设置主要有三部分：" class="headerlink" title="优先级设置主要有三部分："></a>优先级设置主要有三部分：</h5><ol><li>设置寄存器 GICC_PMR，配置优先级个数，比如 I.MX6U 支持 32 级优先级</li><li>设置抢占优先级和子优先级位数，一般为了简单起见，会将所有的位数都设置为抢占优先级</li><li>设置指定中断 ID 的优先级，也就是设置外设优先级</li></ol><h3 id="中断服务函数"><a href="#中断服务函数" class="headerlink" title="中断服务函数"></a>中断服务函数</h3><p>10个API函数</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>GIC_Init</td><td>初始化 GIC</td></tr><tr><td>GIC_EnableIRQ</td><td>使能指定的外设中断</td></tr><tr><td>GIC_DisableIRQ</td><td>关闭指定的外设中断</td></tr><tr><td>GIC_AcknowledgeIRQ</td><td>返回中断号</td></tr><tr><td>GIC_DeactivateIRQ</td><td>无效化指定中断</td></tr><tr><td>GIC_GetRunningPriority</td><td>获取当前正在运行的中断优先级</td></tr><tr><td>GIC_SetPriorityGrouping</td><td>设置抢占优先级位数</td></tr><tr><td>GIC_GetPriorityGrouping</td><td>获取抢占优先级位数</td></tr><tr><td>GIC_SetPriority</td><td>设置指定中断的优先级</td></tr><tr><td>GIC_GetPriority</td><td>获取指定中断的优先级</td></tr></tbody></table><h3 id="修改start-S"><a href="#修改start-S" class="headerlink" title="修改start.S"></a>修改start.S</h3><p>添加中断向量表，编写复位中断服务函数和IRQ中断服务函数。</p><p>编写复位中断服务函数，内容如下：</p><ol><li>关闭I,D Cache和MMU</li><li>设置处理器9中工作模式下对应的SP指针。要使用中断那么必须设置IRQ模式下的SP指针。索性直接设置所有模式下的SP指针</li><li>清除bss段</li><li>跳到C函数，也就是main函数</li></ol><h3 id="CP15协处理器"><a href="#CP15协处理器" class="headerlink" title="CP15协处理器"></a>CP15协处理器</h3><p>MRC: 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。</p><p>MRC 就是读 CP15 寄存器， MCR 就是写 CP15 寄存器， MCR 指令格式如下：</p><p>MCR{cond} p15, <opc1>, <Rt>, <CRn>, <CRm>, <opc2></opc2></CRm></CRn></Rt></opc1></p><p>MRC p15, 0, r0, c0,c0,0</p><p>现在要关闭I,D ache和MMU，打开Cortex-A7参考手册到105页，找到SCTLR寄存器。也就是系统控制寄存器，此寄存器bit0用于打开和关闭MMU，bit1控制对齐，bit2控制D Cache的打开和关闭。Bit11用于控制分支预测。Bit12用于控制I Cache。</p><p><strong>中断向量偏移设置</strong></p><p>将新的中断向量表首地址写入到CP15协处理器的VBAR寄存器。</p><p>MCR{cond} p15, <opc1>, <Rt>, <CRn>, <CRm>, <opc2></opc2></CRm></CRn></Rt></opc1></p><p>MRC p15,0,r0,c12,c0,0  </p><p>MCR p15,0,r0,c12,c0,0</p><p> <strong>IRQ中断服务函数</strong></p><p>mrc p15, 4, r1, c15, c0, 0  读取CP15的CBAR寄存器。CBAR寄存器保存了GIC控制器的寄存器组首地址。GIC寄存器组偏移0x1000<del>0x1fff为GIC的分发器。0x2000</del>0x3fff为CPU接口端。意味我们可以访问GIC控制器了！</p><p>代码中，R1寄存器吧保存着GIC控制器的CPU接口端基地址。读取CPU接口段的GICC_IAR寄存器的值保存到R0寄存器里面。可以从GICC_IAR的bit9~0读取中断ID，我们读取中断ID的目的就是为了得到对应的中断处理函数</p><p>system_irqhandler就是具体的中断处理函数，此函数有一个参数，为GICC_IAR寄存器的值</p><p>system_irqhandler处理完具体的中断以后，需要将对应的中断ID值写入到GICC_EOIR寄存器里面</p><p>ARM 的指令是三级流水线：取指、译指、执 行，pc 指向的是正在取值的地址，这就是很多书上说的 pc=当前执行指令地址+8</p><p><code>0X2000 MOV R1, R0 ;</code></p><p><code>执行 0X2004 MOV R2, R3 ;</code></p><p><code>译指 0X2008 MOV R4, R5 ;取值 PC</code></p><hr><p>参考资料：</p><p>正点原子【第二期】手把手教你学Linux之ARM（MX6U）裸机篇-GPIO中断实验</p><p>正点原子 I.MX6U 嵌入式Linux驱动开发指南 第十七章</p><p>《Cortex-A7 Technical ReferenceManua.pdf》</p><p>《ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Cortex-A7-中断系统详解&quot;&gt;&lt;a href=&quot;#Cortex-A7-中断系统详解&quot; class=&quot;headerlink&quot; title=&quot;Cortex-A7 中断系统</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://www.chenzhan.club/tags/ARM-MX6U/"/>
    
  </entry>
  
</feed>
