<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHENZHAN</title>
  
  <subtitle>CHENZHAN</subtitle>
  <link href="https://chenzhan666.coding.me/atom.xml" rel="self"/>
  
  <link href="https://chenzhan666.coding.me/"/>
  <updated>2021-03-05T16:30:07.114Z</updated>
  <id>https://chenzhan666.coding.me/</id>
  
  <author>
    <name>Chenzhan666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>note25-LCD背光调节</title>
    <link href="https://chenzhan666.coding.me/2021/03/05/note25-LCD%E8%83%8C%E5%85%89%E8%B0%83%E8%8A%82/"/>
    <id>https://chenzhan666.coding.me/2021/03/05/note25-LCD%E8%83%8C%E5%85%89%E8%B0%83%E8%8A%82/</id>
    <published>2021-03-05T14:40:09.000Z</published>
    <updated>2021-03-05T16:30:07.114Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="LCD-背光调节简介"><a href="#LCD-背光调节简介" class="headerlink" title="LCD 背光调节简介"></a>LCD 背光调节简介</h1><p>给背光控制引脚输入高电平就会点亮背光，输入低电平就会关闭背光。不断的打开和关闭背光，当速度足够快的时候 就不会感觉到背光关闭这个过程了。这个正好可以使用 PWM 来完成，PWM 全称是 PulseWidth Modulation，也就是脉冲宽度调制</p><p>PWM 信号有两个关键的术语：频率和占空比，频率就是开关速度，把一次开关算作一个周期，那么频率就是 1 秒内进行了多少次开关。占空比就是一个周期内高电平时间和低电平时间的比例，一个周期内高电平时间越长占空比就越大，反之占空比就越小。占空比用百分之表示， 如果一个周期内全是低电平那么占空比就是 0%，如果一个周期内全是高电平那么占空比就是 100%。 我们给 LCD 的背光引脚输入一个 PWM 信号，这样就可以通过调整占空比的方式来调整 LCD 背光亮度了。提高占空比就会提高背光亮度，降低占空比就会降低背光亮度。重点就在于 PWM 信号的产生和占空比的控制，I.MX6U 提供了 PWM 外设，可以配置 PWM 外设来产生 PWM 信号。 打开《I.MX6ULL 参考手册》的第 40 章“Chapter 40 Pulse Width Modulation(PWM)”，I.MX6U 一共有 8 路 PWM 信号，每个 PWM 包含一个 16 位的计数器和一个 4 x 16 的数据 FIFO，I.MX6U 的 PWM 外设结构如图 29.1.2 所示：</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note23-SPI实验\image-20210305225558314.png" alt="image-20210305225558314"></p><p>图中的各部分功能如下： ①、</p><ol><li>此部分是一个选择器，用于选择 PWM 信号的时钟源，一共有三种时钟源：ipg_clk、 ipg_clk_highfreq 和 ipg_clk_32k</li><li>是一个 12 位的分频器，可以对①中选择的时钟源进行分频</li><li>是 PWM 的 16 位计数器寄存器，保存着 PWM 的计数值</li><li>是 PWM 的 16 位周期寄存器，此寄存器用来控制 PWM 的频率</li><li>是 PWM 的 16 位采样寄存器，此寄存器用来控制 PWM 的占空比</li><li>此部分是 PWM 的中断信号，PWM 是提供中断功能的，如果使能了相应的中断的话就会产生中断</li><li>此部分是 PWM 对应的输出 IO，产生的 PWM 信号就会从对应的 IO 中输出，I.MX6UALPHA 开发板的 LCD 背光控制引脚连接在 I.MX6U 的 GPIO1_IO8 上，GPIO1_IO8 可以复用为 PWM1_OUT</li></ol><p>可以通过配置相应的寄存器来设置 PWM 信号的频率和占空比，PWM 的 16 位计数器是个向上计数器，此计数器会从 0X0000 开始计数，直到计数值等于寄存器 PWMx_PWMPR(x=1~8) + 1，然后计数器就会重新从 0X0000 开始计数，如此往复。所以寄存器 PWMx_PWMPR 可以设置 PWM 的频率</p><p>在一个周期内，PWM 从 0X0000 开始计数的时候，PWM 引脚先输出高电平(默认情况下， 可以通过配置输出低电平)。采样 FIFO 中保存的采样值会在每个时钟和计数器值进行比较，当采样值和计数器相等的话 PWM 引脚就会改为输出低电平(默认情况下，同样可以通过配置输出高电平)。计数器会持续计数，直到和周期寄存器 PWMx_PWMPR(x=1~8) + 1 的值相等，这样一个周期就完成了。所以，采样 FIFO 控制着占空比，而采样 FIFO 里面的值来源于采样寄存器 PWMx_PWMSAR，因此相当于 PWMx_PWMSAR 控制着占空比。至此，PWM 信号的频率和占空比设置我们就知道该如何去做了</p><p>PWM 开启以后会按照默认值运行，并产生 PWM 波形，而这个默认的 PWM 一般并不是我们需要的波形。如果这个 PWM 波形控制着设备的话就会导致设备因为接收到错误的 PWM 信号而运行错误，严重情况下可能会损坏设备，甚至人身安全。因此，在开启 PWM 之前最好设置好 PWMx_PWMPR 和 PWMx_PWMSAR 这两个寄存器，也就是设置好 PWM 的频率和占空 比</p><p>当向 PWMx_PWMSAR 寄存器写入采样值的时候，如果 FIFO 没满的话其值会被存储到 FIFO 中。如果 FIFO 满的时候写入采样值就会导致寄存器 PWMx_PWMSR 的位 FWE(bit6)置 1，表示 FIFO 写错误，FIFO 里面的值也并不会改变。FIFO 可以在任何时候写入，但是只有在 PWM 使能的情况下读取。寄存器 PWMx_SR 的位 FIFOAV(bit2:0)记录着当前 FIFO 中有多少个数据。从采样寄存器 PWMx_PWMSAR 读取一次数据，FIFO 里面的数据就会减一，每产生一个周期的 PWM 信号，FIFO 里面的数据就会减一，相当于被用掉了。PWM 有个 FIFO 空中断，当 FIFO 为空的时候就会触发此中断，可以在此中断处理函数中向 FIFO 写入数据</p><h2 id="PWM-几个寄存器"><a href="#PWM-几个寄存器" class="headerlink" title="PWM 几个寄存器"></a>PWM 几个寄存器</h2><ul><li>PWM1_PWMCR</li><li>PWM1_PWMIR 寄存器，这个是 PWM 的中断控制寄存器</li><li>状态寄存器 PWM1_PWMSR</li><li>PWM1_PWMPR 寄存器，PWM 周期寄存器</li></ul><p>PWM 的频率计算公式如下： </p><p>PWMO(Hz) = PCLK(Hz) / (PERIOD + 2) </p><p>其中 PCLK 是最终进入 PWM 的时钟频率，假如 PCLK 的频率为 1MHz，现在我们要产生 一个频率为 1KHz 的 PWM 信号，那么就可以设置 PERIOD = 1000000 / 1000 – 2 = 998</p><ul><li> PWM1_PWMSAR，这是采样寄存器，用于设置占空比</li></ul><p>通过这个采样值即可调整占空比，当计数器的值小于 SAMPLE 的时候输出高电平(或低电平)。当计数器值大于等于 SAMPLE，小于寄存器 PWM1_PWMPR 的 PERIO 的时候输出低电平(或高电平)。同样假如我们要设置 PWM 信号的占空比为 50%，那么就可以将 SAMPLE 设置为(PERIOD + 2) / 2 = 1000 / 2=500</p><h2 id="PWM1-的输出引脚为-GPIO1-IO8，配置步骤如下："><a href="#PWM1-的输出引脚为-GPIO1-IO8，配置步骤如下：" class="headerlink" title="PWM1 的输出引脚为 GPIO1_IO8，配置步骤如下："></a>PWM1 的输出引脚为 GPIO1_IO8，配置步骤如下：</h2><ol><li>配置引脚 GPIO1_IO8 配置 GPIO1_IO08 的复用功能，将其复用为 PWM1_OUT 信号线</li><li>初始化 PWM1 初始化 PWM1，配置所需的 PWM 信号的频率和默认占空比</li><li>设置中断 因为 FIFO 中的采样值每个周期都会少一个，所以需要不断的向 FIFO 中写入采样值，防止其为空。我们可以使能 FIFO 空中断，这样当 FIFO 为空的时候就会触发相应的中断，然后在中断处理函数中向 FIFO 写入采样值</li><li>使能 PWM1 配置好 PWM1 以后就可以开启了。</li></ol><h1 id="实验程序"><a href="#实验程序" class="headerlink" title="实验程序"></a>实验程序</h1><p>文件 bsp_blacklight.c 一共有 6 个函数，pwm1_irqhandler，是 PWM1 的中断处理函数。需要在此函数中处理 FIFO 空中断，当 FIFO 空中断发生以后需要向采样寄存器 PWM1_PWMSAR 写入采样数据，也就是占空比值，最后要清除相应的中断标志位。backlight_init，是背光初始化函数，在此函数里面会初始化背光引脚 GPIO1_IO08，将其复用为 PWM1_OUT。然后此函数初始化 PWM1，设置要产生的 PWM 信号频率和默认占空 比，接下来使能 FIFO 空中断，注册相应的中断处理函数，最后使能 PWM1。pwm1_enable，用于使能 PWM1。pwm1_setsample_value，用于设置采样值，也就是寄存器 PWM1_PWMSAR 的值。pwm1_setperiod_value，用于设置 PWM 信号的频率。pwm1_setduty，用于设置 PWM 的占空比，这个函数只有一个参数 duty， 也就是占空比值，单位为%，函数内部会根据百分值计算出寄存器 PWM1_PWMSAR 应该设置的值</p><p>调用函数 backlight_init 初始化屏幕背光 PWM。设置背光 PWM 默认占空比为 10%。在 main 函数中读取按键值，如果 KEY0 按下的话就将 PWM 信号的占空比增加 10%，当占空比超过 100%的时候就重回到 10%，重新开始</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;LCD-背光调节简介&quot;&gt;&lt;a href=&quot;#LCD-背光调节简介&quot; class=&quot;headerlink&quot; title=&quot;LCD 背光调节简介&quot;&gt;&lt;/a&gt;LCD 背光调节简介</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note24-多点电容触摸屏</title>
    <link href="https://chenzhan666.coding.me/2021/03/05/note24-%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F/"/>
    <id>https://chenzhan666.coding.me/2021/03/05/note24-%E5%A4%9A%E7%82%B9%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F/</id>
    <published>2021-03-05T12:47:55.000Z</published>
    <updated>2021-03-05T16:29:06.690Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="多点电容触摸简介"><a href="#多点电容触摸简介" class="headerlink" title="多点电容触摸简介"></a>多点电容触摸简介</h1><p>电阻触摸屏，电阻触摸屏只能单点触摸，和电阻触摸屏相比，电容触摸屏最大的优点是支持多点触摸，电容屏只需要手指轻触即可，而电阻屏是需要手指 给予一定的压力才有反应，而且电容屏不需要校准。如今多点电容触摸屏已经得到了广泛的应用，如果要做人机交互设备的开发，多点电容触摸屏基本是不可能绕过去的。我们来学习一下如何使用多点触摸屏，如何获取到多点触摸值。 如何得到其多点触摸坐标值即可。ALIENTEK 的三款 RGB LCD 屏幕都是支持 5 点电容触摸屏的，以 ATK-7016 这款屏幕来讲解如何使用多点电容触摸屏</p><p>ATK-7016 这款屏幕其实是由 TFT LCD+触摸屏组合起来的。底下是 LCD 面板，上面是触摸面板，将两个封装到一起就成了带有触摸屏的 LCD 屏幕。电容触摸屏也是需要一个驱动 IC 的，驱动 IC 一般会提供一个 I2C 接口给主控制器，主控制器可以通过 I2C 接口来读取驱动 IC 里面的触摸坐标数据。ATK-7016、ATK-7084 这两款屏幕使用的触摸控制 IC 是 FT5426，ATK4342 使用的驱动 IC 是 GT9147。这三个电容屏触摸 IC 都是 I2C 接口的，使用方法基本一样。 FT5426 这款驱动 IC 采用 15*28 的驱动结构，也就是 15 个感应通道，28 个驱动通道，最 多支持 5 点电容触摸。ATK-7016 的电容触摸屏部分有 4 个 IO 用于连接主控制器：SCL、SDA、 RST 和 INT，SCL 和 SDA 是 I2C 引脚，RST 是复位引脚，INT 是中断引脚。一般通过 INT 引 脚来通知主控制器有触摸点按下，然后在 INT 中断服务函数中读取触摸数据。也可以不使用中断功能，采用轮询的方式不断查询是否有触摸点按下，我们使用中断方式来获取触摸数据</p><p>根所有的 I2C 器件一样，FT5426 也是通过读写寄存器来完成初始化和触摸坐标数据读取的，主要工作就是读写 FT5426 的寄存器。FT5426 的 I2C 设备地址为 0X38，FT5426 的寄存器有多</p><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a>实验程序编写</h1><p>文件 bsp_ft5xx6.c 中有 7 个函数，函数 ft5426_init， 此函数是 ft5426 的初始化函数，此函数先初始化 FT5426 所使用的 I2C2 接口引脚、复位引脚和中断引脚。接下来使能了 FT5426 所使用的中断，并且注册了中断处理函数，最后初始化了 I2C2 和 FT5426。 gpio1_io9_irqhandler，这个是 FT5426 的中断引脚中断处理函数，在 此函数中会读取 FT5426 内部的触摸数据。 ft5426_write_byte 和 ft5426_read_byte，函数 ft5426_write_byte 用于向 FT5426 的寄存器写入指定的值，函数 ft5426_read_byte 用于读取 FT5426 指定寄存器的值。 ft5426_read_len，此函数也 是从 FT5426 的指定寄存器读取数据，但是此函数是读取数个连续的寄存器。ft5426_read_tpnum，此函数用于获取 FT5426 当前有几个触摸点有效，也就是触摸点个数。 ft5426_read_tpcoord，此函数就是读取 FT5426 各个触摸点坐标值的</p><p>文件 main.c 调用函数 ft5426_init 初始化触摸屏，也就是 FT5426 这个触摸驱动 IC。最后在 main 函数的 while 循环中不断的显示获取到的触摸点数以及对应的触摸坐标值。因为采用中断方式读取 FT5426 的触摸数据，因此 main 函数中并没有读取 FT5426 的操作，只是显示触摸值</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;多点电容触摸简介&quot;&gt;&lt;a href=&quot;#多点电容触摸简介&quot; class=&quot;headerlink&quot; title=&quot;多点电容触摸简介&quot;&gt;&lt;/a&gt;多点电容触摸简介&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note23-SPI实验</title>
    <link href="https://chenzhan666.coding.me/2021/03/03/note23-SPI%E5%AE%9E%E9%AA%8C/"/>
    <id>https://chenzhan666.coding.me/2021/03/03/note23-SPI%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-03-03T13:08:21.000Z</published>
    <updated>2021-03-05T16:27:49.659Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="SPI-实验"><a href="#SPI-实验" class="headerlink" title="SPI 实验"></a>SPI 实验</h1><p>同 I2C 一样，SPI 是很常用的通信接口，也可以通过 SPI 来连接众多的传感器。相比 I2C 接 口，SPI 接口的通信速度很快，I2C 最多 400KHz，但是 SPI 可以到达几十 MHz。I.MX6U 也有 4 个 SPI 接口，可以通过这 4 个 SPI 接口来连接一些 I2C 外设。I.MX6U-ALPHA 使用 SPI3 接口连接了一个六轴传感器 ICM-20608，学习如何使用 I.MX6U 的 SPI 接口来驱动 ICM-20608，读取 ICM-20608 的六轴数据</p><h3 id="SPI-amp-ICM-20608-简介"><a href="#SPI-amp-ICM-20608-简介" class="headerlink" title="SPI &amp; ICM-20608 简介"></a>SPI &amp; ICM-20608 简介</h3><h3 id="SPI-简介"><a href="#SPI-简介" class="headerlink" title="SPI 简介"></a>SPI 简介</h3><p>I2C 是串行通信的一种，只需要两根线就可以完成主机和从机之间的通信，但是 I2C 的速度最高只能到 400KHz</p><p>SPI，SPI 全称是 Serial Perripheral Interface，也就是串行外围设备接口。SPI 是一种同步串行接口技术，是一种高速、全双工的同步通信总线，SPI 时钟频率相比 I2C 要高很多，最高可以工作在上百 MHz。SPI 以主从方式工作，通常是有一个主设备和一个或多个从设备，一般 SPI 需要 4 根线，但是也可以使用三根线(单向传输)</p><p>标准的 4 线 SPI，这四根线如下： </p><ol><li>CS/SS，Slave Select/Chip Select，这个是片选信号线，用于选择需要进行通信的从设备。 I2C 主机是通过发送从机设备地址来选择需要进行通信的从机设备的，SPI 主机不需要发送从机设备，直接将相应的从机设备片选信号拉低即可</li><li>SCK，Serial Clock，串行时钟，和 I2C 的 SCL 一样，为 SPI 通信提供时钟</li><li>MOSI/SDO，Master Out Slave In/Serial Data Output，简称主出从入信号线，这根数据线只能用于主机向从机发送数据，也就是主机输出，从机输入</li><li>MISO/SDI，Master In Slave Out/Serial Data Input，简称主入从出信号线，这根数据线只能用户从机向主机发送数据，也就是主机输入，从机输出</li></ol><p>SPI 通信都是由主机发起的，主机需要提供通信的时钟信号</p><p>SPI 有四种工作模式，通过串行时钟极性(CPOL)和相位(CPHA)的搭配来得到四种工作模式：</p><ol><li>CPOL=0，串行时钟空闲状态为低电平</li><li>CPOL=1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具体的传输协议</li><li>CPHA=0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据</li><li>CPHA=1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据</li></ol><p><img src="/Personalwebsite/blog/myBlog/.me//source_posts%5Cnote23-SPI%E5%AE%9E%E9%AA%8C%5Cimage-20210305193457567.png" alt="image-20210305193457567"></p><p>从SPI 的时序图可以看出，因为SPI 是全双工的，不像 I2C 那样要分为读时序和写时序，所以读写时序可以一起完成。时序图中，CS 片选信号先拉低，选中要通信的从设备，然后通过 MOSI 和 MISO 这两根数据线进行收发数据，MOSI 数据线发出了 0XD2 这个数据给从设备，同时从设备也通过 MISO 线给主设备返回了 0X66 这个数据</p><h3 id="I-MX6U-ECSPI-简介"><a href="#I-MX6U-ECSPI-简介" class="headerlink" title="I.MX6U ECSPI 简介"></a>I.MX6U ECSPI 简介</h3><p>I.MX6U 自带的 SPI 外设叫做 ECSPI，全称是 Enhanced Configurable Serial Peripheral Interface， 就是 SPI。ECSPI 有 64 * 32 个接收 FIFO(RXFIFO)和 64 * 32 个发送 FIFO(TXFIFO)，ECSPI 特性如下：</p><ol><li>全双工同步串行接口</li><li>可配置的主/从模式</li><li>四个片选信号，支持多从机</li><li>发送和接收都有一个 32x64 的 FIFO</li><li>片选信号 SS/CS，时钟信号 SCLK 极性可配置</li><li>支持 DMA</li></ol><p>I.MX6U 的 ECSPI 可以工作在主模式或从模式，I.MX6U 有 4 个 ECSPI，每个 ECSPI 支持四个片选信号，如果要使用 ECSPI 的硬件片选信号， 一个 ECSPI 可以支持 4 个外设。如果不使用硬件的片选信号就可以支持无数个外设，硬件片选信号只能使用指定的片选 IO，软件片选可以使用任意的 IO</p><h4 id="ECSPI-的重要的寄存器"><a href="#ECSPI-的重要的寄存器" class="headerlink" title="ECSPI 的重要的寄存器"></a>ECSPI 的重要的寄存器</h4><ul><li>ECSPIx_CONREG(x=1~4)寄存器，是 ECSPI 的控制寄存器</li><li>寄存器 ECSPIx_CONFIGREG，是 ECSPI 的配置寄存器</li><li>寄存器 ECSPIx_PERIODREG，是 ECSPI 的采样周期寄存器</li><li>寄存器 ECSPIx_STATREG</li><li>两个数据寄存器，ECSPIx_TXDATA 和 ECSPIx_RXDATA，这两个寄存器都是 32 位的，如果要发送数据就向寄存器 ECSPIx_TXDATA 写入数据，读取及存取 ECSPIx_RXDATA 里面的数据就可以得到刚刚接收到的数据</li></ul><h3 id="ICM-20608-简介"><a href="#ICM-20608-简介" class="headerlink" title="ICM-20608 简介"></a>ICM-20608 简介</h3><p>ICM-20608 是 InvenSense 出品的一款 6 轴 MEMS 传感器，包括 3 轴加速度和 3 轴陀螺仪。 ICM-20608 采用 16P 的 LGA 封装, 内部有一个 512 字节的 FIFO。陀螺仪的量程范围可以编程设置，可选择±250，±500，±1000 和±2000°/s， 加速度的量程范围也可以编程设置，可选择±2g，±4g，±4g，±8g 和±16g。陀螺仪和加速度计都是 16 位的 ADC，并且支持 I2C 和 SPI 两种协议，使用 I2C 接口的话通信速度最高可以达到 400KHz，使用 SPI 接口的话通信速度最高可达到 8MHz。ICM-20608 特性如下：</p><ol><li>陀螺仪支持 X,Y 和 Z 三轴输出，内部集成 16 位 ADC，测量范围可设置：±250，± 500，±1000 和±2000°/s</li><li>加速度计支持 X,Y 和 Z 轴输出，内部集成 16 位 ADC，测量范围可设置：±2g，±4g， ±4g，±8g 和±16g</li><li>用户可编程中断</li><li>内部包含 512 字节的 FIFO</li><li>内部包含一个数字温度传感器</li><li>耐 10000g 的冲击</li><li>支持快速 I2C，速度可达 400KHz</li><li>支持 SPI，速度可达 8MH</li></ol><p>使用 IIC 接口 ICM-20608 的 AD0 引脚决定 I2C 设备从地址的最后一位，如果 AD0 为 0 的话 ICM-20608 从设备地址是 0X68，如果 AD0 为 1 的话 ICM-20608 从设备地址为 0X69。使用 SPI 接口，ICM-20608 也是通过读写寄存器来配置和读取传感器数据，使用 SPI 接口读写寄存器需要 16 个时钟或者更多(如果读写操作包括多个字节的话)，第一个字节包含要读写的寄存器地址，寄存器地址最高位是读写标志位，如果是读的话寄存器地址最高位要为 1，如果是写的话寄存器地址最高位要为 0，剩下的 7 位才是实际的寄存器地址，寄存器地址后面跟着的就是读写的数据。关于 ICM-20608 的详细寄存器和位的介绍参考 ICM-20608 的寄存器手册</p><h2 id="实验程序"><a href="#实验程序" class="headerlink" title="实验程序"></a>实验程序</h2><p>文件 bsp_spi.c 中有两个函数：spi_init 和 spich0_readwrite_byte，函数 spi_init 是 SPI 初始化函数，此函数会初始化 SPI 的时钟，通道等。函数 spich0_readwrite_byte 是 SPI 收发函数， 通过此函数即可完成 SPI 的全双工数据收发</p><p>文件 bsp_icm20608.h 里面先定义了一个宏 ICM20608_CSN，这个是 ICM20608 的 SPI 片选引脚。接下来定义了一些 ICM20608 的 ID 和寄存器地址。定义了一个结构体 icm20608_dev_struc，这个结构体是 ICM20608 的设备结构体，里面的成员变量用来保存 ICM20608 的原始数据值和经过转换得到的实际值。实际值是有小数的</p><p>文件 bsp_imc20608.c 是 ICM20608 的驱动文件，里面有 7 个函数， icm20608_init，这个是 ICM20608 的初始化函数，此函数先初始化 ICM20608 所使用的 SPI 引脚，将其复用为 ECSPI3。因为我们的 SPI 片选采用软件控制的方式，所以 SPI 片选引脚设置成了普通的输出模式。设置完 SPI 所使用的引脚以后就是调用函数 spi_init 来初 始化 SPI3，最后初始化 ICM20608，就是配置 ICM20608 的寄存器。接下来函数分别是 icm20608_write_reg 和 icm20608_read_reg，这两个函数分别用于写/读 ICM20608 的指定寄存器。 icm20608_read_len，此函数也是读取 ICM20608 的寄存器值，但是此函数可 以读取连续多个寄存器的值，一般用于读取 ICM20608 传感器数据。 icm20608_gyro_scaleget 和 icm20608_accel_scaleget，这两个函数分别用于获取陀螺仪和加速度 计的分辨率，因为陀螺仪和加速度的测量范围设置的不同，其分辨率就不同，所以在计算实际值的时候要根据实际的量程范围来得到对应的分辨率。最后是 icm20608_getdata，此函数用于获取 ICM20608 的加速度计、陀螺仪和温度计的数据，并且会根据设置的测量范围计算出实际的值，比如加速度的 g 值、陀螺仪的角速度值和温度计的温度值</p><p>文件 main.c 一开始有两个函数 integer_display 和 decimals_display，这两个函数用于在 LCD 上显示获取到的 ICM20608 数据值，函数 integer_display 用于显示原始数据值，也就是整数值。 函数 decimals_display 用于显示实际值，实际值扩大了 100 倍，此函数会提取出实际值的整数部分和小数部分并显示在 LCD 上。另一个重要的函数是 imx6ul_hardfpu_enable，这个函数用于开启 I.MX6U 的 NEON 和硬件 FPU(浮点运算单元)，因为使用到了浮点运算，而 I.MX6U 的 Cortex-A7 是支持 NEON 和 FPU(VFPV4_D32)的，但是在使用 I.MX6U 的硬件 FPU 之前是先要开启的。 调用了函数 icm20608_init 来初始化 ICM20608，如果初始化失败的话就会在 LCD 上闪烁提示语句。最后在 main 函数的 while 循环中不断的调用函数 icm20608_getdata 获取 ICM20608 的传感器数据，并且显示在 LCD 上</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;SPI-实验&quot;&gt;&lt;a href=&quot;#SPI-实验&quot; class=&quot;headerlink&quot; title=&quot;SPI 实验&quot;&gt;&lt;/a&gt;SPI 实验&lt;/h1&gt;&lt;p&gt;同 I2C 一样</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note22-I2C实验</title>
    <link href="https://chenzhan666.coding.me/2021/03/02/note22-I2C%E5%AE%9E%E9%AA%8C/"/>
    <id>https://chenzhan666.coding.me/2021/03/02/note22-I2C%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-03-01T16:40:54.000Z</published>
    <updated>2021-03-05T16:25:55.030Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="I2C-amp-AP3216C-简介"><a href="#I2C-amp-AP3216C-简介" class="headerlink" title="I2C &amp; AP3216C 简介"></a>I2C &amp; AP3216C 简介</h1><h2 id="I2C-简介"><a href="#I2C-简介" class="headerlink" title="I2C 简介"></a>I2C 简介</h2><p>I2C 是一种总线协议，是 NXP 公司设计的，I2C 使用两条线在主控制器和从机之间进行数据通信。一条是 SCL(串行时钟线)，另外一条是 SDA(串行数据线)，这两条数据线需要接上拉电阻，总线空闲的时候 SCL 和 SDA 处于高电平。I2C 总线标准模式下速度可以 达到 100Kb/S，快速模式下可以达到 400Kb/S。I2C 总线工作是按照一定的协议来运行的，接下来就看一下 I2C 协议。 I2C 是支持多从机的，也就是一个 I2C 控制器下可以挂多个 I2C 从设备，这些不同的 I2C 从设备有不同的器件地址，这样 I2C 主控制器就可以通过 I2C 设备的器件地址访问指定的 I2C 设备</p><p>SDA 和 SCL 这两根线必须要接一个上拉电阻，一般是 4.7K。其余的 I2C 从器件都挂接到 SDA 和 SCL 这两根线上，这样就可以通过 SDA 和 SCL 这两根线来访问多个 I2C 设备</p><p>I2C协议术语</p><p><strong>起始位</strong> 就是 I2C 通信起始标志，通过这个起始位就可以告诉 I2C 从机，将开始进行 I2C 通信。在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位</p><p><strong>停止位</strong> 停止位就是停止 I2C 通信的标志位，和起始位的功能相反。在 SCL 位高电平的时候，SDA 出现上升沿就表示为停止位</p><p><strong>数据传输</strong> I2C 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，因此 SDA 上 的数据变化只能在 SCL 低电平期间发生</p><p><strong>应答信号</strong> 当 I2C 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 I2C 从机应答，也就是 等到 I2C 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败</p><p><strong>I2C 写时序</strong> 主机通过 I2C 总线与从机之间进行通信不外乎两个操作：写和读</p><p>写时序的具体步骤：</p><ol><li>开始信号</li><li>发送 I2C 设备地址，每个 I2C 器件都有一个设备地址，通过发送具体的设备地址来决定访问哪个 I2C 器件。这是一个 8 位的数据，其中高 7 位是设备地址，最后 1 位是读写位，为 1 的话表示这是一个读操作，为 0 的话表示这是一个写操作</li><li>I2C 器件地址后面跟着一个读写位，为 0 表示写操作，为 1 表示读操作</li><li>从机发送的 ACK 应答信号</li><li>重新发送开始信号</li><li>发送要写写入数据的寄存器地址</li><li>从机发送的 ACK 应答信号</li><li>发送要写入寄存器的数据</li><li>从机发送的 ACK 应答信号</li><li>停止信号</li></ol><p><strong>I2C 读时序</strong></p><p>I2C 单字节读时序比写时序要复杂一点，读时序分为 4 大步，第一步是发送设备地址，第二步是发送要读取的寄存器地址，第三步重新发送设备地址，最后一步就是 I2C 从器件输出要读取的寄存器值：</p><ol><li>主机发送起始信号</li><li>主机发送要读取的 I2C 从设备地址</li><li>读写控制位，因为是向 I2C 从设备发送数据，因此是写信号</li><li>从机发送的 ACK 应答信号</li><li>重新发送 START 信号</li><li>主机发送要读取的寄存器地址</li><li>从机发送的 ACK 应答信号</li><li>重新发送 START 信号</li><li>重新发送要读取的 I2C 从设备地址</li><li>读写控制位，这里是读信号，表示接下来是从 I2C 从设备里面读取数据</li><li>从机发送的 ACK 应答信号</li><li>从 I2C 器件里面读取到的数据</li><li>主机发出 NO ACK 信号，表示读取完成，不需要从机再发送 ACK 信号了</li><li>主机发出 STOP 信号，停止 I2C 通信</li></ol><p><strong>I2C 多字节读写时序</strong></p><p>有时候我们需要读写多个字节，多字节读写时序和单字节的基本一致，只是在读写数据的时候可以连续发送多个自己的数据，其他的控制时序都是和单字节一样的</p><h2 id="I-MX6U-I2C-简介"><a href="#I-MX6U-I2C-简介" class="headerlink" title="I.MX6U I2C 简介"></a>I.MX6U I2C 简介</h2><p>I.MX6U 提供了 4 个 I2C 外设，通过这四个 I2C 外设即可完成与 I2C 从器件进行通信， I.MX6U 的 I2C 外设特性如下：</p><ol><li>与标准 I2C 总线兼容</li><li>多主机运行 </li><li>软件可编程的 64 中不同的串行时钟序列</li><li>软件可选择的应答位</li><li>开始/结束信号生成和检测</li><li>重复开始信号生成</li><li>确认位生成</li><li>总线忙检测</li></ol><p>I.MX6U 的 I2C 支持两种模式：标准模式和快速模式，标准模式下 I2C 数据传输速率最高是 100Kbits/s，在快速模式下数据传输速率最高为 400Kbits/s</p><p>I2C 的几个重要的寄存器</p><ul><li>I2Cx_IADR(x=1~4)寄存器，这是 I2C 的地址寄存器，寄存器 I2Cx_IADR 只有 ADR(bit7:1)位有效，用来保存 I2C 从设备地址数据。当我们要访问某个 I2C 从设备的时候就需要将其设备地址写入到 ADR 里面</li><li>寄存器 I2Cx_IFDR，这个是 I2C 的分频寄存器，寄存器 I2Cx_IFDR 也只有 IC(bit5:0)这个位，用来设置 I2C 的波特率，I2C 的时钟源可以选 择 IPG_CLK_ROOT=66MHz，通过设置 IC 位既可以得到想要的 I2C 波特率</li><li>寄存器 I2Cx_I2CR，这个是 I2C 控制寄存器</li><li>寄存器就是 I2Cx_I2DR，这是 I2C 的数据寄存器，此寄存器只有低 8 位有效，当 要发送数据的时候将要发送的数据写入到此寄存器，如果要接收数据的话直接读取此寄存器即 可得到接收到的数据</li></ul><h2 id="AP3216C-简介"><a href="#AP3216C-简介" class="headerlink" title="AP3216C 简介"></a>AP3216C 简介</h2><p>通过 I2C1 连接了一个三合一环境传感器：AP3216C，AP3216C 是由敦南科技推出的一款传感器，其支持环境光强度(ALS)、接近距离(PS)和红外线强度(IR)这 三个环境参数检测。该芯片可以通过 IIC 接口与主控制相连，并且支持中断，AP3216C 的特点如下：</p><ol><li><p>I2C 接口，快速模式下波特率可以到 400Kbit/S </p></li><li><p>多种工作模式选择：ALS、PS+IR、ALS+PS+IR、PD 等等</p></li><li><p>内建温度补偿电路</p></li><li><p>宽工作温度范围(-30°C ~ +80°C)</p></li><li><p>超小封装，4.1mm x 2.4mm x 1.35mm </p></li><li><p>环境光传感器具有 16 位分辨率</p></li><li><p>接近传感器和红外传感器具有 10 位分辨率</p></li></ol><p>AP3216C 常被用于手机、平板、导航设备等，其内置的接近传感器可以用于检测是否有物 体接近，比如手机上用来检测耳朵是否接触听筒，如果检测到的话就表示正在打电话，手机就 会关闭手机屏幕以省电。也可以使用环境光传感器检测光照强度，可以实现自动背光亮度调节</p><p>AP3216 的设备地址为 0X1E，同几乎所有的 I2C 从器件一样，AP3216C 内部也有一些寄存 器，通过这些寄存器我们可以配置 AP3216C 的工作模式，并且读取相应的数据</p><p>0X00 这个寄存器是模式控制寄存器，用来设置 AP3216C 的工作模式， 一般开始先将其设置为 0X04，也就是先软件复位一次 AP3216C。接下来根据实际使用情况选 择合适的工作模式，比如设置为 0X03，也就是开启 ALS+PS+IR。从 0X0A~0X0F 这 6 个寄存 器就是数据寄存器，保存着 ALS、PS 和 IR 这三个传感器获取到的数据值。如果同时打开 ALS、 PS 和 IR 的读取间隔最少要 112.5ms，因为 AP3216C 完成一次转换需要 112.5ms。关于 AP3216C 的介绍就到这里，如果要想详细的研究此芯片的话，请大家自行查阅其数据手册。 本章实验中我们通过 I.MX6U 的 I2C1 来读取 AP3216C 内部的 ALS、PS 和 IR 这三个传感 器的值，并且在 LCD 上显示。开机会先检测 AP3216C 是否存在，一般的芯片是有个 ID 寄存 器，通过读取 ID 寄存器判断 ID 是否正确就可以检测芯片是否存在。但是 AP3216C 没有 ID 寄 存器，所以我们就通过向寄存器 0X00 写入一个值，然后再读取 0X00 寄存器，判断读出得到值 和写入的是否相等，如果相等就表示 AP3216C 存在，否则的话 AP3216C 就不存在</p><ol><li>初始化相应的 IO 初始化 I2C1 相应的 IO，设置其复用功能，如果要使用 AP3216C 中断功能的话，还需要设 置 AP3216C 的中断 IO</li><li>初始化 I2C1 初始化 I2C1 接口，设置波特率</li><li>初始化 AP3216C 初始化 AP3216C，读取 AP3216C 的数据</li></ol><p>文件bsp_i2c.c一共有8个函数，函数i2c_init， 用来初始化 I2C，重点是设置 I2C 的波特率，初始化完成以后开启 I2C。i2c_master_repeated_start函数用来发送一个重复开始信号，发送开始信号的时候也会顺带发送从设备地址。i2c_master_start 用于发送一个开始信号，发送开始信号的时候也顺带发送从设备地址。i2c_check_and_clear_error函数用于检查并清除错误。i2c_master_stop，用于产生一个停止信号。i2c_master_write 和 i2c_master_read，这两个函数分别用于完成向 I2C 从设备写数据和从 I2C 从设备读数据。i2c_master_transfer函数就是用户最终调用的，用于完成 I2C 通信的函数，此函数会使用前面的函数拼凑出 I2C 读/写时序。此函数就是按照  I2C 读写时序来编写的</p><p>文件 bsp_ap3216c.c 共有 4 个函数， ap3216c_init 函数用 于初始化 AP3216C，初始化成功的话返回 0，如果初始化失败就返回其他值。此函数先初始化所使用到的 IO，比如初始化 I2C1 的相关 IO，并设置其复用为 I2C1。然后此函数会调用 i2c_init 来初始化 I2C1，最后初始化 AP3216C。ap3216c_writeonebyte 和 ap3216c_readonebyte，这两个函数分别是向 AP3216C 写入数据和从 AP3216C 读取数据。这两个函数都通过调用 bsp_i2c.c 中的函数 i2c_master_transfer 来完成对 AP3216C 的读写。ap3216c_readdata函数用于读取 AP3216C 中的 ALS、PS 和 IR 传感器数据</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;I2C-amp-AP3216C-简介&quot;&gt;&lt;a href=&quot;#I2C-amp-AP3216C-简介&quot; class=&quot;headerlink&quot; title=&quot;I2C &amp;amp; </summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note21-RTC实时时钟</title>
    <link href="https://chenzhan666.coding.me/2021/03/01/note21-RTC%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F/"/>
    <id>https://chenzhan666.coding.me/2021/03/01/note21-RTC%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F/</id>
    <published>2021-03-01T06:52:25.000Z</published>
    <updated>2021-03-01T07:26:13.238Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="I-MX6U-RTC-简介"><a href="#I-MX6U-RTC-简介" class="headerlink" title="I.MX6U RTC 简介"></a>I.MX6U RTC 简介</h1><p>大多数MCU 或者 MPU 内部自带了实时时钟外设模块。如 I.MX6U 内部的 SNVS 就提供了 RTC 功能</p><p>SNVS 直译是安全的非易性存储，SNVS 里面主要是一些低功耗的外设，包括一个安全的实时计数器(RTC)、一个单调计数器(monotonic counter)和一些通用的寄存器，这里只使用实时计数器(RTC)。SNVS 里面的外设在芯片掉电以后由电池供电继续运行，I.MX6UALPHA 开发板上有一个纽扣电池，这个纽扣电池就是在主电源关闭以后为 SNVS 供电的</p><p>纽扣电池在掉电以后会继续给 SNVS 供电，因此实时计数器就会一直运行，这样的话时间信息就不会丢失。在有纽扣电池作为后备电源的情况下，不管系统主电源是否断电，SNVS 都正常运行。SNVS 有两部分：SNVS_HP 和 SNVS_LP，系统主电源断电以后 SNVS_HP 也会断电，但是在后备电源支持下，SNVS_LP 是不会断电的，而且 SNVS_LP 是和芯片复位隔离开的，因此 SNVS_LP 相关的寄存器的值会一直保存着。 SNVS 分为两个子模块：SNVS_HP 和 SNVS_LP，也就是高功耗域(SNVS_HP)和低功耗域 (SNVS_LP)，这两个域的电源来源如下： SNVS_LP：专用的 always-powered-on 电源域，系统主电源和备用电源都可以为其供电。 SNVS_HP：系统(芯片)电源。 SNVS 的这两个子模块的电源如图所示</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note21-RTC实时时钟\image-20210301145727911.png" alt="image-20210301145727911"></p><p>图中各个部分功能如下：</p><p>、VDD_HIGH_IN 是系统(芯片)主电源，这个电源会同时供给给 SNVS_HP 和 SNVS_LP</p><p>、VDD_SNVS_IN 是纽扣电池供电的电源，这个电源只会供给给 SNVS_LP，保证在系统主电源 VDD_HIGH_IN 掉电以后 SNVS_LP 会继续运行</p><p>、SNVS_HP 部分</p><p>、SNVS_LP 部分，此部分有个 SRTC，这个就是我们要使用的 RTC。</p><p>SNVS_HP 和 SNVS_LP，其内部都有一个 SRTC，但因为 SNVS_HP 在系统电源掉电以后就会关闭，所以我们使用的是 SNVS_LP 内部的 SRTC。SNVS_HP 在设备每次关闭以后时钟都被清零，然后开机以后先设置时钟</p><p>不管是 SNVS_HP 里面的 RTC，还是 SNVS_LP 里面的 SRTC，本质是一个定时 器，和 EPIT 定时器一样，只要提供时钟，就会一直运行。SRTC 需要外界提供一个 32.768KHz 的时钟，I.MX6U-ALPHA 核心板上的 32.768KHz 的晶振就是提供这个时钟的。寄存器 SNVS_LPSRTCMR 和 SNVS_LPSRTCLR 保存着秒数，直接读取这两个寄存器的值就知道过了多长时间了。一般以 1970 年 1 月 1 日为起点，加上经过的秒数即可得到现在的时间和日期。SRTC 带有闹钟功能的，可以在寄存器 SNVS_LPAR 中写入闹钟时间值，当时钟值和闹钟值匹配的时候就会产生闹钟中断，要使用时钟功能的话还需要进行一些设置</p><p>与 SRTC 相关的部分寄存器，首先是 SNVS_HPCOMR 寄存器，这个寄存器只用到了位：NPSWA_EN(bit31)，这个位是非特权软件访问控制位，如果非特权软件要访问 SNVS 的话此位必须为 1</p><p>寄存器SNVS_LPCR寄存器，此寄存器也只用到了一个位：SRTC_ENV(bit0)， 此位为 1 的话就使能 STC 计数器</p><p><del>寄存器 SNVS_SRTCMR 和 SNVS_SRTCLR，这两个寄存器保存着 RTC 的秒数，按照NXP官方的《6UL参考手册》中的说法，SNVS_SRTCMR保存着高15位，SNVS_SRTCLR 保存着低 32 位，因此 SRTC 的计数器一共是 47 位</del></p><p>但是！老师在编写驱动的时候发现按照手册上说的去读取计数器值是错误的！具体表现就是 时间是混乱的，因此老师在查找了 NXP 提供的 SDK 包中的 fsl_snvs_hp.c 以及 Linux 内核中的 rtcsnvs.c 这两个驱动文件以后发现《6UL 参考手册》上对 SNVS_SRTCMR 和 SNVS_SRTCLR 的 解释是错误的，经过查阅这两个文件，<strong>得到如下结论</strong>： </p><ol><li>SRTC 计数器是 32 位的，不是 47 位！</li><li>SNVS_SRTCMR 的 bit14:0 这 15 位是 SRTC 计数器的高 15 位</li><li>SNVS_SRTCLR 的 bit31:bit15 这 17 位是 SRTC 计数器的低 17 位</li></ol><p>按照上面的解释去读取这两个寄存器就可以得到正确的时间，如果要调整时间的话也是向这两个寄存器写入要设置的时间值对应的秒数就可以了，但是修改这两个寄存器的话要先关闭 SRTC。关于这些寄存器详细的描述，参考 《I.MX6UL 参考手册》第 2931 页的 46.7 小节</p><p>使用 I.MX6U 的 SNVS_LP 的 SRTC， 配置步骤如下</p><ol><li><p>初始化 SNVS_SRTC </p><p>初始化 SNVS_LP 中的 SRTC</p></li><li><p>设置 RTC 时间 </p><p>第一次使用 RTC 肯定要先设置时间</p></li><li><p>使能 RTC </p><p>配置好 RTC 并设置好初始时间以后就可以开启 RTC </p></li></ol><p>文件 bsp_rtc.c 里面一共有 9 个函数，函数 rtc_init 是初始化rtc的，主要是使能RTC，也可以在rtc_init函数里面设置时间。函数rtc_enable和rtc_disable 分别是 RTC 的使能和禁止函数。函数 rtc_isleapyear 用于判断某一年是否为闰年。函数 rtc_coverdate_to_seconds 负责将给定的日期和时间信息转换为对应的秒数。函数 rtc_setdatetime 用于设置时间，也就是设置寄存器 SNVS_LPSRTCMR 和 SNVS_LPSRTCLR 。 函 数 rtc_convertseconds_to_datetime 用于将给定的秒数转换为对应的时间值。函数 rtc_getseconds 获 取 SRTC 当前秒数，其实就是读取寄存器 SNVS_LPSRTCMR 和 SNVS_LPSRTCLR，然后将其 结合成 47 位的值。最后一个函数 rtc_getdatetime 是获取时间值</p><p>我们在 main 函数里面先初始化 RTC，然后进入 3S 倒计时， 如果这 3S 内按下了 KEY0 按 键，那么就设置 SRTC 的日期。如果 3S 倒计时结束以后没有按下 KEY0，也就是没有设置 SRTC 时间的话就进入 while 循环，然后读取 RTC 的时间值并且显示在 LCD 上</p><hr><p>参考资料：正点原子    《I.MX6UL 参考手册》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;I-MX6U-RTC-简介&quot;&gt;&lt;a href=&quot;#I-MX6U-RTC-简介&quot; class=&quot;headerlink&quot; title=&quot;I.MX6U RTC 简介&quot;&gt;&lt;/a&gt;I</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note20-RGBLCD显示</title>
    <link href="https://chenzhan666.coding.me/2021/03/01/note20-RGBLCD%E6%98%BE%E7%A4%BA/"/>
    <id>https://chenzhan666.coding.me/2021/03/01/note20-RGBLCD%E6%98%BE%E7%A4%BA/</id>
    <published>2021-02-28T16:02:57.000Z</published>
    <updated>2021-02-28T16:59:56.388Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="RGBLCD-显示"><a href="#RGBLCD-显示" class="headerlink" title="RGBLCD 显示"></a>RGBLCD 显示</h1><h2 id="LCD-和-eLCDIF-简介"><a href="#LCD-和-eLCDIF-简介" class="headerlink" title="LCD 和 eLCDIF 简介"></a>LCD 和 eLCDIF 简介</h2><h3 id="LCD-简介"><a href="#LCD-简介" class="headerlink" title="LCD 简介"></a>LCD 简介</h3><p>LCD 全称是 Liquid Crystal Display，是液晶显示器，LCD 的原理解释如下： LCD 的构造是在两片平行的玻璃基板当中放置液晶盒，下基板玻璃上设置 TFT（薄膜晶体管），上基板玻璃上设置彩色滤光片，通过 TFT 上的信号与电压改变来控制液晶分子的转动方向，从而达到控制每个像素点偏振光出射与否而达到显示目的</p><ul><li>分辨率</li></ul><p>LCD 显示器 720P、1080P、2K 或 4K ，就是 LCD 显示器分辨率。是由一个一个的像素点组成，像素点类似一个灯(在 OLED 显示器中，像素点就是一个小灯)，这个小灯是 RGB 灯，也就是由 R(红色)、G(绿色)和 B(蓝色)这三 种颜色组成的，而 RGB 就是光的三原色。1080P 的意思就是一个 LCD 屏幕上的像素数量是 1920*1080 个，也就是这个屏幕一列 1080 个像素点，一共 1920 列</p><p>1080P 显示器像素示意图中，X 轴就是 LCD 显示器的横轴，Y 轴就是显示器的竖轴。图中小方块就是像素点，一共有 1920*1080=2073600 个像素点。左上角的 A 点是第一个像素点，右下角的 C 点就是最后一个像素点。2K 就是 25601440 个像素点，4K 是 38402160 个像素点。在 LCD 尺寸不变的情况下，分辨率越高越清晰。分辨率不变的情况下，LCD 尺寸越小越清晰。衡量一款 LCD 的好坏，分辨率只是其中的一个参数，还有色彩还原程度、色彩偏离、亮 度、可视角度、屏幕刷新率等其他参数</p><ul><li>像素格式</li></ul><p>一个像素点相当于一个 RGB 小灯，通过控制 R、G、B 这三种颜色的亮度可以显示出各种各样的色彩。一般一个 R、 G、B 这三部分分别使用 8bit 的数据，那么一个像素点就是 8bit*3=24bit，也就是说一个像素点 3 个字节，这种像素格式称为 RGB888。如果在加入 8bit 的 Alpha(透明)通道的话一个像素点就是 32bit，也就是 4 个字节，这种像素格式称为 ARGB8888。ARGB8888 这种像素格式，一个像素占用 4 个字节的内存，这四个字节每个位的分配如图</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note20-RGBLCD显示\image-20210301001603955.png" alt="image-20210301001603955"></p><p>图中，一个像素点是 4 个字节，其中 bit31<del>bit24 是 Alpha 通道，bit23</del>bit16 是 RED 通道，bit15<del>bit14 是 GREEN 通道，bit7</del>bit0 是 BLUE 通道。所以红色对应的值就是 0X00FF0000，蓝色对应的值就是 0X000000FF，绿色对应的值为 0X0000FF00。通过调节 R、G、 B的比例可以产生其它的颜色，比如0X00FFFF00就是黄色，0X00000000就是黑色，0X00FFFFFF 就是白色</p><ul><li>LCD 屏幕接口</li></ul><p>LCD 屏幕即显示器有很多种接口，比如显示器上常见的 VGA、HDMI、DP 等等， 但I.MX6U-ALPHA开发板不支持这些接口。I.MX6U-ALPHA支持RGB接口的LCD，RGBLCD 接口的信号线如表所示</p><table><thead><tr><th>信号线</th><th>描述</th></tr></thead><tbody><tr><td>R[7:0]</td><td>8 根红色数据线</td></tr><tr><td>G[7:0]</td><td>8 根绿色数据线</td></tr><tr><td>B[7:0]</td><td>8 根蓝色数据线</td></tr><tr><td>DE</td><td>数据使能线</td></tr><tr><td>VSYNC</td><td>垂直同步信号线</td></tr><tr><td>HSYNC</td><td>水平同步信号线</td></tr><tr><td>PCLK</td><td>像素时钟信号线</td></tr></tbody></table><p>表是RGBLCD的信号线，R[7:0]、G[7:0]和B[7:0]这24根是数据线，DE、VSYNC、 HSYNC 和 PCLK 这四根是控制信号线。RGB LCD 一般有两种驱动模式：DE 模式和 HV 模式， 这两个模式的区别是 DE 模式需要用到 DE 信号线，而 HV 模式不需要用到 DE 信号线，在 DE 模式下是可以不需要 HSYNC 信号线的，即使不接 HSYNC 信号线 LCD 也可以正常工作。 ALIENTEK 一共有三款 RGB LCD 屏幕，型号分别为：ATK-4342(4.3 寸，480 * 272)、ATK7084(7 寸，800 * 480)和 ATK-7016(7 寸，1024 * 600)</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note20-RGBLCD显示\image-20210301002234070.png" alt="image-20210301002234070"></p><p> J1 是对外接口，是一个 40PIN 的 FPC 座（0.5mm 间距），通过 FPC 线，可以连接到 I.MX6U-ALPHA 开发板上面，从而实现和 I.MX6U 的连接。该接口十分完善，采用 RGB888 格式，并支持 DE&amp;HV 模式，还支持触摸屏和背光控制。右侧的几个电阻，可以用户自己选择。默认情况，R1 和 R6 焊接，设置 LCD_LR 和 LCD_UD，控制 LCD 的扫描方向，是从左到右，从上到下（横屏看）。而 LCD_R7/G7/B7 则用来设置 LCD 的 ID，由于 RGBLCD 没有读写寄存器，也就没有所谓的 ID，这里我们通过在模块上面，控制 R7/G7/B7 的 上/下拉，来自定义 LCD 模块的 ID，帮助 MCU 判断当前 LCD 面板的分辨率和相关参数，以提高程序兼容性。这几个位的设置关系如表所示：</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note20-RGBLCD显示\image-20210301002350840.png" alt="image-20210301002350840"></p><p>ATK-7016 模块，就设置 M2:M0=010 即可。这样，我们在程序里面，读取 LCD_R7/G7/B7， 得到 M0:M2 的值，从而判断 RGBLCD 模块的型号，并执行不同的配置，即可实现不同 LCD 模 块的兼容</p><ul><li>LCD 时间参数</li></ul><p>LCD 扫描一帧图像由一行一行组成的。HSYNC 是水平同步信号，也叫做行同步信号，当产生此信号的话就表示开始显示新的一行了，所以此信号都是在图的最左边。当 VSYNC 信号是垂直同步信号，也叫做帧同步信号，当产生此信号的话就表示开始显示新的一帧图像了，所以此信号在图的左上角。 在图可以看到有一圈“黑边”，真正有效的显示区域是中间的白色部分。CRT 显示器后面是个电子枪，电子枪打出的电子撞 击到屏幕上的荧光物质使其发光。只要控制电子枪从左到右扫完一行(也就是扫描一行)，然后从上到下扫描完所有行，这样一帧图像就显示出来。显示一帧图像电子枪是按照 ‘Z’形在运动，当扫描速度很快的时候看起来就是一幅完成的画面了。 当显示完一行以后会发出 HSYNC 信号，此时电子枪就会关闭，然后迅速的移动到屏幕的 左边，当 HSYNC 信号结束以后就可以显示新的一行数据了，电子枪就会重新打开。在 HSYNC 信号结束到电子枪重新打开之间会插入一段延时，这段延时就是图中的 HBP。当显示完一行以后就会关闭电子枪等待 HSYNC 信号产生，关闭电子枪到 HSYNC 信号产生之间会插入一段延时，这段延时就是图中的 HFP 信号。同理，当显示完一帧图像以后电子枪也会关闭，然后等到 VSYNC 信号产生，期间也会加入一段延时，这段延时就是图中的 VFP。 VSYNC 信号产生，电子枪移动到左上角，当 VSYNC 信号结束以后电子枪重新打开，中间也会加入一段延时，这段延时就是图中的 VBP</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note20-RGBLCD显示\image-20210301002857220.png" alt="image-20210301002857220"></p><p>HBP、HFP、VBP 和 VFP 是导致图 24.1.1.5 中黑边的原因，LCD 显示器， RGB LCD 屏幕内部是有一个 IC 的，发送一行或者一帧数据给 IC，IC 是需要反应时间的。通过这段反应 时间可以让 IC 识别到一行数据扫描完了，要换行了，或者一帧图像扫描完了，要开始下一帧图 像显示了。因此，在 LCD 屏幕中继续存在 HBP、HFP、VPB 和 VFP 这四个参数的主要目的是 为了锁定有效的像素数据。这四个时间是 LCD 重要的时间参数，后面编写 LCD 驱动的时候要 用到的，至于这四个时间参数具体值是多少，需要去查看所使用的 LCD 数据手册</p><ul><li>RGB LCD 屏幕时序</li></ul><p><img src="/Personalwebsite/blog/myBlog/.me//Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210301003541074.png" alt="image-20210301003541074"></p><p><strong>HSYNC</strong>8：行同步信号，当此信号有效的话就表示开始显示新的一行数据，查阅所使用的 LCD 数据手册可以知道此信号是低电平有效还是高电平有效，假设此时是低电平有效</p><p><strong>HSPW</strong>：有些地方也叫做 thp，是 HSYNC 信号宽度，也就是 HSYNC 信号持续时间</p><p>HSYNC 信号不是一个脉冲，而是需要持续一段时间才是有效的，单位为 CLK</p><p><strong>HBP</strong>：有些地方叫做 thb，前面已经讲过了，术语叫做行同步信号后肩，单位是 CLK </p><p><strong>HOZVAL</strong>：有些地方叫做 thd，显示一行数据所需的时间，假如屏幕分辨率为 1024*600， 那么 HOZVAL 就是 1024，单位为 CLK</p><p><strong>HFP</strong>：有些地方叫做 thf，前面已经讲过了，术语叫做行同步信号前肩，单位是 CLK</p><p>当 HSYNC 信号发出以后，需要等待 HSPW+HBP 个 CLK 时间才会接收到真正有效的像素数据。当显示完一行数据以后需要等待 HFP 个 CLK 时间才能发出下一个 HSYNC 信号，所以 显示一行所需要的时间就是：HSPW + HBP + HOZVAL + HFP，一帧图像就是由很多个行组成的</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note20-RGBLCD显示\image-20210301003753141.png" alt="image-20210301003753141"></p><p><strong>VSYNC</strong>：帧同步信号，当此信号有效的话就表示开始显示新的一帧数据，查阅所使用的 LCD 数据手册可以知道此信号是低电平有效还是高电平有效，假设此时是低电平有效</p><p><strong>VSPW</strong>：些地方也叫做 tvp，是 VSYNC 信号宽度，也就是 VSYNC 信号持续时间，单位为 1 行的时间</p><p><strong>VBP</strong>：有些地方叫做 tvb，前面已经讲过了，术语叫做帧同步信号后肩，单位为 1 行的时间 </p><p><strong>LINE</strong>：有些地方叫做 tvd，显示一帧有效数据所需的时间，假如屏幕分辨率为 1024*600， 那么 LINE 就是 600 行的时间</p><p><strong>VFP</strong>：有些地方叫做 tvf，前面已经讲过了，术语叫做帧同步信号前肩，单位为 1 行的时间</p><p>显示一帧所需要的时间就是：VSPW+VBP+LINE+VFP 个行时间，最终的计算公式： </p><p>T = (VSPW+VBP+LINE+VFP) * (HSPW + HBP + HOZVAL + HFP)</p><p>因此我们在配置一款 RGB LCD 的时候需要知道这几个参数：HOZVAL(屏幕有效宽度)、 LINE(屏幕有效高度)、HBP、HSPW、HFP、VSPW、VBP 和 VFP</p><ul><li>像素时钟</li></ul><p>像素时钟就是 RGB LCD 的时钟信号，以 ATK7016 这款屏幕为例，显示一帧图像所需要的时钟数就是： </p><p>= (VSPW+VBP+LINE+VFP) * (HSPW + HBP + HOZVAL + HFP) </p><p>= (3 + 20 + 600 + 12) * (20 + 140 + 1024 + 160) </p><p>= 635 * 1344 = 853440</p><p>显示一帧图像需要853440个时钟数，那么显示60帧就是：853440 * 60 = 51206400≈51.2M， 所以像素时钟就是 51.2MHz</p><p><strong>I.MX6U 的 eLCDIF 接口时钟图略</strong></p><p>以 ATK7016 屏幕所需的 51.2MHz 为例进行配置。 PLL5 频率设置涉及到四个寄存器：CCM_PLL_VIDEO、CCM_PLL_VIDEO_NUM、 CCM_PLL_VIDEO_DENOM 、 CCM_MISC2 。 其 中 CCM_PLL_VIDEO_NUM 和 CCM_PLL_VIDEO_DENOM 这两个寄存器是用于小数分频的，不使用小数分频，因此这两个寄存器设置为 0。 PLL5 的时钟计算公式如下： </p><p>PLL5_CLK = OSC24M * (loopDivider + (denominator / numerator)) / postDivider </p><p>不使用小数分频的话 PLL5 时钟计算公式就可以简化为 ： </p><p>PLL5_CLK = OSC24M * loopDivider / postDivider </p><p>OSC24M 就是 24MHz 的有源晶振</p><p>寄存器 CCM_PLL_VIDEO 用到的重要的位如下：</p><p>POST_DIV_SLECT(bit20:19)：此位和寄存器 CCM_ANALOG_CCMSC2 的 VIDEO_DIV 位共同决定了 postDivider，为 0 的话是 4 分频，为 1 的话是 2 分频，为 2 的话是 1 分频。设置为 2，也就是 1 分频</p><p>ENABLE(bit13)：PLL5(PLL_VIDEO)使能为 1 的话使能 PLL5，为 0 的话关闭 PLL5 DIV_SELECT(bit6:0)：loopDivider 值，范围为 27~54，设置为 32</p><p>寄存器 CCM_ANALOG_MISC2 的位 VIDEO_DIV(bit31:30)与寄存器 CCM_PLL_VIDEO 的位 POST_DIV_SLECT(bit20:19)共同决定了 postDivider，通过这两个的配合可以获得 2、4、8、16 分频。将 VIDEO_DIV 设置为 0，也就是 1 分频，因此 postDivider 就是 1，loopDivider 设 置为 32，PLL5 的时钟频率就是： </p><p>PLL5_CLK = OSC24M * loopDivider / postDivider </p><p>​                  = 24M * 32 / 1 </p><p>​                  = 768MHz</p><p>PLL5 此时为 768MHz，在经过图中的②和③进一步分频，设置②中为 3 分频，也 就是寄存器 CCM_CSCDR2 的位 LCDIF1_PRED(bit14:12)为 2。设置③中为 5 分频，就是寄存器 CCM_CBCMR 的位 LCDIF1_PODF(bit25:23)为 4。设置好以后最终进入到 LCDIF 的时钟频率就 是：768/3/5 =51.2MHz，这就是我们需要的像素时钟频率</p><ul><li>显存</li></ul><p>如果采用 ARGB8888 格式的话一个像素需要 4 个字节 的内存来存放像素数据，那么 1024 * 600 分辨率就需要 1024 * 600 * 4=2457600B≈2.4MB 内存。但 是 RGB LCD 内部是没有内存的，所以就需要在开发板上的 DDR3 中分出一段内存作为 RGB LCD 屏幕的显存，我们如果要在屏幕上显示什么图像的话直接操作这部分显存即可</p><h3 id="eLCDIF-接口"><a href="#eLCDIF-接口" class="headerlink" title="eLCDIF 接口"></a>eLCDIF 接口</h3><p>eLCDIF 是 I.MX6U 自带的液晶屏幕接口，用于连接 RGB LCD 接口的屏幕，eLCDIF 接口特性如下： </p><ol><li>支持 RGB LCD 的 DE 模式</li><li>支持 VSYNC 模式以实现高速数据传输</li><li>支持 ITU-R BT.656 格式的 4:2:2 的 YCbCr 数字视频，并且将其转换为模拟 TV 信号</li><li>支持 8/16/18/24/32 位 LCD</li></ol><p>eLCDIF 支持三种接口：MPU 接口、VSYNC 接口和 DOTCLK 接口，这三种接口区别如下： </p><ol><li><p>MPU 接口 MPU 接口用于在 I.MX6U 和 LCD 屏幕直接传输数据和命令，这个接口用于 6080/8080 接 口的 LCD 屏幕，如果寄存器 LCDIF_CTRL 的位 DOTCLK_MODE、DVI_MODE 和 VSYNC_MODE 都为 0 的话就表示 LCDIF 工作在 MPU 接口模式。关于 MPU 接口的详细信息以及时序参考《I.MX6ULL 参考手册》第 2150 页的“34.4.6 MPU Interface”小节</p></li><li><p>VSYNC 接口 VSYNC 接口时序和 MPU 接口时序基本一样， VSYNC 信号来作为帧同步，当 LCDIF_CTRL 的位 VSYNC_MODE 为 1 的时候此接口使能。关于 VSYNC 接口的详细信息请参 考《I.MX6ULL 参考手册》第 2152 页的“34.4.7 VSYNC Interface”小节</p></li><li><p>DOTCLK 接口DOTCLK 接口就是用来连接 RGB LCD 接口屏幕的， 它包括 VSYNC、HSYNC、DOTCLK 和 ENABLE(可选的)这四个信号，这样的接口通常被称为 RGB 接口</p></li></ol><ul><li>LCDIF_CTRL 寄存器</li><li>寄存器 LCDIF_CTRL1， 用 到 位 BYTE_PACKING_FORMAT(bit19:16)，此位用来决定在 32 位的数据中哪些字节的数据有效，默 认值为 0XF，也就是所有的字节有效，当为 0 的话表示所有的字节都无效</li><li>寄存器 LCDIF_TRANSFER_COUNT，用来设置所连接的 RGB LCD 屏幕分辨率大小</li><li>寄存器LCDIF_TRANSFER_COUNT分为两部分，高16位和低16位，高16位是V_COUNT， 是 LCD 的垂直分辨率</li><li>寄存器 LCDIF_VDCTRL0，这个寄存器是 VSYNC 和 DOTCLK 模式控制寄存器 0</li><li>寄存器 LCDIF_VDCTRL1，这个寄存器是 VSYNC 和 DOTCLK 模式控制寄 存器 1，此寄存器只有一个功能，用来设置 VSYNC 总周期，就是：屏幕高度+VSPW+VBP+VFP</li><li>寄存器 LCDIF_VDCTRL2，这个寄存器分为高 16 位和低 16 位两部分，高 16 位是 HSYNC_PULSE_WIDTH，用来设置 HSYNC 信号宽度，也就是 HSPW。低 16 位是 HSYNC_PERIOD，设置 HSYNC 总周期，就是：屏幕宽度+HSPW+HBP+HFP</li><li>寄存器 LCDIF_VDCTRL3</li><li>寄存器 LCDIF_VDCTRL4</li><li>寄存器 LCDIF_CUR_BUF 和 LCDIF_NEXT_BUF，这两个寄存器分别为当前 帧和下一帧缓冲区，也就是 LCD 显存。一般这两个寄存器保存同一个地址，也就是划分给 LCD 的显存首地址</li></ul><p>使用 I.MX6U 的 eLCDIF 接口来驱动 ALIENTEK 的 ATK7016 这款屏幕，配置步骤如下：</p><ol><li>初始化 LCD 所使用的 IO 首先肯定是初始化 LCD 所示使用的 IO，将其复用为 eLCDIF 接口 IO</li><li>设置 LCD 的像素时钟 查阅所使用的 LCD 屏幕数据手册，或者自己计算出的时钟像素，然后设置 CCM 相应的寄存器</li><li>配置 eLCDIF 接口 设置 LCDIF 的寄存器 CTRL、CTRL1、TRANSFER_COUNT、VDCTRL0~4、CUR_BUF 和 NEXT_BUF。根据 LCD 的数据手册设置相应的参数</li><li>编写 API 函数 驱动 LCD 屏幕的目的就是显示内容，所以需要编写一些基本的 API 函数，比如画点、画 线、画圆函数，字符串显示函数等</li></ol><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;RGBLCD-显示&quot;&gt;&lt;a href=&quot;#RGBLCD-显示&quot; class=&quot;headerlink&quot; title=&quot;RGBLCD 显示&quot;&gt;&lt;/a&gt;RGBLCD 显示&lt;/h1</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note19-DDR3内存芯片实验</title>
    <link href="https://chenzhan666.coding.me/2021/02/28/note19-DDR3%E5%86%85%E5%AD%98%E8%8A%AF%E7%89%87%E5%AE%9E%E9%AA%8C/"/>
    <id>https://chenzhan666.coding.me/2021/02/28/note19-DDR3%E5%86%85%E5%AD%98%E8%8A%AF%E7%89%87%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-02-28T03:17:12.000Z</published>
    <updated>2021-02-28T06:24:37.715Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="DDR3-内存简介"><a href="#DDR3-内存简介" class="headerlink" title="DDR3 内存简介"></a>DDR3 内存简介</h1><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p>随机存储器，可以随时进行读写操作，速度很快，掉电以后数据会丢失。比如内存 条、SRAM、SDRAM、DDR 等都是 RAM。RAM 一般用来保存程序数据、中间结果</p><p>可以随意的对 RAM 中任何地址的数据进行读写操作，不需要在乎具体的读写过程</p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>只读存储器，手机通常会是 4+64 或 6+128 配置，就是 RAM 为 4GB 或 6GB，ROM 为 64G 或 128GB。但是这个 ROM 是 Flash(flash memory闪存)，比如 EMMC 或 UFS 存储器，有些Flash 叫做 ROM。但 EMMC 和 UFS， NAND Flash，可以进行写操作的！只是写起来比较麻烦，要先发送要先进行擦除，然后在发送要写的地址或扇区，最后才是要写入的数据，相比于 RAM，向 ROM 或者 Flash 写入数据要复杂很多，因此意味着速度就会变慢(相比 RAM)， 但是 ROM 和 Flash 可以将容量做的很大，而且掉电以后数据不会丢失，适合用来存储资料，比如音乐、图片、视频等信息</p><p>综上所述，RAM 速度快，可以直接和 CPU 进行通信，但是掉电以后数据会丢失，容量不容易做大(和同价格的 Flash 相比)。ROM(目前来说，更适合叫做 Flash)速度虽然慢，但是容量大、适合存储数据</p><h2 id="SRAM-简介"><a href="#SRAM-简介" class="headerlink" title="SRAM 简介"></a>SRAM 简介</h2><p>Static Random-Access Memory静态随机存储器，这里的“静态” 说的是只要 SRAM 上电，那么 SRAM 里面的数据就会一直保存着，直到 SRAM 掉电。对于 RAM 而言需要可以随机的读取任意一个地址空间内的数据，因此采用了地址线和数据线分离的方式</p><p>IS62WV51216  是一颗 16 位宽(数据位为 16 位)、1MB 大小的 SRAM 芯片讲解一下 SRAM</p><p>主要分为三部分：</p><ol><li><p>地址线</p><p>一共 A0~A18，也就是 19 根地址线，因此可访问的地址大小就是 2^19=524288=512KB。又因为 IS62WV51216 是 16 位宽，也就是一次访问 2 个字节，因此需要对 512KB 进行乘 2 处理，得到 512KB*2=1MB。位宽一般有 8 位/16 位/32 位，根据实际需求选择即可，一般都是根据处理器的 SRAM 控制器位宽来选择 SRAM 位宽</p></li><li><p>数据线</p><p>根据 SRAM 位宽的不同，数据线的数量要不同，8 位宽就有 8 根数据线，16 位宽就有 16 根数据线。IS62WV51216 是 16 位宽 的 SRAM，有 16 根数据线，一次访问可以访问 16bit 的数据，也就是 2 个字节。因此就有高字节和低字节数据之分，其中 IO0<del>IO7 是低字节数据，IO8</del>IO15 是高字节数据</p></li><li><p>控制线</p><p>SRAM 工作需要控制线，CS2 和 CS1 是片选信号，低电平有效，在一个系统中可能会有多片 SRAM(目的是为了扩展 SRAM 大小或位宽)，这个时候就需要 CS 信号来选择当前使用哪片 SRAM。另外，有的 SRAM 内部其实是由两片 SRAM 拼接起来的，因此会提供两个片选信号</p><p>OE 是输出使能信号，低电平有效，也就是主控从 SRAM 读取数据</p><p>WE 是写使能信号，低电平有效，也就是主控向 SRAM 写数据</p><p>UB 和 LB 信号，这两根控制线都是低电平有效。UB 为低电平的话表示访问高字节，LB 为低电平的话表示访问低字节</p></li></ol><p>SRAM 价格贵但无需刷新(SDRAM 需要刷新，后面会讲解)，读写速度快， SRAM 通常作为 SOC 的内部 RAM 使用或 Cache 使用，I.MX6U 内部的 OCRAM 是 SRAM</p><h2 id="SDRAM-简介"><a href="#SDRAM-简介" class="headerlink" title="SDRAM 简介"></a>SDRAM 简介</h2><p>Synchronous Dynamic Random Access Memory 同步动态随机存储器，“同步”的意思是 SDRAM 工作需要时钟线，“动态”的意思是 SDRAM 中的数据需要不断的刷新来保证数据不会丢失，“随机” 的意思就是可以读写任意地址的数据</p><p>与 SRAM 相比，SDRAM 集成度高、功耗低、成本低、适合做大容量存储，但是需要定时刷新来保证数据不会丢失。因此 SDRAM 适合用来做内存条，SRAM 适合做高速缓存或 MCU 内部的 RAM。SDRAM 目前已经发展到了第四代，分别为：SDRAM、DDR SDRAM、DDR2 SDRAM、DDR3 SDRAM、DDR4 SDRAM。</p><p>W9825G6KH 是一款 16 位宽(数据位为 16 位)、32MB 的 SDRAM、速度一般为 133MHz、166MHz 或 200MHz，主要有这几部分：</p><ol><li><p>控制线 </p><p>SDRAM 需要很多控制线： </p><p>CLK：时钟线，SDRAM 是同步动态随机存储器，“同步”的意思就是时钟，因此需要一根额外的时钟线，这是和 SRAM 最大的不同，SRAM 没有时钟线 </p><p>CKE：时钟使能信号线，SRAM 没有 CKE 信号</p><p>CS：片选信号，这个和 SRAM 一样，都有片选信号 </p><p>RAS：行选通信号，低电平有效，SDRAM 和 SRAM 的寻址方式不同，SDRAM 按照行、 列来确定某个具体的存储区域。因此就有行地址和列地址之分，行地址和列地址共同复用同一 组地址线，要访问某一个地址区域，必须要发送行地址和列地址，指定要访问哪一行？哪一列？ RAS 是行选通信号，表示要发送行地址，行地址和列地址访问方式如图：</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note19-DDR3内存芯片实验\image-20210228133801189.png" alt="image-20210228133801189"></p><p>CAS：列选通信号，和 RAS 类似，低电平有效，选中以后就可以发送列地址了</p><p> WE：写使能信号，低电平有效</p></li><li><p>A10 地址线</p><p>A10 是地址线，还有另外一个作用，A10 还控制着 Auto-precharge，也就是预充电。这里又提到了预充电的概念，SDRAM 芯片内部会分为多个 BANK，关于 BANK 我们稍后会讲解。SDRAM 在读写完成以后，如果要对同一个 BANK 中的另一行进行寻址操作就必须将原来有效的行关闭，然后发送新的行/列地址，关闭现在工作的行，准备打开新行的操作就叫做预充电。一般 SDSRAM 都支持自动预充电的功能</p></li><li><p>地址线</p><p>对于 W9825G6KH 来说一共有 A0<del>A12，共 13 根地址线，但 SDRAM 寻址是按照行地址和列地址来访问的，因此这 A0</del>A12 包含了行地址和列地址。不同的 SDRAM 芯 片，根据其位宽、容量等的不同，行列地址数是不同的，这个在 SDRAM 的数据手册里面会也清楚的。比如 W9825G6KH 的 A0<del>A8 是列地址，一共 9 位列地址，A0</del>A12 是行地址，一共 13 位，因此可寻址范围为：2^9*2^13=4194304B=4MB，W9825G6KH 为 16 位宽(2 个字节)，因此需要对 4MB 进行乘 2 处理，得到 42=8MB，但是 W9825G6KH 是一个 32MB 的 SDRAM 算出来只有 8MB，仅仅为实际容量的 1/4。 8MB 只是一个 BANK 的容量，W9825G6KH 一共有 4 个 BANK</p></li><li><p>BANK 选择线</p><p>BS0 和 BS1 是 BANK 选择信号线，在一片 SDRAM 中因为技术、成本等原因，不可能做 一个全容量的 BANK。因为 SDRAM 的工作原理，单一的 BANK 会带来严重的寻址冲突，减低内存访问效率。为此，人们在一片 SDRAM 中分割出多块 BANK，一般都是 2 的 n 次 方，比如 2，4，8 等。每个 SDRAM 数据手册里面都会写清楚自己是几 BANK。计算出来一个 BANK 的大小为 8MB， 那么四个 BANK 的总容量就是 8MB*4=32MB。 既然有4个BANK，那么在访问的时候就需要告诉SDRAM，我们现在需要访问哪个BANK， BS0 和 BS1 就是为此而生的，4 个 BANK 刚好 2 根线，如果是 8 个 BANK 的话就需要三根线， 也就是 BS0~BS2。BS0、BS1 这两个线也是 SRAM 所没有的</p></li><li><p>BANK 区域</p></li><li><p>数据线</p><p>W9825G6KH 是 16 位宽的 SDRAM，因此有 16 根数据线，DQ0~DQ15，不同的位宽其数 据线数量不同</p></li><li><p>高低字节选择</p><p>W9825G6KH 是一个 16 位的 SDRAM，因此就分为低字节数据和高字节数据，LDQM 和 UDQM 就是低字节和高字节选择信号</p></li></ol><h2 id="DDR-简介"><a href="#DDR-简介" class="headerlink" title="DDR 简介"></a>DDR 简介</h2><p>DDR 内存是 SDRAM 的升级版本，SDRAM 分为 SDR SDRAM、 DDR SDRAM、DDR2 SDRAM、DDR3 SDRAM、DDR4 SDRAM。先来看一下 DDR，也就是 DDR1，为了提高 SDRAM 的速度，DDR SDRAM 诞生</p><p>DDR 全称是 Double Data Rate SDRAM，也就是双倍速率 SDRAM，DDR 的 速率(数据传输速率)比 SDRAM 高 1 倍！这 1 倍的速度不是简简单单的将 CLK(1.表示总线数据上计数器，一般为高电平时触发 2.表示计时器，在计算机以及网络领域中，多指处理器或总线等数字电路工作时的时间间隔信号，实质是指这种信号的频率 3.一种方波信号，使操作按顺序进行，有时称其为处理器时钟) 提高 1 倍， SDRAM 在一个 CLK 周期传输一次数据，DDR 在一个 CLK 周期传输两次数据，也就是在上升 沿和下降沿各传输一次数据，这个概念叫做预取(prefetch)，相当于 DDR 的预取为 2bit，因此 DDR 的速度直接加倍！比如 SDRAM 速度一般是 133<del>200MHz，对应的传输速度就是 133</del>200MT/s，在描述 DDR 速度的时候一般都使用 MT/s，也就是每秒多少兆次数据传输。 133MT/S 就是每秒 133M 次数据传输，MT/s 描述的是单位时间内传输速率。同样 133<del>200MHz 的频率，DDR 的传输速度就变为了 266</del>400MT/S，所以大家常说的 DDR266、DDR400 就是这 么来的</p><p>DDR2 的 IO 时钟是 DDR 的 2 倍，因此 DDR 内核时钟依旧是 133<del>200MHz 的时候，总线速度就是 266</del>400MHz。而且 DDR2 在 DDR 基础上进一步增加预取(prefetch)，增加到了 4bit， 相当于比 DDR 多读取一倍的数据，因此 DDR2 的数据传输速率就是 533~800MT/s，这个也就是大家常说的 DDR2 533、DDR2 800</p><p>DDR3 在 DDR2 的基础上将预取(prefetch)提高到 8bit，因此又获得了比 DDR2 高一倍的传输速率，因此在总线时钟同样为 266<del>400MHz 的情况下，DDR3 的传输速率就是 1066</del>1600MT/S。 I.MX6U 的 MMDC 外设用于连接 DDR，支持 LPDDR2、DDR3、DDR3L，最高支持 16 位数据位宽。总线速度为 400MHz(实际是 396MHz)，数据传输速率最大为 800MT/S</p><p>LPDDR3、DDR3 和 DDR3L 的区别，这三个都是 DDR3，但是区别主要在于工作电压，LPDDR3 叫做低功耗 DDR3，工作电压为 1.2V。DDR3 叫做标压 DDR3，工作电压为 1.5V，一般台式内存条都是 DDR3。DDR3L 是低压 DDR3，工作电压为 1.35V，一般手机、嵌入式、笔记本等都使用 DDR3L</p><p>NT5CC256M16EP-EK 是一款容量为 4Gb，也就是 512MB 大小、 16 位宽、1.35V、传输速率为 1866MT/S 的 DDR3L 芯片，结构如下</p><ol><li><p>控制线</p><p>ODT：片上终端使能，ODT 使能和禁止片内终端电阻</p><p>ZQ：输出驱动校准的外部参考引脚，此引脚应该外接一个 240 欧的电阻到 VSSQ 上，一般 就是直接接地了</p><p>RESET：复位引脚，低电平有效</p><p>CKE：时钟使能引脚</p><p>A12：A12 是地址引脚，但是有也有另外一个功能，因此也叫做 BC 引脚，A12 会在 READ 和 WRITE 命令期间被采样，以决定 burst chop 是否会被执行</p><p>CK 和 CK#：时钟信号，DDR3 的时钟线是差分时钟线，所有的控制和地址信号都会在 CK 对的上升沿和 CK#的下降沿交叉处被采集</p><p>CS#：片选信号，低电平有效。 RAS#、CAS#和 WE#：行选通信号、列选通信号和写使能信号</p></li><li><p>地址线</p><p>A[14:0]为地址线，A0<del>A14，一共 15 根地址线，根据 NT5CC256M16ER-EK 的数据手册可知，列地址为 A0</del>A9，共 10 根，行地址为 A0~A14，共 15 根，因此一个 BANK 的大小就是 2^10*2^152=32MB2=64MB，根据图 23.1.4.2 可知一共有 8 个 BANK，因此 DDR3L 的容量就 是 648=512MB</p></li><li><p>BANK 选择线</p><p>一片 DDR3 有 8 个 BANK，因此需要 3 个线才能实现 8 个 BANK 的选择，BA0~BA2 就是 用于完成 BANK 选择的</p></li><li><p>BANK 区域</p><p>DDR3 一般都是 8 个 BANK 区域</p></li><li><p>数据线</p><p>因为是 16 位宽的，因此有 16 根数据线，分别为 DQ0~DQ15</p></li><li><p>数据选通引脚</p><p>DQS 和 DQS#是数据选通引脚，为差分信号，读的时候是输出，写的时候是输入。LDQS(有的叫做 DQSL)和 LDQS#(有的叫做 DQSL#)对应低字节，也就是 DQ0<del>7，UDQS(有的叫做 DQSU) 和 UDQS#(有的叫做 DQSU#)，对应高字节，也就是 DQ8</del>15</p></li><li><p>数据输入屏蔽引脚</p><p>DM 是写数据收入屏蔽引脚</p></li></ol><h2 id="DDR3-关键时间参数"><a href="#DDR3-关键时间参数" class="headerlink" title="DDR3 关键时间参数"></a>DDR3 关键时间参数</h2><h3 id="传输速率MT-S"><a href="#传输速率MT-S" class="headerlink" title="传输速率MT/S"></a>传输速率MT/S</h3><p>决定了 DDR3 内 存的最高传输速率</p><h3 id="tRCD-参数"><a href="#tRCD-参数" class="headerlink" title="tRCD 参数"></a>tRCD 参数</h3><p>tRCD 全称是 RAS-to-CAS Delay，也就是行寻址到列寻址之间的延迟。DDR 的寻址流程是先指定 BANK 地址，然后在指定行地址，最后指定列地址确定最终要寻址的单元。BANK 地址和行地址是同时发出的，这个命令叫做“行激活”(Row Active)。行激活以后就发送列地址和具体的操作命令(读还是写)，这两个是同时发出的，因此一般也用“读/写命令”表示列寻址。在行有效(行激活)到读写命令发出的这段时间间隔叫做 tRCD</p><h3 id="CL-参数"><a href="#CL-参数" class="headerlink" title="CL 参数"></a>CL 参数</h3><p>当列地址发出以后就会触发数据传输，但是数据从存储单元到内存芯片 IO 接口上还需要一段时间，这段时间就是非常著名的 CL(CAS Latency)，也就是列地址选通潜伏期</p><h3 id="AL-参数"><a href="#AL-参数" class="headerlink" title="AL 参数"></a>AL 参数</h3><p>提出了一个前置 CAS 的概念，目的是为了解决 DDR 中的指令冲突， 它允许 CAS 信号紧随着 RAS 发送，相当于将 DDR 中的 CAS 前置了。但是读/写操作并没有因此提前，依旧要保证足够的延迟/潜伏期，为此引入了 AL(Additive Latency)，单位也是时钟周期数。AL+CL 组成了 RL(Read Latency)，从 DDR2 开始还引入了写潜伏期 WL(Write Latency)， WL 表示写命令发出以后到第一笔数据写入的潜伏期</p><p>tRCD，AL、CL、RL 为读潜伏期，RL=AL+CL</p><h3 id="tRC-参数"><a href="#tRC-参数" class="headerlink" title="tRC 参数"></a>tRC 参数</h3><p>RC 是两个 ACTIVE 命令，或者 ACTIVE 命令到 REFRESH 命令之间的周期</p><h3 id="tRAS-参数"><a href="#tRAS-参数" class="headerlink" title="tRAS 参数"></a>tRAS 参数</h3><p>tRAS 是 ACTIVE 命令到 PRECHARGE 命令之间的最小时间</p><h1 id="I-MX6U-MMDC-控制器"><a href="#I-MX6U-MMDC-控制器" class="headerlink" title="I.MX6U MMDC 控制器"></a>I.MX6U MMDC 控制器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MMDC 就是 I.MX6U 的内存控制器，MMDC 是一个多模的 DDR 控制器，可以连接 16 位宽的 DDR3/DDR3L、16 位 宽的 LPDDR2，MMDC 是一个可配置、高性能的 DDR 控制器。MMDC 外设包含一个内核 (MMDC_CORE)和 PHY(MMDC_PHY)，内核和 PHY 的功能如下： </p><p><strong>MMDC 内核</strong>：内核负责通过 AXI 接口与系统进行通信、DDR 命令生成、DDR 命令优化、 读/写数据路径</p><p><strong>MMDC PHY</strong>：PHY 负责时序调整和校准，使用特殊的校准机制以保障数据能够在 400MHz 被准确捕获</p><p>MMDC 的主要特性如下： </p><ol><li>支持 DDR3/DDR3Lx16、支持 LPDDR2x16，不支持 LPDDR1MDDR 和 DDR2</li><li>支持单片 256Mbit~8Gbit 容量的 DDR，列地址范围：8-12 位，行地址范围 11-16bit。2 个片选信号</li><li>对于 DDR3，最大支持 8bit 的突发访问</li><li>对于 LPDDR2 最大支持 4bit 的突发访问</li><li>MMDC 最大频率为 400MHz，因此对应的数据速率为 800MT/S</li><li>支持各种校准程序，可以自动或手动运行。支持 ZQ 校准外部 DDR 设备，ZQ 校准 DDR I/O 引脚、校准 DDR 驱动能力</li></ol><h2 id="MMDC-控制器信号引脚"><a href="#MMDC-控制器信号引脚" class="headerlink" title="MMDC 控制器信号引脚"></a>MMDC 控制器信号引脚</h2><p>DDR 对于硬件要求非常严格，因此 DDR 的引脚都是独立的，一般没有复用功能，只做为 DDR 引脚使用</p><p>DDR 引脚的电气属性寄存器和普通的外设引脚电气 属性寄存器不同</p><h2 id="MMDC-控制器时钟源"><a href="#MMDC-控制器时钟源" class="headerlink" title="MMDC 控制器时钟源"></a>MMDC 控制器时钟源</h2><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note19-DDR3内存芯片实验\image-20210228141132319.png" alt="image-20210228141132319"></p><p>MMDC 的时钟源路径图，主要分为 4 部分：</p><ol><li><p>pre_periph2 时钟选择器，也就是 periph2_clkd 的前级选择器，由 CBCMR 寄存器的 PRE_PERIPH2_CLK_SEL 位(bit22:21)来控制，一共有四种可选方案</p><table><thead><tr><th>PRE_PERIPH2_CLK_SEL(bit22:21)</th><th>时钟源</th></tr></thead><tbody><tr><td>00</td><td>PLL2</td></tr><tr><td>01</td><td>PLL2_PFD2</td></tr><tr><td>10</td><td>PLL2_PFD0</td></tr><tr><td>11</td><td>PLL4</td></tr></tbody></table></li></ol><ol start="2"><li><p>periph2_clk 时钟选择器，由 CBCDR 寄存器的 PERIPH2_CLK_SEL 位(bit26)来控制， 当为 0 的时候选择 pll2_main_clk 作为 periph2_clk 的时钟源，当为 1 的时候选择 periph2_clk2_clk 作为 periph2_clk 的时钟源。这里肯定要将 PERIPH2_CLK_SEL 设置为 0，也就是选择 pll2_main_clk 作为 periph2_clk 的时钟源，因此 periph2_clk=PLL2_PFD0=396MHz </p></li><li><p>最后就是分频器，由 CBCDR 寄存器的 FABRIC_MMDC_PODF 位(bit5:3)设置分频值， 可设置 0<del>7，分别对应 1</del>8 分频，要配置 MMDC 的时钟源为 396MHz，那么此处就要设置为 1 分频，因此 FABRIC_MMDC_PODF=0</p></li></ol><p>MMDC 的时钟源设置，说 DDR 的频率为 400MHz，但是实际只有 396MHz</p><h1 id="DDR3L初始化与测试"><a href="#DDR3L初始化与测试" class="headerlink" title="DDR3L初始化与测试"></a>DDR3L初始化与测试</h1><h2 id="dr-stress-tester配置文件"><a href="#dr-stress-tester配置文件" class="headerlink" title="dr_stress_tester配置文件"></a>dr_stress_tester配置文件</h2><p>excel配置文件，excel配置好以后realview.inc会同步的更新</p><h2 id="inc文件"><a href="#inc文件" class="headerlink" title=".inc文件"></a>.inc文件</h2><p>ddr_stress_tester工具需要用到.inc文件</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>ddr_stress_tester通过USB口将.inc中的配置信息下载到开发板里面。直接进行超频测试的话测试失败</p><h2 id="做校准"><a href="#做校准" class="headerlink" title="做校准"></a>做校准</h2><p>Write leveling calibration</p><p>MMDC_MPWLDECTRL0 ch0 (0x021b080c) = 0x00000000</p><p>MMDC_MPWLDECTRL1 ch0 (0x021b0810) = 0x00070007</p><p>Read DQS Gating calibration</p><p>MPDGCTRL0 PHY0 (0x021b083c) = 0x01380138</p><p>MPDGCTRL1 PHY0 (0x021b0840) = 0x00000000</p><p>Read calibration</p><p>MPRDDLCTL PHY0 (0x021b0848) = 0x40402E32</p><p>Write calibration</p><p>MPWRDLCTL PHY0 (0x021b0850) = 0x40403432</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;DDR3-内存简介&quot;&gt;&lt;a href=&quot;#DDR3-内存简介&quot; class=&quot;headerlink&quot; title=&quot;DDR3 内存简介&quot;&gt;&lt;/a&gt;DDR3 内存简介&lt;/h1</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note18-UART串口通信</title>
    <link href="https://chenzhan666.coding.me/2021/02/27/note18-UART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
    <id>https://chenzhan666.coding.me/2021/02/27/note18-UART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</id>
    <published>2021-02-27T02:44:38.000Z</published>
    <updated>2021-02-28T14:39:16.727Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="I-MX6U-串口简介"><a href="#I-MX6U-串口简介" class="headerlink" title="I.MX6U 串口简介"></a>I.MX6U 串口简介</h1><h2 id="UART-简介"><a href="#UART-简介" class="headerlink" title="UART 简介"></a>UART 简介</h2><h3 id="UART-通信格式"><a href="#UART-通信格式" class="headerlink" title="UART 通信格式"></a>UART 通信格式</h3><p>串口全称叫做串行接口，通常也叫做 COM 接口，串行接口指的是数据一个一个的顺序传输，通信线路简单。使用两条线即可实现双向通信，一条用于发送，一条用于接收。串口通信距离远，但是速度相对会低，串口是一种很常用的工业接口。I.MX6U 自带的 UART 外设就是串口的一种，UART 全称是 UniversalAsynchronous Receiver/Trasmitter，也就是异步串行收发器。还有 另 外一 个叫做 USART 的 东 西。 USART 的全称是 Universal Synchronous/Asynchronous Receiver/Transmitter，也就是同步/异步串行收发器。相比 UART 多了 一个同步的功能，在硬件上体现出来的就是多了一条时钟线。一般 USART 是可以作为 UART 使用的，也就是不使用其同步的功能。</p><p>UART 作为串口的一种，其工作原理也是将数据一位一位的进行传输，发送和接收各用一 条线，因此通过 UART 接口与外界相连最少只需要三条线：TXD(发送)、RXD(接收)和 GND(地线)</p><p><strong>空闲位：</strong>数据线在空闲状态的时候为逻辑“1”状态，也就是高电平，表示没有数据线空闲， 没有数据传输</p><p><strong>起始位：</strong>当要传输数据的时候先传输一个逻辑“0”，也就是将数据线拉低，表示开始数据传输</p><p><strong>数据位：</strong>数据位就是实际要传输的数据，数据位数可选择 5~8 位，我们一般都是按照字节传输数据的，一个字节 8 位，因此数据位通常是 8 位的。低位在前，先传输，高位最后传输</p><p><strong>奇偶校验位：</strong>这是对数据中“1”的位数进行奇偶校验用的，可以不使用奇偶校验功能</p><p><strong>停止位：</strong>数据传输完成标志位，停止位的位数可以选择 1 位、1.5 位或 2 位高电平，一般都 选择 1 位停止位</p><p><strong>波特率：</strong>波特率就是 UART 数据传输的速率，也就是每秒传输的数据位数，一般选择 9600、 19200、115200 等</p><h3 id="UART-电平标准"><a href="#UART-电平标准" class="headerlink" title="UART 电平标准"></a>UART 电平标准</h3><p>UART 一般的接口电平有 TTL 和 RS-232，一般开发板上都有 TXD 和 RXD 这样的引脚， 这些引脚低电平表示逻辑 0，高电平表示逻辑 1，这个就是 TTL 电平。RS-232 采用差分线，-3<del>- 15V 表示逻辑 1，+3</del>+15V 表示逻辑 0</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note18-UART串口通信\image-20210227105240199.png" alt="image-20210227105240199"></p><p>图中的模块就是 USB 转 TTL 模块，TTL 接口部分有 VCC、GND、RXD、TXD、 RTS 和 CTS。RTS 和 CTS 基本用不到，使用的时候通过杜邦线和其他模块的 TTL 接口相连即可</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note18-UART串口通信\image-20210227105332047.png" alt="image-20210227105332047"></p><p>RS-232 电平需要 DB9 接口</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note18-UART串口通信\image-20210227105426834.png" alt="image-20210227105426834"></p><p> USB 转串口 TTL 芯片，比如 CH340、PL2303 等。通过这些芯片就可以实现串口 TTL 转 USB。I.MX6UALPHA开发板就使用CH340 芯片来完成UART1和电脑之间的连接，只需要一条USB 线即可</p><h2 id="I-MX6U-UART-简介"><a href="#I-MX6U-UART-简介" class="headerlink" title="I.MX6U UART 简介"></a>I.MX6U UART 简介</h2><p>I.MX6U 一共 有 8 个 UART，其主要特性如下： </p><ol><li>兼容 TIA/EIA-232F 标准，速度最高可到 5Mbit/S</li><li>支持串行 IR 接口，兼容 IrDA，最高可到 115.2Kbit/s</li><li>支持 9 位或者多节点模式(RS-485)</li><li>1 或 2 位停止位</li><li>可编程的奇偶校验(奇校验和偶校验)</li><li>自动波特率检测(最高支持 115.2Kbit/S</li></ol><p>UART 的时钟源是由寄存器 CCM_CSCDR1 的 UART_CLK_SEL(bit)位来选择的，当为 0 的 时候 UART 的时钟源为 pll3_80m(80MHz)，如果为 1 的时候 UART 的时钟源为 osc_clk(24M)， 一般选择 pll3_80m 作为 UART 的时钟源。寄存器 CCM_CSCDR1 的 UART_CLK_PODF(bit5:0) 位是 UART 的时钟分频值，可设置 0<del>63，分别对应 1</del>64 分频，一般设置为 1 分频，因此最终 进入 UART 的时钟为 80MHz</p><h3 id="UART-几个重要的寄存器，-UART-的控制寄存器-1，即-UARTx-UCR1-x-1-8"><a href="#UART-几个重要的寄存器，-UART-的控制寄存器-1，即-UARTx-UCR1-x-1-8" class="headerlink" title="UART 几个重要的寄存器， UART 的控制寄存器 1，即 UARTx_UCR1(x=1~8)"></a>UART 几个重要的寄存器， UART 的控制寄存器 1，即 UARTx_UCR1(x=1~8)</h3><p>寄存器 UARTx_UCR1 我们用到的重要位如下：</p><p><strong>ADBR(bit14)：</strong>自动波特率检测使能位，为 0 的时候关闭自动波特率检测，为 1 的时候使 能自动波特率检测</p><p><strong>UARTEN(bit0)：</strong>UART 使能位，为 0 的时候关闭 UART，为 1 的时候使能 UART</p><h3 id="UART-的控制寄存器-2，即：UARTx-UCR2"><a href="#UART-的控制寄存器-2，即：UARTx-UCR2" class="headerlink" title="UART 的控制寄存器 2，即：UARTx_UCR2"></a>UART 的控制寄存器 2，即：UARTx_UCR2</h3><h3 id="UARTx-UCR3-寄存器"><a href="#UARTx-UCR3-寄存器" class="headerlink" title="UARTx_UCR3 寄存器"></a>UARTx_UCR3 寄存器</h3><h3 id="寄-存-器-UARTx-UFCR-、-UARTx-UBIR-和-UARTx-UBMR-，"><a href="#寄-存-器-UARTx-UFCR-、-UARTx-UBIR-和-UARTx-UBMR-，" class="headerlink" title="寄 存 器 UARTx_UFCR 、 UARTx_UBIR 和 UARTx_UBMR ，"></a>寄 存 器 UARTx_UFCR 、 UARTx_UBIR 和 UARTx_UBMR ，</h3><p>寄 存 器 UARTx_UFCR 中我们要用到的是位 RFDIV(bit9:7)，用来设置参考时钟分频</p><table><thead><tr><th>RFDIV(bit9:7)</th><th>分频值</th></tr></thead><tbody><tr><td>000</td><td>6 分频</td></tr><tr><td>001</td><td>5 分频</td></tr><tr><td>010</td><td>4 分频</td></tr><tr><td>011</td><td>3 分频</td></tr><tr><td>100</td><td>2 分频</td></tr><tr><td>101</td><td>1 分频</td></tr><tr><td>110</td><td>7 分频</td></tr><tr><td>111</td><td>保留</td></tr></tbody></table><p>通过这三个寄存器可以设置 UART 的波特率，波特率的计算公式如下：<br>$$<br>Baud Rate = 𝑅𝑒𝑓 𝐹𝑟𝑒𝑞 /(16 × （𝑈𝐵𝑀𝑅 + 1）/（ 𝑈𝐵𝐼𝑅 + 1） )<br>$$</p><table><thead><tr><th>Ref Freq</th><th>经过分频以后进入 UART 的最终时钟频率</th></tr></thead><tbody><tr><td>UBMR</td><td>寄存器 UARTx_UBMR 中的值</td></tr><tr><td>UBIR</td><td>寄存器 UARTx_UBIR 中的值</td></tr></tbody></table><p>通过 UARTx_UFCR 的 RFDIV 位、UARTx_UBMR 和 UARTx_UBIR 这三者的配合即可得 到我们想要的波特率。比如现在要设置 UART 波特率为 115200，那么可以设置 RFDIV 为 5(0b101)，也就是 1 分频，因此 Ref Freq=80MHz。设置 UBIR=71，UBMR=3124，根据上面的 公式可以得到：<br>$$<br>Baud Rate = 𝑅𝑒𝑓 𝐹𝑟𝑒𝑞 /(16 × （𝑈𝐵𝑀𝑅 + 1）/（ 𝑈𝐵𝐼𝑅 + 1） ) = 80000000 /(16 × （3124 + 1）/（ 71+ 1） ) = 115200<br>$$</p><h3 id="寄存器-UARTx-URXD-和-UARTx-UTXD，"><a href="#寄存器-UARTx-URXD-和-UARTx-UTXD，" class="headerlink" title="寄存器 UARTx_URXD 和 UARTx_UTXD，"></a>寄存器 UARTx_URXD 和 UARTx_UTXD，</h3><p>这两个寄存器分别为 UART 的接 收和发送数据寄存器，这两个寄存器的低八位为接收到的和要发送的数据。读取寄存器UARTx_URXD 即可获取到接收到的数据，如果要通过 UART 发送数据，直接将数据写入到寄 存器 UARTx_UTXD 即可</p><h2 id="UART1-的配置步骤如下"><a href="#UART1-的配置步骤如下" class="headerlink" title="UART1 的配置步骤如下"></a>UART1 的配置步骤如下</h2><ol><li>设置 UART1 的时钟源 设置 UART 的时钟源为 pll3_80m，设置寄存器 CCM_CSCDR1 的 UART_CLK_SEL 位为 0 即可</li><li>初始化 UART1 初始化 UART1 所使用 IO，设置 UART1 的寄存器 UART1_UCR1~UART1_UCR3，设置内容包括波特率，奇偶校验、停止位、数据位等等</li><li>使能 UART1 UART1 初始化完成以后就可以使能 UART1 了，设置寄存器 UART1_UCR1 的位 UARTEN 为 1</li><li>编写 UART1 数据收发函数 编写两个函数用于 UART1 的数据收发操作</li></ol><p>6ULL的UART_URXD寄存器保存这串口接收到的数据。</p><p>UART_UTXD寄存器为发送数据寄存器，如果需要通过串口发送数据，只需要将数据写入到UART_UTXD寄存器里面。</p><p>UART_UCR1~UCR4都是串口的控制寄存器。UART_UCR1的bit0是UART的使能位，为1的时候使能UART。Bit14为自动检测波特率使能位，为1的时候使能波特率自动检测。</p><p>UART_UCR2的bit0为软件复位位。为0的时候复位UART。Bit1使能UART的接收，我们要配置为1。Bit2为发送使能，要设置为1。Bit5设置数据位，0的话表示7位数据位，1的话表示8位数据位。Bit6设置停止位，0的话表示1位停止位，1的话表示2位。Bit7奇偶校验位，为0的时候是偶校验，为1的时候是计校验。Bit8校验使能位，为0的时候关闭校验。</p><p>UART_UCR3的bit2必须为1！！！</p><p>UART_UFCR寄存器的bit9~7设置分频值，UART的时钟源=PLL3/6=480/6=80MHz。CSCDR1寄存器的UART_CLK_SEL位设置UART的时钟源，为0的时候UART时钟源为80MHz</p><p>,为1的时候UART时钟源为24M晶振。CSCDR1寄存器的UART_CLK_PODF位控制分频，一般设置为1分频，因此UART_CLK_ROOT=80MHZ</p><p>UART_UFCR、UART_UBIR和UART_UBMR这三个寄存器决定了串口波特率。</p><p>UART_USR2寄存器的bit0为1的时候表示有数据可以读取。Bit3为1的时候表示数据发送完成</p><p>UART1_TXD使用的IO为UART1_TX_DATA，UART1_RXD所使用的IO为UART1_RX_DATA。</p><p> Putc和puts编译的时候会提示吧报错，要在Makefile中添加-fno-builtin</p><p> SecuCRT打开以后串口接收到乱码，因为Linux默认用UTF-8编码，因此我们需要设置SecureCRT的编码模式为UTF-8</p><p>我们移植的printf不支持浮点计算和输出！！！！！</p><p>文件 bsp_uart.c 中共有 10 个函数，第一个函数 是 uart_init，这个函数是 UART1 初始化函数，用于初始化 UART1 相关的 IO、并且设置 UART1 的波特率、字长、停止位和校验模式等，初始化完成以后就使能 UART1。第二个函数是 uart_io_init，用于初始化 UART1 所使用的 IO。第三个函数是 uart_setbaudrate，这个函数是从 NXP 官方的 SDK 包里面移植过来的，用于设置波特率。只需将要设置的波特率告诉此函 数，此函数就会使用逐次逼近方式来计算出寄存器 UART1_UFCR 的 FRDIV 位、寄存器 UART1_UBIR 和寄存器 UART1_UBMR 这三个的值。第四和第五这两个函数为 uart_disable 和 uart_enable，分别是使能和关闭 UART1。第 6 个函数是 uart_softreset，用于软件复位指定的 UART。 第七个函数是putc，用于通过UART1发送一个字节的数据。第八个函数是puts，用于通过UART1 发送一串数据。第九个函数是 getc，用于通过 UART1 获取一个字节的数据，最后一个函数是 raise，这是一个空函数，防止编译器报错</p><h2 id="I-MX6U-ALPHA-开发板串口-1-硬件原理图"><a href="#I-MX6U-ALPHA-开发板串口-1-硬件原理图" class="headerlink" title="I.MX6U-ALPHA 开发板串口 1 硬件原理图"></a>I.MX6U-ALPHA 开发板串口 1 硬件原理图</h2><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note18-UART串口通信\image-20210227111151868.png" alt="image-20210227111151868"></p><h2 id="编译下载验证"><a href="#编译下载验证" class="headerlink" title="编译下载验证"></a>编译下载验证</h2><p>Makefile 文件在链接的时候加入了数学库， 因为在 bsp_uart.c 中有个函数 uart_setbaudrate，在此函数中使用到了除法运算，因此在链接的时候需要将编译器的数学库也链 接进来。第9行的变量LIBPATH就是数学库的目录，在第56行链接的时候使用了变量LIBPATH。 要用到一些第三方库，那么在连接程序的时候就需要指定这些第三方库所在的目录，Makefile 在链接的时候使用选项“-L”来指定库所在的目录，比如“示 例代码 21.4.1”中第 9 行的变量 LIBPATH 就是指定了我们所使用的编译器库所在的目录</p><p>打开快速连接设置界面，设置好相应的串口参数:</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note18-UART串口通信\image-20210227111602010.png" alt="image-20210227111602010"></p><h1 id="串口格式化函数移植"><a href="#串口格式化函数移植" class="headerlink" title="串口格式化函数移植"></a>串口格式化函数移植</h1><h2 id="串口格式化函数简介"><a href="#串口格式化函数简介" class="headerlink" title="串口格式化函数简介"></a>串口格式化函数简介</h2><p>格式化函数说的是 printf、sprintf 和 scanf 这样的函数，分为格式化输入和格式化输出两类函数。学习 C 语言的时候常常通过 printf 函数在屏幕上显示字符串，通过 scanf 函数从键盘获取输入。这样就有了输入和输出了，实现了最基本的人机交互。在 I.MX6U-ALPHA 开发板上可以将 printf 和 scanf 映射到串口上，就可以使用 SecureCRT 作为开发板的终端，完成与开发板的交互。也可以使用 printf 和 sprintf 来实现各种各样的格式化字符串，方便后续的开发。串口驱动我们上已经编写完成了，而且实现了最基本的字节收发，本章我们就通过移植网上别人已经做好的文件来实现格式化函数</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;I-MX6U-串口简介&quot;&gt;&lt;a href=&quot;#I-MX6U-串口简介&quot; class=&quot;headerlink&quot; title=&quot;I.MX6U 串口简介&quot;&gt;&lt;/a&gt;I.MX6U </summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note17-EPIT定时器，按键消抖，高精度延时</title>
    <link href="https://chenzhan666.coding.me/2021/02/26/note17-EPIT%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/"/>
    <id>https://chenzhan666.coding.me/2021/02/26/note17-EPIT%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-02-25T17:03:15.000Z</published>
    <updated>2021-02-26T09:55:35.811Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="EPIT-定时器简介"><a href="#EPIT-定时器简介" class="headerlink" title="EPIT 定时器简介"></a>EPIT 定时器简介</h1><p>EPIT 的全称是：Enhanced Periodic Interrupt Timer，直译过来就是增强的周期中断定时器， 它主要是完成周期性中断定时的</p><ol><li>EPIT是32位的一个向下计数器</li><li>EPIT的时钟源可以选择，我们选择ipg_clk=66MHz</li><li>可以对时钟源进行分频，12位的分频器，0<del>4095分别代表1</del>4096分频</li><li>开启定时器以后，计数寄存器会每个时钟减1，如果和比较寄存器里面的值相等的话就会触发中断</li></ol><p>EPIT有两种工作模式：Set-add-forget，一个是free-runing</p><ol start="5"><li>6ULL有两个EPIT定时器</li></ol><p>EPIT_CR寄存器用于配置EPIT</p><p>EPIT 是一个 32 位定时器，在处理器几乎不用介入的情况下提供精准的定时中断，软件使 能以后 EPIT 就会开始运行，EPIT 定时器有如下特点：</p><ol><li>时钟源可选的 32 位向下计数器</li><li>12 位的分频值</li><li>当计数值和比较值相等的时候产生中断</li></ol><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note17-EPIT定时器实验\image-20210226011448197.png" alt="image-20210226011448197"></p><p>①、这是个多路选择器，用来选择 EPIT 定时器的时钟源，EPIT 共有 3 个时钟源可选择， ipg_clk、ipg_clk_32k 和 ipg_clk_highfreq</p><p>②、这是一个 12 位的分频器，负责对时钟源进行分频，12 位对应的值是 0<del>4095，对应着 1</del>4096 分频</p><p>③、经过分频的时钟进入到 EPIT 内部，在 EPIT 内部有三个重要的寄存器：计数寄存器 (EPIT_CNR)、加载寄存器(EPIT_LR)和比较寄存器(EPIT_CMPR)，这三个寄存器都是 32 位的。 EPIT 是一个向下计数器，也就是说给它一个初值，它就会从这个给定的初值开始递减，直到减为 0，计数寄存器里面保存的就是当前的计数值。如果 EPIT 工作在 set-and-forget 模式下，当计数寄存器里面的值减少到 0，EPIT 就会重新从加载寄存器读取数值到计数寄存器里面，重新开 始向下计数。比较寄存器里面保存的数值用于和计数寄存器里面的计数值比较，如果相等的话 就会产生一个比较事件</p><p>④、比较器</p><p>⑤、EPIT 可以设置引脚输出，如果设置了的话就会通过指定的引脚输出信号</p><p>⑥、产生比较中断，也就是定时中断。 EPIT 定时器有两种工作模式：set-and-forget 和 free-running，这两个工作模式的区别如下： set-and-forget 模式：EPITx_CR(x=1，2)寄存器的 RLD 位置 1 的时候 EPIT 工作在此模式 下，在此模式下 EPIT 的计数器从加载寄存器 EPITx_LR 中获取初始值，不能直接向计数器寄存器写入数据。不管什么时候，只要计数器计数到 0，那么就会从加载寄存器 EPITx_LR 中重新加载数据到计数器中，周而复始。 free-running 模式：EPITx_CR 寄存器的 RLD 位清零的时候 EPIT 工作在此模式下，当计数器计数到0以后会重新从0XFFFFFFFF开始计数，并不是从加载寄存器EPITx_LR中获取数据</p><p>EPIT_CR bit0为1，设置EPIT使能，bit1为1，设置计数器的初始值为记载寄存器的值。Bit2为1使能比较中断，bit3为1设置定时器工作在set-and-forget模式下。Bit15~bit4设置分频值。Bit25:24设置时钟源的选择，我们设置为1，那么EPIT的时钟源就为ipg_clock=66MHz </p><p>EPIT_SR寄存器，只有bit0有效，表示中断状态，写1清零。当OCIF位为1的时候表示中断发生，为0的时候表示中断未发生。我们处理完定时器中断以后一定要清除中断标志位</p><p>EPIT_LR寄存器设置计数器的加载值。计数器每次计时到0以后就会读取LR寄存器的值重新开始计时</p><p>CMPR比较计数器，当计数器的值和CMPR相等以后就会产生比较中断</p><p>使用EPIT实现500ms周期的定时器。我们在EPIT中断服务函数里面让LED灯亮灭</p><h1 id="EPIT-的配置寄存器-EPITx-CR"><a href="#EPIT-的配置寄存器-EPITx-CR" class="headerlink" title="EPIT 的配置寄存器 EPITx_CR"></a>EPIT 的配置寄存器 EPITx_CR</h1><p>CLKSRC(bit25:24)：EPIT 时钟源选择位，为 0 的时候关闭时钟源，1 的时候选择选择 Peripheral 时钟(ipg_clk)，为 2 的时候选择 High-frequency 参考时钟(ipg_clk_highfreq)，为 3 的时 候选择 Low-frequency 参考时钟(ipg_clk_32k)。我们设置为1，也就是选择 ipg_clk 作为 EPIT 的时钟源，ipg_clk=66MHz</p><p>PRESCALAR(bit15:4)：EPIT 时钟源分频值，可设置范围 0<del>4095，分别对应 1</del>4096 分频RLD(bit3)：EPIT 工作模式，为 0 的时候工作在 free-running 模式，为 1 的时候工作在 setand-forget 模式，设置为 1，也就是工作在 set-and-forget 模式</p><p>OCIEN(bit2)：比较中断使能位，为 0 的时候关闭比较中断，为 1 的时候使能比较中断，要使能比较中断</p><p>ENMOD(bit1)：设置计数器初始值，为 0 时计数器初始值等于上次关闭 EPIT 定时器以后计数器里面的值，为 1 的时候来源于加载寄存器</p><p>EN(bit0)：EPIT 使能位，为 0 的时候关闭 EPIT，为 1 的时候使能 EPIT。 </p><p>寄存器 EPITx_SR 结构体：寄存器 EPITx_SR 只有一个位有效，那就是 OCIF(bit0)，这个位是比较中断标志位，为 0 的时候表示没有比较事件发生，为 1 的时候表示有比较事件发生。当比较中断发生以后需要手动清除此位，此位是写 1 清零的</p><p>寄存器 EPITx_LR、EPITx_CMPR 和 EPITx_CNR 分别为加载寄存器、比较寄存器和计数寄存器，这三个寄存器都是用来存放数据的</p><p>EPIT 的配置步骤如下：</p><ol><li>设置 EPIT1 的时钟源 设置寄存器 EPIT1_CR 寄存器的 CLKSRC(bit25:24)位，选择 EPIT1 的时钟源</li><li>设置分频值设置寄存器 EPIT1_CR 寄存器的 PRESCALAR(bit15:4)位，设置分频值</li><li>设置工作模式设置寄存器 EPIT1_CR 的 RLD(bit3)位，设置 EPTI1 的工作模式</li><li>设置计数器的初始值来源设置寄存器 EPIT1_CR 的 ENMOD(bit1)位，设置计数器的初始值来源</li><li>使能比较中断我们要使用到比较中断，因此需要设置寄存器 EPIT1_CR 的 OCIEN(bit2)位，使能比较中断</li><li>设置加载值和比较值设置寄存器 EPIT1_LR 中的加载值和寄存器 EPIT1_CMPR 中的比较值，通过这两个寄存器就可以决定定时器的中断周期</li><li>EPIT1 中断设置和中断服务函数编写 使能 GIC 中对应的 EPIT1 中断，注册中断服务函数，如果需要的话还可以设置中断优先 级。最后编写中断服务函数</li><li>使能 EPIT1 定时器 配置好 EPIT1 以后就可以使能 EPIT1 了，通过寄存器 EPIT1_CR 的 EN(bit0)位来设置。 通过以上几步我们就配置好 EPIT 了，通过 EPIT 的比较中断来实现 LED0 的翻转</li></ol><h1 id="定时器按键消抖"><a href="#定时器按键消抖" class="headerlink" title="定时器按键消抖"></a>定时器按键消抖</h1><p>直接用延时函数来实现消抖会浪费 CPU 性能，因为在延时函数里面 CPU 什么都做不了。 如果按键使用中断的话更不能在中断里面使用延时函数，因为中断服务函数要快进快出</p><p>Linux 驱动里面按键消抖的做法—使用定时器来实现按键消抖</p><h2 id="定时器按键消抖简介"><a href="#定时器按键消抖简介" class="headerlink" title="定时器按键消抖简介"></a>定时器按键消抖简介</h2><p>在按键按下以后延时一段时间再 去读取按键值，如果此时按键值还有效那就表示这是一次有效的按键，中间的延时就是消抖, EPIT 定时器设置好定时时间，然后 CPU 可以做其他事情，定时时间到了以后就会触发中断，然后在中断中做相应的处理即可</p><p>即借助定时器来实现消抖，按键采用中断驱动方式，当按键按下以后触发按键中断，在 按键中断中开启一个定时器，定时周期为 10ms，当定时时间到了以后就会触发定时器中断，最 后在定时器中断处理函数中读取按键的值，如果按键值还是按下状态那就表示这是一次有效的按键</p><p>设置按键为下降沿触发，因 此会在 t1、t2 和 t3 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中 断，所以会在 t1、t2 和 t3 这三个时刻开器定时器中断。但是 t1<del>t2 和 t2</del>t3 这两个时间段是小于 我们设置的定时器中断周期(也就是消抖时间，比如 10ms)，所以虽然 t1 开启了定时器，但是定 时器定时时间还没到呢 t2 时刻就重置了定时器，最终只有 t3 时刻开启的定时器能完整的完成 整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现 按键防抖的原理，Linux 里面的按键驱动用的就是这个原理</p><p>使用 EPIT1 来配合按键 KEY 来实现具体的消抖，步骤如下：</p><ol><li>配置按键 IO 中断</li><li>初始化消抖用的定时器</li><li>编写中断处理函数</li></ol><p>文件 bsp_keyfilter.c 一共有 6 个函数。filterkey_init 是初始化函数，首先初始化了 KEY 所使用的 UART1_CTS 这个 IO，设置这个 IO 的中断模式，并且注册中断处理函数，最后调用函数 filtertimer_init 初始化定时器 EPIT1 定时周期为 10ms。函数 filtertimer_init 是定时器 EPIT1的初始化函数。函数 filtertimer_stop 和 filtertimer_restart 分别是 EPIT1 的关闭和重启函数。 filtertimer_irqhandler 是 EPTI1 的中断处理函数，此函数里面就是按键要做的工作。函数 gpio1_16_31_irqhandler 是 GPIO1_IO18 的中断处理函数，工作是重启定时器 EPIT1</p><h1 id="高精度延时"><a href="#高精度延时" class="headerlink" title="高精度延时"></a>高精度延时</h1><p>延时函数是很常用的 API 函数，但是使用循环来实现的延时函数不准确，误差会很大。延时函数肯定是越精确越好，这样延时函数就可 以使用在某些对时序要求严格的场合。要求严格的话就使用硬件定时器</p><h2 id="GPT-定时器"><a href="#GPT-定时器" class="headerlink" title="GPT 定时器"></a>GPT 定时器</h2><p>GPT 定时器是一个 32 位向上定时器(也就是从 0X00000000 开始向上递增计数)，GPT 定时 器也可以跟一个值进行比较，当计数器值和这个值相等的话就发生比较事件，产生比较中断。 GPT 定时器有一个 12 位的分频器，可以对 GPT 定时器的时钟源进行分频，GPT 定时器特性如下：</p><ol><li>一个可选时钟源的 32 位向上计数器</li><li>两个输入捕获通道，可以设置触发方式</li><li>三个输出比较通道，可以设置输出模式</li><li>可以生成捕获中断、比较中断和溢出中断</li><li>计数器可以运行在重新启动(restart)或(自由运行)free-run 模式</li></ol><p>共有五个时钟源，分别为：ipg_clk_24M、GPT_CLK(外部时钟)、 ipg_clk、ipg_clk_32k 和 ipg_clk_highfreq</p><h3 id="重新启动-restart-模式"><a href="#重新启动-restart-模式" class="headerlink" title="重新启动(restart)模式"></a>重新启动(restart)模式</h3><p>当 GPTx_CR(x=1，2)寄存器的 FRR 位清零的时候 GPT 工作在此 模式。在此模式下，当计数值和比较寄存器中的值相等的话计数值就会清零，然后重新从 0X00000000 开始向上计数，只有比较通道 1 才有此模式！向比较通道 1 的比较寄存器写入任何 数据都会复位 GPT 计数器。对于其他两路比较通道（通道 2 和 3），当发生比较事件以后不会 复位计数器</p><h3 id="自由运行-free-run-模式"><a href="#自由运行-free-run-模式" class="headerlink" title="自由运行(free-run)模式"></a>自由运行(free-run)模式</h3><p>当 GPTx_CR(x=1，2)寄存器的 FRR 位置 1 时候 GPT 工作在此模 式下，此模式适用于所有三个比较通道，当比较事件发生以后并不会复位计数器，而是继续计 数，直到计数值为 0XFFFFFFFF，然后重新回滚到 0X00000000</p><h3 id="GPT-定时器几个重要的寄存器"><a href="#GPT-定时器几个重要的寄存器" class="headerlink" title="GPT 定时器几个重要的寄存器"></a>GPT 定时器几个重要的寄存器</h3><h4 id="GPT-的配置寄存器-GPTx-CR"><a href="#GPT-的配置寄存器-GPTx-CR" class="headerlink" title="GPT 的配置寄存器 GPTx_CR"></a>GPT 的配置寄存器 GPTx_CR</h4><p>重要的位：</p><p>SWR(bit15)：复位 GPT 定时器</p><p>FRR(bit9)：运行模式选择</p><p>CLKSRC(bit8:6)：GPT 定时器时钟源选择位</p><p>ENMOD(bit1)：GPT 使能模式</p><p>EN(bit)：GPT 使能位</p><h4 id="GPT-定时器的分频寄存器-GPTx-PR"><a href="#GPT-定时器的分频寄存器-GPTx-PR" class="headerlink" title="GPT 定时器的分频寄存器 GPTx_PR"></a>GPT 定时器的分频寄存器 GPTx_PR</h4><p>重要的位</p><p>PRESCALER(bit11:0)：这就是 12 位分频值， 可设置 0<del>4095，分别对应 1</del>4096 分频</p><h4 id="GPT-定时器的状态寄存器-GPTx-SR"><a href="#GPT-定时器的状态寄存器-GPTx-SR" class="headerlink" title="GPT 定时器的状态寄存器 GPTx_SR"></a>GPT 定时器的状态寄存器 GPTx_SR</h4><p>重要的位</p><p>ROV(bit5：回滚标志位</p><p>IF2~IF1(bit4:3)：输入捕获标志位</p><p>OF3~OF1(bit2:0)：输出比较中断标志位</p><h4 id="GPT-定时器的计数寄存器-GPTx-CNT"><a href="#GPT-定时器的计数寄存器-GPTx-CNT" class="headerlink" title="GPT 定时器的计数寄存器 GPTx_CNT"></a>GPT 定时器的计数寄存器 GPTx_CNT</h4><p>寄存器保存着 GPT 定时器的当前 计数值</p><h4 id="GPT-定时器的输出比较寄存器-GPTx-OCR"><a href="#GPT-定时器的输出比较寄存器-GPTx-OCR" class="headerlink" title="GPT 定时器的输出比较寄存器 GPTx_OCR"></a>GPT 定时器的输出比较寄存器 GPTx_OCR</h4><p>每个输出比较通道对应一个 输出比较寄存器，因此一个 GPT 定时器有三个 OCR 寄存器</p><h2 id="定时器实现高精度延时原理"><a href="#定时器实现高精度延时原理" class="headerlink" title="定时器实现高精度延时原理"></a>定时器实现高精度延时原理</h2><p>高精度延时函数的实现要借助硬件定时器。如果设置 GPT 定时器的时钟源为 ipg_clk=66MHz，设置 66 分频，那么进入 GPT 定时器的最终时钟频率就是 66/66=1MHz，周期为 1us。GPT 的计数器每计一个数就表示“过去” 了 1us。如果计 10 个数就表示“过去”了 10us。通过读取寄存器 GPTx_CNT 中的值就知道计了几个数，比如现在要延时 100us，那么进入延时函数以后纪录下寄存器 GPTx_CNT 中的值为 200， 当 GPTx_CNT 中的值为 300 (过去了100个数)的时候就表示 100us 过去了，也就是延时结束。GPTx_CNT 是个 32 位寄存器，如果时钟为 1MHz 的话，GPTx_CNT 最多可以实现 0XFFFFFFFFus=4294967295us ≈4294s≈72min。也就是说 72 分钟以后 GPTx_CNT 寄存器就会回滚到 0X00000000，也就是溢出，所以需要在延时函数中要处理溢出的情况。高精度延时的实现步骤如下：</p><ol><li>设置 GPT1 定时器 首先设置 GPT1_CR 寄存器的 SWR(bit15)位来复位寄存器 GPT1。复位完成以后设置寄存器 GPT1_CR 寄存器的 CLKSRC(bit8:6)位，选择 GPT1 的时钟源为 ipg_clk。设置定时器 GPT1 的工作模式</li><li>设置 GPT1 的分频值 设置寄存器 GPT1_PR 寄存器的 PRESCALAR(bit111:0)位，设置分频值</li><li>设置 GPT1 的比较值 如果要使用 GPT1 的输出比较中断，那么 GPT1 的输出比较寄存器 GPT1_OCR1 的值可以 根据所需的中断时间来设置。如不使用比较输出中断，所以将 GPT1_OCR1 设置为最大值，即：0XFFFFFFFF</li><li>使能 GPT1 定时器 设置好 GPT1 定时器以后就可以使能了，设置 GPT1_CR 的 EN(bit0)位为 1 来使能 GPT1 定时器</li><li>编写延时函数 GPT1定时器已经开始运行了，可以根据前面介绍的高精度延时函数原理来编写延时函数， 针对 us 和 ms 延时分别编写两个延时函数</li></ol><p>文件 bsp_delay.c 中一共有 5 个函数，分别为：delay_init、delayus、delayms 、delay_short 和 delay。函数 delay_init 是延时初始化函数，主要用于初始化 GPT1 定时器，设置其时钟源、分频值和输出比较寄存器值。 GPT1 的中断处理函数 gpt1_irqhandler。函数 delayus 和 delayms 就是 us 级和 ms 级的高精度延时函数，delayus 函数处理 GPT1 计数器溢出的情况。函数 delayus 只有一个参数 usdelay，这个参数就是要延时的 us 数。delayms 函数很简单，就是对 delayus(1000)的多次叠加，此函数也只有一个参数 msdelay，也就是要延时的 ms 数</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;EPIT-定时器简介&quot;&gt;&lt;a href=&quot;#EPIT-定时器简介&quot; class=&quot;headerlink&quot; title=&quot;EPIT 定时器简介&quot;&gt;&lt;/a&gt;EPIT 定时器简介</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note16 GPIO中断实验</title>
    <link href="https://chenzhan666.coding.me/2021/02/21/note16-GPIO%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C%E5%AE%9E%E9%AA%8C/"/>
    <id>https://chenzhan666.coding.me/2021/02/21/note16-GPIO%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-02-20T17:16:28.000Z</published>
    <updated>2021-02-26T09:56:49.058Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Cortex-A7-中断系统详解"><a href="#Cortex-A7-中断系统详解" class="headerlink" title="Cortex-A7 中断系统详解"></a>Cortex-A7 中断系统详解</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>中断向量表是一个表，这个表里面存放的是中断向量。中断服务程序的入口地址或存放中断服务程序的首地址成为中断向量，因此中断向量表是一系列中断服务程序入口地址组成的表。这些中断服务程序(函数)在中断向量表中的位置是由半导体厂商定好的，当某个中断被触发以后就会自动跳转到中断向量表中对应的中断服务程序(函数)入口地址处。中断向量表在整个程序的最前面</p><p>中断向量表都是链接到代码的最前面，比如一般 ARM 处理器都是从地址 0X00000000 开始执行指令的，那么中断向量表就是从 0X00000000 开始存放的。第一条中断向量，存放的是栈顶指针，接下来是第 2 行复位中断复位函数 Reset_Handler 的入口地址，依次类推</p><p>Cortex-A中断向量表有8个中断，其中重点关注IRQ。Cortex-A的中断向量表需要用户自己去定义</p><table><thead><tr><th>向量地址</th><th>中断类型</th><th>中断模式</th></tr></thead><tbody><tr><td>0X00</td><td>复位中断(Rest)</td><td>特权模式(SVC)</td></tr><tr><td>0X04</td><td>未定义指令中断(Undefined Instruction)</td><td>未定义指令中止模式(Undef)</td></tr><tr><td>0X08</td><td>软中断(Software Interrupt,SWI)</td><td>特权模式(SVC)</td></tr><tr><td>0X0C</td><td>指令预取中止中断(Prefetch Abort)</td><td>中止模式</td></tr><tr><td>0X10</td><td>数据访问中止中断(Data Abort)</td><td>中止模式</td></tr><tr><td>0X14</td><td>未使用(Not Used)</td><td>未使用</td></tr><tr><td>0X18</td><td>IRQ 中断(IRQ Interrupt)</td><td>外部中断模式(IRQ)</td></tr><tr><td>0X1C</td><td>FIQ 中断(FIQ Interrupt)</td><td>快速中断模式(FIQ)</td></tr></tbody></table><p>IRQ 中断， Cortex-A 内核 CPU 的所有外部中 断都属于这个 IQR 中断，当任意一个外部中断发生的时候都会触发 IRQ 中断。在 IRQ 中断服 务函数里面就可以读取指定的寄存器来判断发生的具体是什么中断，进而根据具体的中断做出相应的处理</p><ul><li>外部中断和 IRQ 中断关系</li></ul><ol><li>复位中断(Rest)，CPU 复位以后就会进入复位中断，我们可以在复位中断服务函数里面 做一些初始化工作，比如初始化 SP 指针、DDR 等等</li><li>未定义指令中断(Undefined Instruction)，如果指令不能识别的话就会产生此中断</li><li>软中断(Software Interrupt,SWI)，由 SWI 指令引起的中断，Linux 的系统调用会用 SWI 指令来引起软中断，通过软中断来陷入到内核空间</li><li>指令预取中止中断(Prefetch Abort)，预取指令的出错的时候会产生此中断</li><li>数据访问中止中断(Data Abort)，访问数据出错的时候会产生此中断</li><li>IRQ 中断(IRQ Interrupt)，外部中断，前面已经说了，芯片内部的外设中断都会引起此 中断的发生</li><li>FIQ 中断(FIQ Interrupt)，快速中断，如果需要快速处理中断的话就可以使用此中</li></ol><h3 id="中断向量偏移"><a href="#中断向量偏移" class="headerlink" title="中断向量偏移"></a>中断向量偏移</h3><p>一般ARM从0X000000000地址开始运行，对于STM32我们设置连接首地址为0X8000000</p><p>如果代码需要从0X8000000开始运行，那么需要告诉一下soc内核。也就是设置中断向量偏移。设置SCB的VTOR寄存器为新的中断向量表起始地址即可</p><h3 id="GIC-内嵌向量中断控制器"><a href="#GIC-内嵌向量中断控制器" class="headerlink" title="GIC(内嵌向量中断控制器)"></a>GIC(内嵌向量中断控制器)</h3><p>Holds the physical base address of the memory-mapped GIC registers保存内存映射的GIC寄存器的物理基址（首地址）</p><p>NVIC就是中断管理机构。使能和关闭指定的中断、设置中断优先级</p><p>GIC 接收众多的外部中断，然后对其进行处理，最终就只通过四个信号 报给 ARM 内核，这四个信号的含义如下</p><table><thead><tr><th>VFIQ</th><th>虚拟快速FIQ</th></tr></thead><tbody><tr><td>VIRQ</td><td>虚拟快速IRQ</td></tr><tr><td>FIQ</td><td>快速中断IRQ</td></tr><tr><td>IRQ</td><td>外部中断IRQ</td></tr></tbody></table><p>左侧部分就是中断源，中间部分就是 GIC 控制器，最右侧就是中断控制器向处理器内核发送中断信息，GIC 将众多的中断源分为分为三类</p><ol><li>SPI(Shared Peripheral Interrupt),共享中断，顾名思义，所有 Core 共享的中断，这个是最 常见的，那些外部中断都属于 SPI 中断(注意！不是 SPI 总线那个中断) 。比如按键中断、串口 中断等等，这些中断所有的 Core 都可以处理，不限定特定 Core</li><li>PPI(Private Peripheral Interrupt)，私有中断，我们说了 GIC 是支持多核的，每个核肯定 有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断</li><li>SGI(Software-generated Interrupt)，软件中断，由软件触发引起的中断，通过向寄存器 GICD_SGIR 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信</li></ol><h4 id="中断ID"><a href="#中断ID" class="headerlink" title="中断ID"></a>中断ID</h4><p>中断源有很多，为了区分这些不同的中断源肯定要给他们分配一个唯一 ID，这些 ID 就是 中断 ID。每一个 CPU 最多支持 1020 个中断 ID，中断 ID 号为 ID0~ID1019。这 1020 个 ID 包 含了 PPI、SPI 和 SGI</p><ul><li><p>1020 个 ID 分 配如下：</p><table><thead><tr><th>ID0~ID15</th><th>这 16 个 ID 分配给 SG</th></tr></thead><tbody><tr><td>ID16~ID31</td><td>这 16 个 ID 分配给 PPI</td></tr><tr><td>ID32~ID1019</td><td>这 988 个 ID 分配给 SPI，像 GPIO 中断、串口中断等这些外部中断</td></tr></tbody></table></li></ul><p>I.MX6U 的总共 使用了 128 个中断 ID，加上前面属于 PPI 和 SGI 的 32 个 ID，I.MX6U 的中断源共有 128+32=160 个，这 128 个中断 ID 对应的中断在《I.MX6ULL 参考手册》的“3.2 CortexA7 interrupts”小节</p><ul><li><p>部分中断源查阅自 《I.MX6ULL 参考手册》</p><table><thead><tr><th>IRQ</th><th>ID</th><th>中断源</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>32</td><td>boot</td><td>用于在启动异常的时候通知内核</td></tr><tr><td>1</td><td>33</td><td>ca7_platform</td><td>DAP中断，调试端口访问请求中断</td></tr><tr><td>2</td><td>34</td><td>sdma</td><td>SDMA中断</td></tr><tr><td>3</td><td>35</td><td>tsc</td><td>TSC(触摸)中断</td></tr><tr><td>4</td><td></td><td>snvs_lp_wrapper   snvs_hp_wrapper</td><td>SNVS中断</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>124</td><td>156</td><td>无</td><td>保留</td></tr><tr><td>125</td><td>157</td><td>无</td><td>保留</td></tr><tr><td>126</td><td>158</td><td>无</td><td>保留</td></tr><tr><td>127</td><td>159</td><td>pmu</td><td>PMU中断</td></tr></tbody></table></li></ul><h4 id="GIC-逻辑分块"><a href="#GIC-逻辑分块" class="headerlink" title="GIC 逻辑分块"></a>GIC 逻辑分块</h4><p>GIC 架构分为了两个逻辑块：Distributor 和 CPU Interface，也就是分发器端和 CPU 接口端</p><ul><li><p>Distributor(分发器端)：此逻辑块负责处理各个中断事件的分发问题，也就是中断事件应该发送到哪个 CPU Interface 上去。分发器收集所有的中断源，可以控制每个中断的优先级，它总是将优先级最高的中断事件发送到 CPU 接口端。分发器端要做的主要工作如下：</p><ol><li>全局中断使能控制</li><li>控制每一个中断的使能或者关闭</li><li>设置每个中断的优先级</li><li>设置每个中断的目标处理器列表</li><li>设置每个外部中断的触发模式：电平触发或边沿触发</li><li>设置每个中断属于组 0 还是组 1</li></ol></li><li><p>CPU Interface(CPU 接口端)：CPU 接口端是和 CPU Core 相连接的，因此每个 CPU Core 都可以在 GIC 中找到一个与之对应的 CPU Interface。CPU 接口端就是分发器和 CPU Core 之间的桥梁，CPU 接口端主要工作如下： ①、</p><ol><li>使能或者关闭发送到 CPU Core 的中断请求信号</li><li>应答中断</li><li>通知中断处理完成</li><li>设置优先级掩码，通过掩码来设置哪些中断不需要上报给 CPU Core</li><li>定义抢占策略</li><li>当多个中断到来的时候，选择优先级最高的中断通知给 CPU Core</li></ol></li></ul><p>结构体 GIC_Type 就是 GIC 控制器，列举出了 GIC 控制器的所有寄存器，可以通过结构体 GIC_Type 来访问 GIC 的所有寄存器。GIC 的分发器端相关寄存器，其相对于 GIC 基地址偏移为 0X1000，因此我们获取到 GIC 基地址以后只需要加上 0X1000 即可访问 GIC 分发器端寄存器</p><h4 id="CP15-协处理器"><a href="#CP15-协处理器" class="headerlink" title="CP15 协处理器"></a>CP15 协处理器</h4><p>CP15 协处理器一般用于存储系统管理，但是在中断中也会使用到，CP15 协处理器一共有 16 个 32 位寄存器。CP15 协处理器的访问通过如下另个指令完成：</p><table><thead><tr><th>MRC</th><th>将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中</th></tr></thead><tbody><tr><td>MCR</td><td>将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中</td></tr></tbody></table><p>MCR 指令格式如下</p><p><code>MCR&#123;cond&#125; p15,&lt; opcl &gt;,&lt; Rt &gt;,&lt; CRn &gt;,&lt; CRm &gt;,&lt; opc2 &gt;</code></p><table><thead><tr><th>cond</th><th>指令执行的条件码，如果忽略的话就表示无条件执行</th></tr></thead><tbody><tr><td>opcl</td><td>协处理器要执行的操作码</td></tr><tr><td>Rt</td><td>ARM 源寄存器，要写入到 CP15 寄存器的数据就保存在此寄存器中</td></tr><tr><td>CRn</td><td>CP15 协处理器的目标寄存器</td></tr><tr><td>CRm</td><td>协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将 CRm 设置为 C0，否则结果不可预测</td></tr><tr><td>opc2</td><td>可选的协处理器特定操作码，当不需要的时候要设置为 0</td></tr></tbody></table><p>MRC 的指令格式和 MCR 一样，只不过在 MRC 指令中 Rt 就是目标寄存器，也就是从 CP15 指定寄存器读出来的数据会保存在 Rt 中。而 CRn 就是源寄存器，也就是要读取的写处 理器寄存器。 假如我们要将 CP15 中 C0 寄存器的值读取到 R0 寄存器中，那么就可以使用如下命令：</p><p><code>MRC p15, 0, r0, c0, c0, 0</code></p><p>CP15 协处理器有 16 个 32 位寄存器，c0~c15，在使用 MRC 或者 MCR 指令访问这 16 个 寄存器的时候，指令中的 CRn、opc1、CRm 和 opc2 通过不同的搭配，其得到的寄存器含义是 不同的，来看一下 c0、c1、c12 和 c15 这四个寄存器</p><h5 id="c0-寄存器"><a href="#c0-寄存器" class="headerlink" title="c0 寄存器"></a>c0 寄存器</h5><p>当 MRC/MCR 指令中的 CRn=c0，opc1=0，CRm=c0，opc2=0 的时候就表示 此时的 c0 就是 MIDR 寄存器，也就是主 ID 寄存器，这个也是 c0 的基本作用。对于 Cortex-A7 内核来说，c0 作为 MDIR 寄存器的时候其含义如图所示：</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note16-GPIO中断实验实验\image-20210225164458052.png" alt="image-20210225164458052"></p><table><thead><tr><th>bit31:24</th><th>厂商编号，0X41，ARM</th></tr></thead><tbody><tr><td>bit23:20</td><td>内核架构的主版本号，ARM 内核版本一般使用 rnpn 来表示，比如 r0p1，其中 r0 后面的 0 就是内核架构主版本号</td></tr><tr><td>bit19:16</td><td>架构代码，0XF，ARMv7 架构</td></tr><tr><td>bit15:4</td><td>内核版本号，0XC07，Cortex-A7 MPCore 内核</td></tr><tr><td>bit3:0</td><td>内核架构的次版本号，rnpn 中的 pn，比如 r0p1 中 p1 后面的 1 就是次版本号</td></tr></tbody></table><h5 id="c1-寄存器"><a href="#c1-寄存器" class="headerlink" title="c1 寄存器"></a>c1 寄存器</h5><p>原理省略</p><p>如果要读写 SCTLR 的话，就可以使用如下命令： </p><p><code>MRC p15, 0, , c1, c0, 0 ;读取 SCTLR 寄存器，数据保存到 Rt 中</code></p><p><code>MCR p15, 0, , c1, c0, 0 ;将 Rt 中的数据写到 SCTLR(c1)寄存器中</code></p><h5 id="c12-寄存器"><a href="#c12-寄存器" class="headerlink" title="c12 寄存器"></a>c12 寄存器</h5><p>原理省略</p><p>设置 VBAR 为 0X87800000，设置命令如下：</p><p> <code>ldr r0, =0X87800000 ; r0=0X87800000</code> </p><p><code>MCR p15, 0, r0, c12, c0, 0 ;将 r0 里面的数据写入到 c12 中，即 c12=0X87800000</code></p><h5 id="c15-寄存器"><a href="#c15-寄存器" class="headerlink" title="c15 寄存器"></a>c15 寄存器</h5><p>原理省略</p><p>获取到 GIC 基地址：</p><p> <code>MRC p15, 4, r1, c15, c0, 0 ; 获取 GIC 基础地址，基地址保存在 r1 中</code></p><p>获取当前中断 ID 的代码如下： </p><p><code>MRC p15, 4, r1, c15, c0, 0 ;获取 GIC 基地址</code> </p><p><code>ADD r1, r1, #0X2000 ;GIC 基地址加 0X2000 得到 CPU 接口端寄存器起始地址</code></p><p>`LDR r0, [r1, #0XC] ;读取 CPU 接口端起始地址+0XC 处的寄存器值，也就是寄存器 GIC_IAR 的值</p><h4 id="中断使能"><a href="#中断使能" class="headerlink" title="中断使能"></a>中断使能</h4><p>中断使能包括两部分，一个是 IRQ 或者 FIQ 总中断使能，另一个就是 ID0~ID1019 这 1020 个中断源的使能</p><h5 id="IRQ-和-FIQ-总中断使能"><a href="#IRQ-和-FIQ-总中断使能" class="headerlink" title="IRQ 和 FIQ 总中断使能"></a>IRQ 和 FIQ 总中断使能</h5><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>cpsid i</td><td>禁止 IRQ 中断</td></tr><tr><td>cpsie i</td><td>使能 IRQ 中断</td></tr><tr><td>cpsid f</td><td>禁止 FIQ 中断</td></tr><tr><td>cpsie f</td><td>使能 FIQ 中断</td></tr></tbody></table><h5 id="ID0-ID1019-中断使能和禁止"><a href="#ID0-ID1019-中断使能和禁止" class="headerlink" title="ID0~ID1019 中断使能和禁止"></a>ID0~ID1019 中断使能和禁止</h5><p>GIC 寄存器 GICD_ISENABLERn 和 GICD_ ICENABLERn 用来完成外部中断的使能和禁 止，对于 Cortex-A7 内核来说中断 ID 只使用了 512 个。一个 bit 控制一个中断 ID 的使能，那么 就需要 512/32=16 个 GICD_ISENABLER 寄存器来完成中断的使能。同理，也需要 16 个 GICD_ICENABLER 寄存器来完成中断的禁止。其中 GICD_ISENABLER0 的 bit[15:0]对应 ID15<del>0 的 SGI 中断，GICD_ISENABLER0 的 bit[31:16]对应 ID31</del>16 的 PPI 中断。剩下的 GICD_ISENABLER1~GICD_ISENABLER15 就是控制 SPI 中断的</p><h4 id="中断优先级设置"><a href="#中断优先级设置" class="headerlink" title="中断优先级设置"></a>中断优先级设置</h4><h5 id="优先级数配置"><a href="#优先级数配置" class="headerlink" title="优先级数配置"></a>优先级数配置</h5><p>Cortex-A7 的中断优先级可以分为抢占优先级和子优先级，Cortex-A7 最多可以支持 256 个优先级，数字越小，优先级越高！I.MX6U 选择了 32 个优先级。在使用中断的时候需要初始化 GICC_PMR 寄存器，此寄存器用来决定使用几级优先级，寄存器结构如图 17.1.6.1 所示</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note16-GPIO中断实验实验\image-20210225171259807.png" alt="image-20210225171259807"></p><p>GICC_PMR 寄存器只有低 8 位有效，这 8 位最多可以设置 256 个优先级，其他优先级数设 置如表 17.1.6.1 所示：</p><table><thead><tr><th>bit7:0</th><th>优先级数</th></tr></thead><tbody><tr><td>11111111</td><td>256 个优先级</td></tr><tr><td>11111110</td><td>128 个优先级</td></tr><tr><td>11111100</td><td>64 个优先级</td></tr><tr><td>11111000</td><td>32 个优先级</td></tr><tr><td>11110000</td><td>16 个优先级</td></tr></tbody></table><p>I.MX6U 支持 32 个优先级，所以 GICC_PMR 要设置为 0b11111000</p><h5 id="抢占优先级和子优先级位数设置"><a href="#抢占优先级和子优先级位数设置" class="headerlink" title="抢占优先级和子优先级位数设置"></a>抢占优先级和子优先级位数设置</h5><p>抢占优先级和子优先级各占多少位是由寄存器 GICC_BPR 来决定的，GICC_BPR 寄存器结构如图</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note16-GPIO中断实验实验\image-20210225171613112.png" alt="image-20210225171613112"></p><p>寄存器 GICC_BPR 只有低 3 位有效，其值不同，抢占优先级和子优先级占用的位数也不同， 配置如表如图：</p><table><thead><tr><th>Binary Point</th><th>抢占优先级域</th><th>子优先级域</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>[7:1]</td><td>[0]</td><td>7 级抢占优先级，1 级子优先级</td></tr><tr><td>1</td><td>[7:2]</td><td>[1:0]</td><td>6 级抢占优先级，2 级子优先级</td></tr><tr><td>2</td><td>[7:3]</td><td>[2:0]</td><td>5 级抢占优先级，3 级子优先级</td></tr><tr><td>3</td><td>[7:4]</td><td>[3:0]</td><td>4 级抢占优先级，4 级子优先级</td></tr><tr><td>4</td><td>[7:5]</td><td>[4:0]</td><td>3 级抢占优先级，5 级子优先级</td></tr><tr><td>5</td><td>[7:6]</td><td>[5:0]</td><td>2 级抢占优先级，6 级子优先级</td></tr><tr><td>6</td><td>[7:7]</td><td>[6:0]</td><td>1 级抢占优先级，7 级子优先级</td></tr><tr><td>7</td><td>无</td><td>[7:0]</td><td>0 级抢占优先级，8 级子优先级</td></tr></tbody></table><p>为了简单起见，一般将所有的中断优先级位都配置为抢占优先级，比如 I.MX6U 的优先级 位数为 5(32 个优先级)，所以可以设置 Binary point 为 2，表示 5 个优先级位全部为抢占优先级</p><h5 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h5><p>某个中断 ID 的中断优先级设置由寄存器 D_IPRIORITYR 来完成，前面说了 Cortex-A7 使用了 512 个中断 ID，每个中断 ID 配有一个优 先级寄存器，所以一共有 512 个 D_IPRIORITYR 寄存器。如果优先级个数为 32 (11111000)的话，使用寄存器 D_IPRIORITYR 的 bit7:4 (第四位开始是1）来设置优先级，也就是说实际的优先级要左移 3 位（把1移过去）。比如要设置 ID40 中断的优先级为 5，示例代码如下：</p><p><code>GICD_IPRIORITYR[40] = 5 &lt;&lt; 3;</code></p><h5 id="优先级设置主要有三部分："><a href="#优先级设置主要有三部分：" class="headerlink" title="优先级设置主要有三部分："></a>优先级设置主要有三部分：</h5><ol><li>设置寄存器 GICC_PMR，配置优先级个数，比如 I.MX6U 支持 32 级优先级</li><li>设置抢占优先级和子优先级位数，一般为了简单起见，会将所有的位数都设置为抢占优先级</li><li>设置指定中断 ID 的优先级，也就是设置外设优先级</li></ol><h3 id="中断服务函数"><a href="#中断服务函数" class="headerlink" title="中断服务函数"></a>中断服务函数</h3><p>10个API函数</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>GIC_Init</td><td>初始化 GIC</td></tr><tr><td>GIC_EnableIRQ</td><td>使能指定的外设中断</td></tr><tr><td>GIC_DisableIRQ</td><td>关闭指定的外设中断</td></tr><tr><td>GIC_AcknowledgeIRQ</td><td>返回中断号</td></tr><tr><td>GIC_DeactivateIRQ</td><td>无效化指定中断</td></tr><tr><td>GIC_GetRunningPriority</td><td>获取当前正在运行的中断优先级</td></tr><tr><td>GIC_SetPriorityGrouping</td><td>设置抢占优先级位数</td></tr><tr><td>GIC_GetPriorityGrouping</td><td>获取抢占优先级位数</td></tr><tr><td>GIC_SetPriority</td><td>设置指定中断的优先级</td></tr><tr><td>GIC_GetPriority</td><td>获取指定中断的优先级</td></tr></tbody></table><h3 id="修改start-S"><a href="#修改start-S" class="headerlink" title="修改start.S"></a>修改start.S</h3><p>添加中断向量表，编写复位中断服务函数和IRQ中断服务函数。</p><p>编写复位中断服务函数，内容如下：</p><ol><li>关闭I,D Cache和MMU</li><li>设置处理器9中工作模式下对应的SP指针。要使用中断那么必须设置IRQ模式下的SP指针。索性直接设置所有模式下的SP指针</li><li>清除bss段</li><li>跳到C函数，也就是main函数</li></ol><h3 id="CP15协处理器"><a href="#CP15协处理器" class="headerlink" title="CP15协处理器"></a>CP15协处理器</h3><p>MRC: 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。</p><p>MRC 就是读 CP15 寄存器， MCR 就是写 CP15 寄存器， MCR 指令格式如下：</p><p>MCR{cond} p15, <opc1>, <Rt>, <CRn>, <CRm>, <opc2></opc2></CRm></CRn></Rt></opc1></p><p>MRC p15, 0, r0, c0,c0,0</p><p>现在要关闭I,D ache和MMU，打开Cortex-A7参考手册到105页，找到SCTLR寄存器。也就是系统控制寄存器，此寄存器bit0用于打开和关闭MMU，bit1控制对齐，bit2控制D Cache的打开和关闭。Bit11用于控制分支预测。Bit12用于控制I Cache。</p><p><strong>中断向量偏移设置</strong></p><p>将新的中断向量表首地址写入到CP15协处理器的VBAR寄存器。</p><p>MCR{cond} p15, <opc1>, <Rt>, <CRn>, <CRm>, <opc2></opc2></CRm></CRn></Rt></opc1></p><p>MRC p15,0,r0,c12,c0,0  </p><p>MCR p15,0,r0,c12,c0,0</p><p> <strong>IRQ中断服务函数</strong></p><p>mrc p15, 4, r1, c15, c0, 0  读取CP15的CBAR寄存器。CBAR寄存器保存了GIC控制器的寄存器组首地址。GIC寄存器组偏移0x1000<del>0x1fff为GIC的分发器。0x2000</del>0x3fff为CPU接口端。意味我们可以访问GIC控制器了！</p><p>代码中，R1寄存器吧保存着GIC控制器的CPU接口端基地址。读取CPU接口段的GICC_IAR寄存器的值保存到R0寄存器里面。可以从GICC_IAR的bit9~0读取中断ID，我们读取中断ID的目的就是为了得到对应的中断处理函数</p><p>system_irqhandler就是具体的中断处理函数，此函数有一个参数，为GICC_IAR寄存器的值</p><p>system_irqhandler处理完具体的中断以后，需要将对应的中断ID值写入到GICC_EOIR寄存器里面</p><p>ARM 的指令是三级流水线：取指、译指、执 行，pc 指向的是正在取值的地址，这就是很多书上说的 pc=当前执行指令地址+8</p><p><code>0X2000 MOV R1, R0 ;</code></p><p><code>执行 0X2004 MOV R2, R3 ;</code></p><p><code>译指 0X2008 MOV R4, R5 ;取值 PC</code></p><hr><p>参考资料：</p><p>正点原子【第二期】手把手教你学Linux之ARM（MX6U）裸机篇-GPIO中断实验</p><p>正点原子 I.MX6U 嵌入式Linux驱动开发指南 第十七章</p><p>《Cortex-A7 Technical ReferenceManua.pdf》</p><p>《ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Cortex-A7-中断系统详解&quot;&gt;&lt;a href=&quot;#Cortex-A7-中断系统详解&quot; class=&quot;headerlink&quot; title=&quot;Cortex-A7 中断系统</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note15 主频和时钟配置实验</title>
    <link href="https://chenzhan666.coding.me/2021/02/20/note15-%E4%B8%BB%E9%A2%91%E5%92%8C%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C/"/>
    <id>https://chenzhan666.coding.me/2021/02/20/note15-%E4%B8%BB%E9%A2%91%E5%92%8C%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-02-20T11:56:22.000Z</published>
    <updated>2021-02-26T09:57:16.984Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="时钟系统"><a href="#时钟系统" class="headerlink" title="时钟系统"></a>时钟系统</h1><p>I.MX6U 的系统主频为 528MHz，默认情况下内部 boot rom 会将 I.MX6U 的主频设置为 396MHz</p><ul><li><p>来源</p><p>32.768KHz 和 24MHz 的晶振，其中 32.768KHz 晶振是 I.MX6U 的 RTC 时钟源，24MHz 晶振是 I.MX6U 内核 和其它外设的时钟源</p></li><li><p>7 路 PLL 时钟源</p><p>为了方便生成时钟，6从24MHz晶振生出来7路PLL。这7路PLL中有的又生出来PFD。</p><ol><li>PLL1：ARM PLL供给ARM内核，ARM 内核时钟就是由此 PLL 生成的，此 PLL 通过编程的方式最高可倍频到 1.3GHz</li><li>PLL2：sysytem PLL，528MHz，528_PLL，此路PLL分出了4路PFD，分别为PLL2_PFD0~PFD3，此路 PLL 时钟=24MHz * 22 = 528MHz ，叫做 528_PLL通常 528_PLL 和这 4 路 PFD 是 I.MX6U 内部系统总线的 时钟源，比如内处理逻辑单元、DDR 接口、NAND/NOR 接口等等</li><li>PLL3: USB1 PLL，480MHz 480_PLL，此路PLL分出了4路PFD，分别为PLL3_PFD0~PFD3， USB1_PLL=24MHz *20=480MHz。 USB1_PLL虽然主要用于USB1PHY，但是其和四路PFD同样也可以作为其他外设的根时钟源</li><li>PLL4: Audio PLL，主供音频使用，,此路 PLL 用于音频相关的外设，此路 PLL 的倍频可以调整，PLL 的输出范围同样也是 650MHz~1300MHz，此路 PLL 在最终输出的时候也可以进行分频，可选 1/2/4 分频</li><li>PLL5: Video PLL，主供视频外设，比如RGB LCD接口，和图像处理有关的外设，显示相关的外设，比如 LCD，此路 PLL 的倍频可以 调整，PLL 的输出范围在 650MHz~1300MHz。此路 PLL 在最终输出的时候还可以进行分频， 可选 1/2/4/8/16 分频</li><li>PLL6：ENET PLL，主供网络外设，ENET_PLL=24MHz * (20+5/6) = 500MHz。此路 PLL 用于生成网络所需的时钟，可以在此 PLL 的基础上生成 25/50/100/125MHz 的网络时钟</li><li>PLL7: USB2_PLL ,480MHz，无PFD，给USB2PHY使用的，此路PLL固定为20倍频是480MHz</li></ol></li><li><p>时钟树</p><p>共有三部分：CLOCK_SWITCHER、CLOCK ROOT GENERATOR 和 SYSTEM CLOCKS。左边的 CLOCK_SWITCHER 是 7 路 PLL 和 8 路 PFD，右边的 SYSTEM CLOCKS 是芯片外设，中间的 CLOCK ROOT GENERATOR 是设置相应的寄存器负责从 7 路 PLL 和 8 路 PFD 中选择合适的时钟源给外设使用</p><p>比如ESAI时钟源选择：</p><p> PLL4、PLL3_PFD2、PLL5、pll3_sw_clk</p><p>由寄存器 CCM-&gt;CSCMR2 的 ESAI_CLK_SEL 位来决定</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note15-主频和时钟配置实验\image-20210220220107511.png" alt="image-20210220220107511"></p><ol><li>是 ESAI 时钟的前级分频，分频值由寄存器 CCM_CS1CDR 的 ESAI_CLK_PRED 来确定的，可设置 1~8 分频，假如现在 PLL4=650MHz，我们选择 PLL4 作为 ESAI 时钟，前级 分频选择 2 分频，那么此时的时钟就是 650/2=325MHz</li><li>是 ESAI 时钟的前级分频，分频值由寄存器 CCM_CS1CDR 的 ESAI_CLK_PRED 来确定的，可设置 1~8 分频，假如现在 PLL4=650MHz，我们选择 PLL4 作为 ESAI 时钟，前级 分频选择 2 分频，那么此时的时钟就是 650/2=325MHz</li><li>是一个分频器，对②中输出的时钟进一步分频，分频值由寄存器 CCM_CS1CDR 的 ESAI_CLK_PODF 来决定，可设置 1~8 分频。假如我们设置为 8 分频的话， 经过此分频器以后的时钟就是 325/8=40.625MHz。因此最终进入到 ESAI 外设的时钟就是 40.625MHz</li></ol></li><li><p>内核时钟设置</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note15-主频和时钟配置实验\image-20210220221110905.png" alt="image-20210220221110905"></p><ol><li>内核时钟源来自于 PLL1</li><li>通过寄存器 CCM_CACRR 的 ARM_PODF 位对 PLL1 进行分频，可选择 1/2/4/8 分频， 假如我们选择 2 分频，那么经过分频以后的时钟频率是 996/2=498MHz</li><li>此处没有进行 2 分频</li><li>经过第2步 2 分频以后的 498MHz 就是 ARM 的内核时钟，也就是 I.MX6U 的主频</li></ol><p>寄存器 CCM_CACCR 的 ARM_PODF 位很好设置，可以设置为 0<del>7，分别对应 1</del>8 分频。如果要 设置为2分频的话CCM_CACCR就要设置为1</p><p>PLL1 的频率 可以通过寄存器 CCM_ANALOG_PLL_ARMn 来设置</p><p>ENABLE: 时钟输出使能位，此位设置为 1 使能 PLL1 输出，如果设置为 0 的话就关闭 PLL1 输出。 DIV_SELECT: 此位设置 PLL1 的输出频率，可设置范围为：54~108，PLL1 CLK = Fin * div_seclec/2.0，Fin=24MHz。如果 PLL1 要输出 1056MHz 的话，div_select 就要设置为 88</p></li><li><p>PLL1 时钟开关</p></li><li><p>寄存器 CCM_CCSR</p><p>STEP_SEL、PLL1_SW_CLK_SEL 这两个位，一个是用来选择 step_clk 时钟源的，一个是用来选择 pll1_sw_clk 时钟源的</p></li><li><p>PFD 时钟设置</p><p>设置好主频以后我们还需要设置好其他的 PLL 和 PFD 时钟</p></li><li><p>PLL2、PLL3 和 PLL7 固定为 528MHz、480MHz 和 480MHz，PLL4~PLL6 都是针对特殊外设</p></li><li><p> AHB、IPG 和 PERCLK 根时钟设置</p></li></ul><h1 id="I-MX6U系统配置"><a href="#I-MX6U系统配置" class="headerlink" title="I.MX6U系统配置"></a>I.MX6U系统配置</h1><h2 id="系统主频的配置"><a href="#系统主频的配置" class="headerlink" title="系统主频的配置"></a>系统主频的配置</h2><ol><li><p>要设置ARM内核主频为528MHz，设置CACRR寄存器的ARM_PODF位为2分频，然后设置PLL1=1056MHz即可。CACRR的bit3<del>0为ARM_PODF位，可设置0</del>7，分别对应1~8分频。应该设置CACRR寄存器的ARM_PODF=1</p></li><li><p>设置PLL1=1056MHz。PLL1=pll1_sw_clk。pll1_sw_clk有两路可以选择，分别为pll1_main_clk，和step_clk，通过CCSR寄存器的pll1_sw_clk_sel位(bit2)来选择。为0的时候选择pll1_main_clk，为1的时候选额step_clk</p></li><li><p>在修改PLL1的时候，也就是设置系统时钟的时候需要给6ULL一个临时的时钟，也就是step_clk在修改PLL1的时候需要将pll1_sw_clk切换到step_clk上</p></li><li><p>设置step_clk。Step_clk也有两路来源，由CCSR的step_sel位(bit8)来设置，为0的时候设置step_clk为osc=24MHz。为1的时候不重要，不用</p></li><li><p>时钟切换成功以后就可以修改PLL1的值</p></li><li><p>通过CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位(bit6~0)来设置PLL1的频率，公式位：</p><p><strong><em>Output = frefDIV_SEL/2 1056=24DIV_SEL/2=&gt;DIEV_SEL=88</em></strong></p><p>设置CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位=88即可。PLL1=1056MHz</p><p>还要设置CCM_ANALOG_PLL_ARM寄存器的ENABLE位(bit13)为1，也就是使能输出</p></li><li><p>在切换回PLL1之前，设置置CACRR寄存器的ARM_PODF=1！！切记</p></li></ol><h2 id="各个PLL时钟的配置"><a href="#各个PLL时钟的配置" class="headerlink" title="各个PLL时钟的配置"></a>各个PLL时钟的配置</h2><p>PLL2和PLL3。PLL2固定为528MHz，PLL3固定为480MHz</p><ol><li>初始化PLL2_PFD0~PFD3。寄存器CCM_ANALOG_PFD_528用于设置4路PFD的时钟。比如PFD0= 528<em>18/PFD0_FRAC。设置PFD0_FRAC位即可。比如PLL2_PFD0=352M=528</em>18/PFD0_FRAC，因此FPD0_FRAC=27</li><li>初始化PLL3_PFD0~PFD3</li></ol><h2 id="其他外设时钟源配置"><a href="#其他外设时钟源配置" class="headerlink" title="其他外设时钟源配置"></a>其他外设时钟源配置</h2><p>AHB_CLK_ROOT、PERCLK_CLK_ROOT以及IPG_CLK_ROOT。</p><p>因为PERCLK_CLK_ROOT和IPG_CLK_ROOT要用到AHB_CLK_ROOT，所以我们要初始化AHB_CLK_ROOT</p><ol><li><p>AHB_CLK_ROOT的初始化</p><p>AHB_CLK_ROOT=132MHz</p><p>设置CBCMR寄存器的PRE_PERIPH_CLK_SEL位，设置CBCDR寄存器的PERIPH_CLK_SEL位0。设置CBCDR寄存器的AHB_PODF位为2，也就是3分频，因此396/3=132MHz</p></li><li><p>IPG_CLK_ROOT初始化</p><p>设置CBCDR寄存器IPG_PODF=1，也就是2分频</p></li><li><p>PERCLK_CLK_ROOT初始化</p><p>设置CSCMR1寄存器的PERCLK_CLK_SEL位为0，表示PERCLK的时钟源为IPG</p></li></ol><hr><p>参考资料：正点原子【第二期】手把手教你学Linux之ARM（MX6U）裸机篇-主频和时钟配置实验</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;时钟系统&quot;&gt;&lt;a href=&quot;#时钟系统&quot; class=&quot;headerlink&quot; title=&quot;时钟系统&quot;&gt;&lt;/a&gt;时钟系统&lt;/h1&gt;&lt;p&gt;I.MX6U 的系统主频为 52</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note14 GPIO输入按键实验</title>
    <link href="https://chenzhan666.coding.me/2021/02/17/note14-GPIO%E8%BE%93%E5%85%A5%E6%8C%89%E9%94%AE%E5%AE%9E%E9%AA%8C/"/>
    <id>https://chenzhan666.coding.me/2021/02/17/note14-GPIO%E8%BE%93%E5%85%A5%E6%8C%89%E9%94%AE%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-02-17T08:58:24.000Z</published>
    <updated>2021-02-20T14:54:46.692Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>GPIO 连接按键的时候就要做为输入使用</p><p>KEY0 接了一个 10K 的上拉电阻，因此 KEY0 没有按下的时候 UART1_CTS 应该是高电平，当 KEY0 按下以后 UART1_CTS 就是低电平</p><h1 id="bsp-gpio-h"><a href="#bsp-gpio-h" class="headerlink" title="bsp_gpio.h"></a>bsp_gpio.h</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1 #ifndef _BSP_GPIO_H</span><br><span class="line">2 #define _BSP_GPIO_H</span><br><span class="line">3 #define _BSP_KEY_H</span><br><span class="line">4 #include &quot;imx6ul.h&quot;</span><br><span class="line">5 &#x2F;***************************************************************</span><br><span class="line">6 Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span><br><span class="line">7 文件名 : bsp_gpio.h</span><br><span class="line">8 作者 : 左忠凯</span><br><span class="line">9 版本 : V1.0</span><br><span class="line">10 描述 : GPIO 操作文件头文件。</span><br><span class="line">11 其他 : 无</span><br><span class="line">12 论坛 : www.openedv.com</span><br><span class="line">13 日志 : 初版 V1.0 2019&#x2F;1&#x2F;4 左忠凯创建</span><br><span class="line">14 ***************************************************************&#x2F;</span><br><span class="line">15</span><br><span class="line">16 &#x2F;* 枚举类型和结构体定义 *&#x2F;</span><br><span class="line">17 typedef enum _gpio_pin_direction</span><br><span class="line">18 &#123;</span><br><span class="line">19 kGPIO_DigitalInput &#x3D; 0U, &#x2F;* 输入 *&#x2F;</span><br><span class="line">20 kGPIO_DigitalOutput &#x3D; 1U, &#x2F;* 输出 *&#x2F;</span><br><span class="line">21 &#125; gpio_pin_direction_t;</span><br><span class="line">22</span><br><span class="line">23 &#x2F;* GPIO 配置结构体 *&#x2F;</span><br><span class="line">24 typedef struct _gpio_pin_config</span><br><span class="line">25 &#123;</span><br><span class="line">26 gpio_pin_direction_t direction; &#x2F;* GPIO 方向:输入还是输出 *&#x2F;</span><br><span class="line">27 uint8_t outputLogic; &#x2F;* 如果是输出的话，默认输出电平 *&#x2F;</span><br><span class="line">28 &#125; gpio_pin_config_t;</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31 &#x2F;* 函数声明 *&#x2F;</span><br><span class="line">32 void gpio_init(GPIO_Type *base, int pin, gpio_pin_config_t *config);</span><br><span class="line">33 int gpio_pinread(GPIO_Type *base, int pin);</span><br><span class="line">34 void gpio_pinwrite(GPIO_Type *base, int pin, int value);</span><br><span class="line">35</span><br><span class="line">36 #endif</span><br></pre></td></tr></table></figure><p>bsp_gpio.h 中定义了一个枚举类型 gpio_pin_direction_t 和结构体 gpio_pin_config_t，枚举类 型 gpio_pin_direction_t 表示 GPIO 方向，输入或输出。结构体 gpio_pin_config_t 是 GPIO 的配置 结构体，里面有 GPIO 的方向和默认输出电平两个成员变量。</p><h1 id="bsp-gpio-c"><a href="#bsp-gpio-c" class="headerlink" title="bsp_gpio.c"></a>bsp_gpio.c</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1 #include &quot;bsp_gpio.h&quot;</span><br><span class="line">2 &#x2F;***************************************************************</span><br><span class="line">3 Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span><br><span class="line">4 文件名 : bsp_gpio.h</span><br><span class="line">5 作者 : 左忠凯</span><br><span class="line">6 版本 : V1.0</span><br><span class="line">7 描述 : GPIO 操作文件。</span><br><span class="line">8 其他 : 无</span><br><span class="line">9 论坛 : www.openedv.com</span><br><span class="line">10 日志 : 初版 V1.0 2019&#x2F;1&#x2F;4 左忠凯创建</span><br><span class="line">11 ***************************************************************&#x2F;</span><br><span class="line">12</span><br><span class="line">13 &#x2F;*</span><br><span class="line">14 * @description : GPIO 初始化。</span><br><span class="line">15 * @param - base : 要初始化的 GPIO 组。</span><br><span class="line">16 * @param - pin : 要初始化 GPIO 在组内的编号。</span><br><span class="line">17 * @param - config : GPIO 配置结构体。</span><br><span class="line">18 * @return : 无</span><br><span class="line">19 *&#x2F;</span><br><span class="line">20 void gpio_init(GPIO_Type *base, int pin, gpio_pin_config_t *config)</span><br><span class="line">21 &#123;</span><br><span class="line">22 if(config-&gt;direction &#x3D;&#x3D; kGPIO_DigitalInput) &#x2F;* 输入 *&#x2F;</span><br><span class="line">23 &#123;</span><br><span class="line">24 base-&gt;GDIR &amp;&#x3D; ~( 1 &lt;&lt; pin);</span><br><span class="line">25 &#125;</span><br><span class="line">26 else &#x2F;* 输出 *&#x2F;</span><br><span class="line">27 &#123;</span><br><span class="line">28 base-&gt;GDIR |&#x3D; 1 &lt;&lt; pin;</span><br><span class="line">29 gpio_pinwrite(base,pin, config-&gt;outputLogic);&#x2F;* 默认输出电平 *&#x2F;</span><br><span class="line">30 &#125;</span><br><span class="line">31 &#125;</span><br><span class="line">32</span><br><span class="line">33 &#x2F;*</span><br><span class="line">34 * @description : 读取指定 GPIO 的电平值 。</span><br><span class="line">35 * @param – base : 要读取的 GPIO 组。</span><br><span class="line">36 * @param - pin : 要读取的 GPIO 脚号。</span><br><span class="line">37 * @return : 无</span><br><span class="line">38 *&#x2F;</span><br><span class="line">39 int gpio_pinread(GPIO_Type *base, int pin)</span><br><span class="line">40 &#123;</span><br><span class="line">41 return (((base-&gt;DR) &gt;&gt; pin) &amp; 0x1);</span><br><span class="line">42 &#125;</span><br><span class="line">43</span><br><span class="line">44 &#x2F;*</span><br><span class="line">45 * @description : 指定 GPIO 输出高或者低电平 。</span><br><span class="line">46 * @param – base : 要输出的的 GPIO 组。</span><br><span class="line">47 * @param - pin : 要输出的 GPIO 脚号。</span><br><span class="line">48 * @param – value : 要输出的电平，1 输出高电平， 0 输出低低电平</span><br><span class="line">49 * @return : 无</span><br><span class="line">50 *&#x2F;</span><br><span class="line">51 void gpio_pinwrite(GPIO_Type *base, int pin, int value)</span><br><span class="line">52 &#123;</span><br><span class="line">53 if (value &#x3D;&#x3D; 0U)</span><br><span class="line">54 &#123;</span><br><span class="line">55 base-&gt;DR &amp;&#x3D; ~(1U &lt;&lt; pin); &#x2F;* 输出低电平 *&#x2F;</span><br><span class="line">56 &#125;</span><br><span class="line">57 else</span><br><span class="line">58 &#123;</span><br><span class="line">59 base-&gt;DR |&#x3D; (1U &lt;&lt; pin); &#x2F;* 输出高电平 *&#x2F;</span><br><span class="line">60 &#125;</span><br><span class="line">61 &#125;</span><br></pre></td></tr></table></figure><p>文件 bsp_gpio.c 中有三个函数：gpio_init、gpio_pinread 和 gpio_pinwrite</p><ul><li><p>   函数 gpio_init 用 于初始化指定的 GPIO 引脚，最终配置的是 GDIR 寄存器，此函数有三个参数，这三个参数的 含义如下： </p><p>base: </p><p>要初始化的 GPIO 所属于的 GPIO 组，比如 GPIO1_IO18 就属于 GPIO1 组</p><p>pin：要初始化 GPIO 在组内的标号，比如 GPIO1_IO18 在组内的编号就是 18</p><p>config: 要初始化的 GPIO 配置结构体，用来指定 GPIO 配置为输出还是输入</p></li><li><p>   函数 gpio_pinread 是读取指定的 GPIO 值，也就是读取 DR 寄存器的指定位，此函数有两个 参数和一个返回值，参数含义如下： </p><p>base: </p><p>要读取的 GPIO 所属于的 GPIO 组，比如 GPIO1_IO18 就属于 GPIO1 组</p><p>pin：</p><p>要读取的 GPIO 在组内的标号，比如 GPIO1_IO18 在组内的编号就是 18</p><p>返回值：读取到的 GPIO 值，为 0 或者 1</p></li><li><p>   函数 gpio_pinwrite 是控制指定的 GPIO 引脚输入高电平(1)或者低电平(0)，就是设置 DR 寄 存器的指定位，此函数有三个参数，参数含义如下： </p><p>base: </p><p>要设置的 GPIO 所属于的 GPIO 组，比如 GPIO1_IO18 就属于 GPIO1 组</p><p>pin：</p><p>要设置的 GPIO 在组内的标号，比如 GPIO1_IO18 在组内的编号就是 18</p><p>value: </p><p>要设置的值，1(高电平)或者 0(低电平)。 我们以后就可以使用函数 gpio_init 设置指定 GPIO 为输入还是输出，使用函数 gpio_pinread 和 gpio_pinwrite 来读写指定的 GPIO</p></li></ul><h1 id="bsp-key-h"><a href="#bsp-key-h" class="headerlink" title="bsp_key.h"></a>bsp_key.h</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1 #ifndef _BSP_KEY_H</span><br><span class="line">2 #define _BSP_KEY_H</span><br><span class="line">3 #include &quot;imx6ul.h&quot;</span><br><span class="line">4 &#x2F;***************************************************************</span><br><span class="line">5 Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span><br><span class="line">6 文件名 : bsp_key.h</span><br><span class="line">7 作者 : 左忠凯</span><br><span class="line">8 版本 : V1.0</span><br><span class="line">9 描述 : 按键驱动头文件。</span><br><span class="line">10 其他 : 无</span><br><span class="line">11 论坛 : www.openedv.com</span><br><span class="line">12 日志 : 初版 V1.0 2019&#x2F;1&#x2F;4 左忠凯创建</span><br><span class="line">13 ***************************************************************&#x2F;</span><br><span class="line">14</span><br><span class="line">15 &#x2F;* 定义按键值 *&#x2F;</span><br><span class="line">16 enum keyvalue&#123;</span><br><span class="line">17 KEY_NONE &#x3D; 0,</span><br><span class="line">18 KEY0_VALUE,</span><br><span class="line">19 &#125;;</span><br><span class="line">20</span><br><span class="line">21 &#x2F;* 函数声明 *&#x2F;</span><br><span class="line">22 void key_init(void);</span><br><span class="line">23 int key_getvalue(void);</span><br><span class="line">24</span><br><span class="line">25 #endif</span><br></pre></td></tr></table></figure><p>bsp_key.h 文件中定义了一个枚举类型：keyvalue，此枚举类型表示按键值</p><h1 id="bsp-key-c"><a href="#bsp-key-c" class="headerlink" title="bsp_key.c"></a>bsp_key.c</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1 #include &quot;bsp_key.h&quot;</span><br><span class="line">2 #include &quot;bsp_gpio.h&quot;</span><br><span class="line">3 #include &quot;bsp_delay.h&quot;</span><br><span class="line">4 &#x2F;***************************************************************</span><br><span class="line">5 Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span><br><span class="line">6 文件名 : bsp_key.c</span><br><span class="line">7 作者 : 左忠凯</span><br><span class="line">8 版本 : V1.0</span><br><span class="line">9 描述 : 按键驱动文件。</span><br><span class="line">10 其他 : 无</span><br><span class="line">11 论坛 : www.openedv.com</span><br><span class="line">12 日志 : 初版 V1.0 2019&#x2F;1&#x2F;4 左忠凯创建</span><br><span class="line">13 ***************************************************************&#x2F;</span><br><span class="line">14</span><br><span class="line">15 &#x2F;*</span><br><span class="line">16 * @description : 初始化按键</span><br><span class="line">17 * @param : 无</span><br><span class="line">18 * @return : 无</span><br><span class="line">19 *&#x2F;</span><br><span class="line">20 void key_init(void)</span><br><span class="line">21 &#123;</span><br><span class="line">22 gpio_pin_config_t key_config;</span><br><span class="line">23</span><br><span class="line">24 &#x2F;* 1、初始化 IO 复用, 复用为 GPIO1_IO18 *&#x2F;</span><br><span class="line">25 IOMUXC_SetPinMux(IOMUXC_UART1_CTS_B_GPIO1_IO18, 0);</span><br><span class="line">26</span><br><span class="line">27 &#x2F;* 2、、配置 UART1_CTS_B 的 IO 属性</span><br><span class="line">28 *bit 16:0 HYS 关闭</span><br><span class="line">29 *bit [15:14]: 11 默认 22K 上拉</span><br><span class="line">30 *bit [13]: 1 pull 功能</span><br><span class="line">31 *bit [12]: 1 pull&#x2F;keeper 使能</span><br><span class="line">32 *bit [11]: 0 关闭开路输出</span><br><span class="line">33 *bit [7:6]: 10 速度 100Mhz</span><br><span class="line">34 *bit [5:3]: 000 关闭输出</span><br><span class="line">35 *bit [0]: 0 低转换率</span><br><span class="line">36 *&#x2F;</span><br><span class="line">37 IOMUXC_SetPinConfig(IOMUXC_UART1_CTS_B_GPIO1_IO18, 0xF080);</span><br><span class="line">38</span><br><span class="line">39 &#x2F;* 3、初始化 GPIO GPIO1_IO18 设置为输入*&#x2F;</span><br><span class="line">40 key_config.direction &#x3D; kGPIO_DigitalInput;</span><br><span class="line">41 gpio_init(GPIO1,18, &amp;key_config);</span><br><span class="line">42</span><br><span class="line">43 &#125;</span><br><span class="line">44</span><br><span class="line">45 &#x2F;*</span><br><span class="line">46 * @description : 获取按键值</span><br><span class="line">47 * @param : 无</span><br><span class="line">48 * @return : 0 没有按键按下，其他值:对应的按键值</span><br><span class="line">49 *&#x2F;</span><br><span class="line">50 int key_getvalue(void)</span><br><span class="line">51 &#123;</span><br><span class="line">52 int ret &#x3D; 0;</span><br><span class="line">53 static unsigned char release &#x3D; 1; &#x2F;* 按键松开 *&#x2F;</span><br><span class="line">54</span><br><span class="line">55 if((release&#x3D;&#x3D;1)&amp;&amp;(gpio_pinread(GPIO1, 18) &#x3D;&#x3D; 0)) &#x2F;* KEY0 按下 *&#x2F;</span><br><span class="line">56 &#123;</span><br><span class="line">57 delay(10); &#x2F;* 延时消抖 *&#x2F;</span><br><span class="line">58 release &#x3D; 0; &#x2F;* 标记按键按下 *&#x2F;</span><br><span class="line">59 if(gpio_pinread(GPIO1, 18) &#x3D;&#x3D; 0)</span><br><span class="line">60 ret &#x3D; KEY0_VALUE;</span><br><span class="line">61 &#125;</span><br><span class="line">62 else if(gpio_pinread(GPIO1, 18) &#x3D;&#x3D; 1) &#x2F;* KEY0 未按下 *&#x2F;</span><br><span class="line">63 &#123;</span><br><span class="line">64 ret &#x3D; 0;</span><br><span class="line">65 release &#x3D; 1; &#x2F;* 标记按键释放 *&#x2F;</span><br><span class="line">66 &#125;</span><br><span class="line">67</span><br><span class="line">68 return ret;</span><br><span class="line">69 &#125;</span><br></pre></td></tr></table></figure><p>bsp_key.c 中一共有两个函数：key_init 和 key_getvalue</p><p>key_init 是按键初始化函数，用来 初始化按键所使用的 UART1_CTS 这个 IO。函数 key_init 先设置 UART1_CTS 复用为 GPIO1_IO18，然后配置 UART1_CTS 这个 IO 为速度为 100MHz，默认 22K 上拉。最后调用函 数 gpio_init 来设置 GPIO1_IO18 为输入功能。 </p><p>函数 key_getvalue 用于获取按键值，此函数没有参数，只有一个返回值，返回值表示按键 值，返回值为 0 的话就表示没有按键按下，如果返回其他值的话就表示对应的按键按下了。获 取按键值其实就是不断的读取 GPIO1_IO18 的值，如果按键按下的话相应的 IO 被拉低，那么 GPIO1_IO18 值就为 0，如果按键未按下的话 GPIO1_IO18 的值就为 1。此函数中静态局部变量 release 表示按键是否释放</p><h1 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1 #include &quot;bsp_clk.h&quot;</span><br><span class="line">2 #include &quot;bsp_delay.h&quot;</span><br><span class="line">3 #include &quot;bsp_led.h&quot;</span><br><span class="line">4 #include &quot;bsp_beep.h&quot;</span><br><span class="line">5 #include &quot;bsp_key.h&quot;</span><br><span class="line">6</span><br><span class="line">7 &#x2F;*</span><br><span class="line">8 * @description : main 函数</span><br><span class="line">9 * @param : 无</span><br><span class="line">10 * @return : 无</span><br><span class="line">11 *&#x2F;</span><br><span class="line">12 int main(void)</span><br><span class="line">13 &#123;</span><br><span class="line">14 int i &#x3D; 0;</span><br><span class="line">15 int keyvalue &#x3D; 0;</span><br><span class="line">16 unsigned char led_state &#x3D; OFF;</span><br><span class="line">17 unsigned char beep_state &#x3D; OFF;</span><br><span class="line">18</span><br><span class="line">19 clk_enable(); &#x2F;* 使能所有的时钟 *&#x2F;</span><br><span class="line">20 led_init(); &#x2F;* 初始化 led *&#x2F;</span><br><span class="line">21 beep_init(); &#x2F;* 初始化 beep *&#x2F;</span><br><span class="line">22 key_init(); &#x2F;* 初始化 key *&#x2F;</span><br><span class="line">23</span><br><span class="line">24 while(1)</span><br><span class="line">25 &#123;</span><br><span class="line">26 keyvalue &#x3D; key_getvalue();</span><br><span class="line">27 if(keyvalue)</span><br><span class="line">28 &#123;</span><br><span class="line">29 switch (keyvalue)</span><br><span class="line">30 &#123;</span><br><span class="line">31 case KEY0_VALUE:</span><br><span class="line">32 beep_state &#x3D; !beep_state;</span><br><span class="line">33 beep_switch(beep_state);</span><br><span class="line">34 break;</span><br><span class="line">35 &#125;</span><br><span class="line">36 &#125;</span><br><span class="line">37 i++;</span><br><span class="line">38 if(i&#x3D;&#x3D;50)</span><br><span class="line">39 &#123;</span><br><span class="line">40 i &#x3D; 0;</span><br><span class="line">41 led_state &#x3D; !led_state;</span><br><span class="line">42 led_switch(LED0, led_state);</span><br><span class="line">43 &#125;</span><br><span class="line">44 delay(10);</span><br><span class="line">45 &#125;</span><br><span class="line">46 return 0;</span><br><span class="line">47 &#125;</span><br></pre></td></tr></table></figure><p>main.c 函数先初始化 led 灯、蜂鸣器和按键，然后在 while(1)循环中不断的调用函数 key_getvalue 来读取按键值，如果 KEY0 按下的话就打开/关闭蜂鸣器。LED0 作为系统提示指 示灯闪烁，闪烁周期大约为 500ms</p><hr><p>参考资料：正点原子《I.MX6U嵌入式Linux驱动开发指南V1.5》P384~393</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;GPIO 连接按键的时候就要做为输入使用&lt;/p&gt;
&lt;p&gt;KEY0 接了一个 10K 的上拉电阻，因此 KEY0 没有按下的时候 UART1_CTS 应该是高电平，当 KEY0 按下以</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note13 蜂鸣器实验</title>
    <link href="https://chenzhan666.coding.me/2021/02/15/note13-%E8%9C%82%E9%B8%A3%E5%99%A8%E5%AE%9E%E9%AA%8C/"/>
    <id>https://chenzhan666.coding.me/2021/02/15/note13-%E8%9C%82%E9%B8%A3%E5%99%A8%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-02-15T13:17:03.000Z</published>
    <updated>2021-02-26T09:57:41.960Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><p>蜂鸣器简介</p><p>常用的蜂鸣器有两种： 有源蜂鸣器和无源蜂鸣器，这里的有“源”不是电源，而是震荡源，有源蜂鸣器内部带有震荡 源，所以有源蜂鸣器只要通电就会叫。无源蜂鸣器内部不带震荡源，直接用直流电是驱动不起 来的，需要 2K-5K 的方波去驱动</p><p>有源蜂鸣器只要通电就会叫，所以我们可以做一个供电电路，这个供电电路可以由一个 IO 来控制其通断，一般使用三极管来搭建这个电路。为什么我们不能像控制 LED 灯一样，直接将 GPIO 接到蜂鸣器的负极，通过 IO 输出高低来控制蜂鸣器的通断。因为蜂鸣器工作的电流比 LED 灯要大，直接将蜂鸣器接到 I.MX6U 的 GPIO 上有可能会烧毁 IO，所以我们需要通过一个 三极管来间接的控制蜂鸣器的通断，相当于加了一层隔离</p></li><li><p>硬件原理分析</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note13-蜂鸣器实验\image-20210215212827020.png" alt="image-20210215212827020"></p><p>图中通过一个 PNP 型的三极管 8550 来驱动蜂鸣器，通过 SNVS_TAMPER1 这个 IO 来控制三极管 Q1 的导通，当 SNVS_TAMPER1 输出低电平的时候 Q1 导通，相当于蜂鸣器的正极连接到 DCDC_3V3，蜂鸣器形成一个通路，因此蜂鸣器会鸣叫</p></li><li><p>试验程序编写</p><p>新建 VSCode 工程，工程创建完成以后在 bsp 文件夹下新建名为“beep”的文件夹，蜂鸣 器驱动文件都放到“beep”文件夹里面。 </p><p>新建 beep.h 文件，保存到 bsp/beep 文件夹里面，在 beep.h 里面输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 #ifndef __BSP_BEEP_H</span><br><span class="line">2 #define __BSP_BEEP_H</span><br><span class="line">3</span><br><span class="line">4 #include &quot;imx6ul.h&quot;</span><br><span class="line">5</span><br><span class="line">6 &#x2F;* 函数声明 *&#x2F;</span><br><span class="line">7 void beep_init(void);</span><br><span class="line">8 void beep_switch(int status);</span><br><span class="line">9 #endif</span><br></pre></td></tr></table></figure><p>beep.h 很简单，就是函数声明。新建文件 beep.c，然后在 beep.c 里面输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1 #include &quot;bsp_beep.h&quot;</span><br><span class="line">2</span><br><span class="line">3 &#x2F;*</span><br><span class="line">4 * @description : 初始化蜂鸣器对应的 IO</span><br><span class="line">5 * @param : 无</span><br><span class="line">6 * @return : 无</span><br><span class="line">7 *&#x2F;</span><br><span class="line">8 void beep_init(void)</span><br><span class="line">9 &#123;</span><br><span class="line">10 &#x2F;* 1、初始化 IO 复用，复用为 GPIO5_IO01 *&#x2F;</span><br><span class="line">11 IOMUXC_SetPinMux(IOMUXC_SNVS_SNVS_TAMPER1_GPIO5_IO01,0);</span><br><span class="line">12</span><br><span class="line">13 &#x2F;* 2、配置 GPIO1_IO03 的 IO 属性 *&#x2F;</span><br><span class="line">14 IOMUXC_SetPinConfig(IOMUXC_SNVS_SNVS_TAMPER1_GPIO5_IO01,0X10B0);</span><br><span class="line">15</span><br><span class="line">16 &#x2F;* 3、初始化 GPIO,GPIO5_IO01 设置为输出 *&#x2F;</span><br><span class="line">17 GPIO5-&gt;GDIR |&#x3D; (1 &lt;&lt; 1);</span><br><span class="line">18</span><br><span class="line">19 &#x2F;* 4、设置 GPIO5_IO01 输出高电平，关闭蜂鸣器 *&#x2F;</span><br><span class="line">20 GPIO5-&gt;DR |&#x3D; (1 &lt;&lt; 1);</span><br><span class="line">21 &#125;</span><br><span class="line">22</span><br><span class="line">23 &#x2F;*</span><br><span class="line">24 * @description : 蜂鸣器控制函数，控制蜂鸣器打开还是关闭</span><br><span class="line">25 * @param - status : 0，关闭蜂鸣器，1 打开蜂鸣器</span><br><span class="line">26 * @return : 无</span><br><span class="line">27 *&#x2F;</span><br><span class="line">28 void beep_switch(int status)</span><br><span class="line">29 &#123;</span><br><span class="line">30 if(status &#x3D;&#x3D; ON)</span><br><span class="line">31 GPIO5-&gt;DR &amp;&#x3D; ~(1 &lt;&lt; 1); &#x2F;* 打开蜂鸣器 *&#x2F;</span><br><span class="line">32 else if(status &#x3D;&#x3D; OFF)</span><br><span class="line">33 GPIO5-&gt;DR |&#x3D; (1 &lt;&lt; 1); &#x2F;* 关闭蜂鸣器 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>beep.c 文件一共有两个函数：beep_init 和 beep_switch，其中 beep_init 用来初始化 BEEP 所 使用的 GPIO，也就是 SNVS_TAMPER1，将其复用为 GPIO5_IO01，beep_switch 函数用来控制 BEEP 的开关，也就是设置 GPIO5_IO01 的高低电平。 </p><p>最后在 main.c 函数中输入如下所示内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1 #include &quot;bsp_clk.h&quot;</span><br><span class="line">2 #include &quot;bsp_delay.h&quot;</span><br><span class="line">3 #include &quot;bsp_led.h&quot;</span><br><span class="line">4 #include &quot;bsp_beep.h&quot;</span><br><span class="line">5</span><br><span class="line">6 &#x2F;*</span><br><span class="line">7 * @description : main 函数</span><br><span class="line">8 * @param : 无</span><br><span class="line">9 * @return : 无</span><br><span class="line">10 *&#x2F;</span><br><span class="line">11 int main(void)</span><br><span class="line">12 &#123;</span><br><span class="line">13 clk_enable(); &#x2F;* 使能所有的时钟 *&#x2F;</span><br><span class="line">14 led_init(); &#x2F;* 初始化 led *&#x2F;</span><br><span class="line">15 beep_init(); &#x2F;* 初始化 beep *&#x2F;</span><br><span class="line">16</span><br><span class="line">17 while(1)</span><br><span class="line">18 &#123;</span><br><span class="line">19 &#x2F;* 打开 LED0 和蜂鸣器 *&#x2F;</span><br><span class="line">20 led_switch(LED0,ON);</span><br><span class="line">21 beep_switch(ON);</span><br><span class="line">22 delay(500);</span><br><span class="line">23</span><br><span class="line">24 &#x2F;* 关闭 LED0 和蜂鸣器 *&#x2F;</span><br><span class="line">25 led_switch(LED0,OFF);</span><br><span class="line">26 beep_switch(OFF);</span><br><span class="line">27 delay(500);</span><br><span class="line">28 &#125;</span><br><span class="line">29</span><br><span class="line">30 return 0;</span><br><span class="line">31 &#125;</span><br></pre></td></tr></table></figure><p>main.c中只有一个main函数，main函数先使能所有的外设时钟，然后初始化LED和BEEP。 最终在 while(1)循环中周期性的开关 LED 灯和蜂鸣器，周期大约为 500ms</p></li><li><p>编写 Makefile 和链接脚本</p><p>Makefile 使用之前编写的通用 Makefile，修改变量 TARGET 为 beep，在变量 INCDIRS 和 SRCDIRS 中追加“bsp/beep”</p><p>其中第 2 行修改目标的名称为“beep”。第 10 行在变量 INCDIRS 中添加蜂鸣器驱动头文件路径，也就是文件 beep.h 的路径。 第 16 行在变量 SRCDIRS 中添加蜂鸣器驱动文件路劲，也就是文件 beep.c 的路径。 链接脚本就使用之前的链接脚本文件 imx6ul.lds 即可</p></li></ul><hr><p>参考资料：正点原子《I.MX6U嵌入式Linux驱动开发指南V1.5》P377~382</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;蜂鸣器简介&lt;/p&gt;
&lt;p&gt;常用的蜂鸣器有两种： 有源蜂鸣器和无源蜂鸣器，这里的有“源”不是电源，而是震荡源，有源蜂鸣器内部带有震荡 源，所以有源蜂鸣器只要通电就会叫</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note12 官方SDK移值及BSP工程管理</title>
    <link href="https://chenzhan666.coding.me/2021/02/15/note12-%E5%AE%98%E6%96%B9SDK%E7%A7%BB%E5%80%BC%E5%8F%8ABSP%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://chenzhan666.coding.me/2021/02/15/note12-%E5%AE%98%E6%96%B9SDK%E7%A7%BB%E5%80%BC%E5%8F%8ABSP%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2021-02-15T10:00:11.000Z</published>
    <updated>2021-02-15T16:52:20.090Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="官方-SDK-移植"><a href="#官方-SDK-移植" class="headerlink" title="官方 SDK 移植"></a>官方 SDK 移植</h1><p>NXP 官方为 I.MX6ULL 编写了 SDK 包，在 SDK 包里面 NXP 已经编写好了寄存器定义文件， 所以我们可以直接移植 SDK 包里面的文件来用</p><ul><li><p>SDK 包里面与寄存器定义相关的文件，一共如下三个文件： </p><ol><li>fsl_common.h</li><li>fsl_iomuxc.h</li><li>MCIMX6Y2.h</li></ol></li><li><p>SDK 文件移植</p><p>使用 VSCode 新建工程，并将 fsl_common.h、fsl_iomuxc.h 和 MCIMX6Y2.h 这三个文件删减后拷贝到工程中</p></li><li><p>创建 cc.h 文件</p><p>cc.h 里面存放一些 SDK 库文件需要使用到的数据类型，在 cc.h 里面输入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1 #ifndef __CC_H</span><br><span class="line">2 #define __CC_H</span><br><span class="line">3 &#x2F;***************************************************************</span><br><span class="line">4 Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span><br><span class="line">5 文件名 : cc.h</span><br><span class="line">6 作者 : 左忠凯</span><br><span class="line">7 版本 : V1.0</span><br><span class="line">8 描述 : 有关变量类型的定义，NXP 官方 SDK 的一些移植文件会用到。</span><br><span class="line">9 其他 : 无</span><br><span class="line">10 日志 : 初版 V1.0 2019&#x2F;1&#x2F;3 左忠凯创建</span><br><span class="line">11 ***************************************************************&#x2F;</span><br><span class="line">12</span><br><span class="line">13 &#x2F;*</span><br><span class="line">14 * 自定义一些数据类型供库文件使用</span><br><span class="line">15 *&#x2F;</span><br><span class="line">16 #define __I volatile</span><br><span class="line">17 #define __O volatile</span><br><span class="line">18 #define __IO volatile</span><br><span class="line">19</span><br><span class="line">20 #define ON 1</span><br><span class="line">21 #define OFF 0</span><br><span class="line">22</span><br><span class="line">23 typedef signed char int8_t;</span><br><span class="line">24 typedef signed short int int16_t;</span><br><span class="line">25 typedef signed int int32_t;</span><br><span class="line">26 typedef unsigned char uint8_t;</span><br><span class="line">27 typedef unsigned short int uint16_t;</span><br><span class="line">28 typedef unsigned int uint32_t;</span><br><span class="line">29 typedef unsigned long long uint64_t;</span><br><span class="line">30 typedef signed char s8;</span><br><span class="line">31 typedef signed short int s16;</span><br><span class="line">32 typedef signed int s32;</span><br><span class="line">33 typedef signed long long int s64;</span><br><span class="line">34 typedef unsigned char u8;</span><br><span class="line">35 typedef unsigned short int u16;</span><br><span class="line">36 typedef unsigned int u32;</span><br><span class="line">37 typedef unsigned long long int u64;</span><br><span class="line">38</span><br><span class="line">39 #endif</span><br></pre></td></tr></table></figure></li><li><p>编写实验代码</p><p>新建 start.S 和 main.c</p><p>start.S</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 .global _start &#x2F;* 全局标号 *&#x2F;</span><br><span class="line">2</span><br><span class="line">3 &#x2F;*</span><br><span class="line">4 * 描述： _start 函数，程序从此函数开始执行，此函数主要功能是设置 C</span><br><span class="line">5 * 运行环境。</span><br><span class="line">6 *&#x2F;</span><br><span class="line">7 _start:</span><br><span class="line">8</span><br><span class="line">9 &#x2F;* 进入 SVC 模式 *&#x2F;</span><br><span class="line">10 mrs r0, cpsr</span><br><span class="line">11 bic r0, r0, #0x1f &#x2F;* 将 r0 的低 5 位清零，也就是 cpsr 的 M0~M4 *&#x2F;</span><br><span class="line">12 orr r0, r0, #0x13 &#x2F;* r0 或上 0x13,表示使用 SVC 模式 *&#x2F;</span><br><span class="line">13 msr cpsr, r0 &#x2F;* 将 r0 的数据写入到 cpsr_c 中 *&#x2F;</span><br><span class="line">14</span><br><span class="line">15 ldr sp, &#x3D;0X80200000 &#x2F;* 设置栈指针 *&#x2F;</span><br><span class="line">16 b main &#x2F;* 跳转到 main 函数 *&#x2F;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">1 #include &quot;fsl_common.h&quot;</span><br><span class="line">2 #include &quot;fsl_iomuxc.h&quot;</span><br><span class="line">3 #include &quot;MCIMX6Y2.h&quot;</span><br><span class="line">4</span><br><span class="line">5 &#x2F;*</span><br><span class="line">6 * @description : 使能 I.MX6U 所有外设时钟</span><br><span class="line">7 * @param : 无</span><br><span class="line">8 * @return : 无</span><br><span class="line">9 *&#x2F;</span><br><span class="line">10 void clk_enable(void)</span><br><span class="line">11 &#123;</span><br><span class="line">12 CCM-&gt;CCGR0 &#x3D; 0XFFFFFFFF;</span><br><span class="line">13 CCM-&gt;CCGR1 &#x3D; 0XFFFFFFFF;</span><br><span class="line">14</span><br><span class="line">15 CCM-&gt;CCGR2 &#x3D; 0XFFFFFFFF;</span><br><span class="line">16 CCM-&gt;CCGR3 &#x3D; 0XFFFFFFFF;</span><br><span class="line">17 CCM-&gt;CCGR4 &#x3D; 0XFFFFFFFF;</span><br><span class="line">18 CCM-&gt;CCGR5 &#x3D; 0XFFFFFFFF;</span><br><span class="line">19 CCM-&gt;CCGR6 &#x3D; 0XFFFFFFFF;</span><br><span class="line">20</span><br><span class="line">21 &#125;</span><br><span class="line">22</span><br><span class="line">23 &#x2F;*</span><br><span class="line">24 * @description : 初始化 LED 对应的 GPIO</span><br><span class="line">25 * @param : 无</span><br><span class="line">26 * @return : 无</span><br><span class="line">27 *&#x2F;</span><br><span class="line">28 void led_init(void)</span><br><span class="line">29 &#123;</span><br><span class="line">30 &#x2F;* 1、初始化 IO 复用 *&#x2F;</span><br><span class="line">31 IOMUXC_SetPinMux(IOMUXC_GPIO1_IO03_GPIO1_IO03,0);</span><br><span class="line">32</span><br><span class="line">33 &#x2F;* 2、、配置 GPIO1_IO03 的 IO 属性</span><br><span class="line">34 *bit 16:0 HYS 关闭</span><br><span class="line">35 *bit [15:14]: 00 默认下拉</span><br><span class="line">36 *bit [13]: 0 kepper 功能</span><br><span class="line">37 *bit [12]: 1 pull&#x2F;keeper 使能</span><br><span class="line">38 *bit [11]: 0 关闭开路输出</span><br><span class="line">39 *bit [7:6]: 10 速度 100Mhz</span><br><span class="line">40 *bit [5:3]: 110 R0&#x2F;6 驱动能力</span><br><span class="line">41 *bit [0]: 0 低转换率</span><br><span class="line">42 *&#x2F;</span><br><span class="line">43 IOMUXC_SetPinConfig(IOMUXC_GPIO1_IO03_GPIO1_IO03,0X10B0);</span><br><span class="line">44</span><br><span class="line">45 &#x2F;* 3、初始化 GPIO,设置 GPIO1_IO03 设置为输出 *&#x2F;</span><br><span class="line">46 GPIO1-&gt;GDIR |&#x3D; (1 &lt;&lt; 3);</span><br><span class="line">47</span><br><span class="line">48 &#x2F;* 4、设置 GPIO1_IO03 输出低电平，打开 LED0 *&#x2F;</span><br><span class="line">49 GPIO1-&gt;DR &amp;&#x3D; ~(1 &lt;&lt; 3);</span><br><span class="line">50 &#125;</span><br><span class="line">51</span><br><span class="line">52 &#x2F;*</span><br><span class="line">53 * @description : 打开 LED 灯</span><br><span class="line">54 * @param : 无</span><br><span class="line">55 * @return : 无</span><br><span class="line">56 *&#x2F;</span><br><span class="line">57 void led_on(void)</span><br><span class="line">58 &#123;</span><br><span class="line">59 &#x2F;* 将 GPIO1_DR 的 bit3 清零 *&#x2F;</span><br><span class="line">60 GPIO1-&gt;DR &amp;&#x3D; ~(1&lt;&lt;3);</span><br><span class="line">61 &#125;</span><br><span class="line">62</span><br><span class="line">63 &#x2F;*</span><br><span class="line">64 * @description : 关闭 LED 灯</span><br><span class="line">65 * @param : 无</span><br><span class="line">66 * @return : 无</span><br><span class="line">67 *&#x2F;</span><br><span class="line">68 void led_off(void)</span><br><span class="line">69 &#123;</span><br><span class="line">70 &#x2F;* 将 GPIO1_DR 的 bit3 置 1 *&#x2F;</span><br><span class="line">71 GPIO1-&gt;DR |&#x3D; (1&lt;&lt;3);</span><br><span class="line">72 &#125;</span><br><span class="line">73</span><br><span class="line">74 &#x2F;*</span><br><span class="line">75 * @description : 短时间延时函数</span><br><span class="line">76 * @param - n : 要延时循环次数(空操作循环次数，模式延时)</span><br><span class="line">77 * @return : 无</span><br><span class="line">78 *&#x2F;</span><br><span class="line">79 void delay_short(volatile unsigned int n)</span><br><span class="line">80 &#123;</span><br><span class="line">81 while(n--)&#123;&#125;</span><br><span class="line">82 &#125;</span><br><span class="line">83</span><br><span class="line">84 &#x2F;*</span><br><span class="line">85 * @description : 延时函数,在 396Mhz 的主频下</span><br><span class="line">86 * 延时时间大约为 1ms</span><br><span class="line">87 * @param - n : 要延时的 ms 数</span><br><span class="line">88 * @return : 无</span><br><span class="line">89 *&#x2F;</span><br><span class="line">90 void delay(volatile unsigned int n)</span><br><span class="line">91 &#123;</span><br><span class="line">92 while(n--)</span><br><span class="line">93 &#123;</span><br><span class="line">94 delay_short(0x7ff);</span><br><span class="line">95 &#125;</span><br><span class="line">96 &#125;</span><br><span class="line">97</span><br><span class="line">98 &#x2F;*</span><br><span class="line">99 * @description : main 函数</span><br><span class="line">100 * @param : 无</span><br><span class="line">101 * @return : 无</span><br><span class="line">102 *&#x2F;</span><br><span class="line">103 int main(void)</span><br><span class="line">104 &#123;</span><br><span class="line">105 clk_enable(); &#x2F;* 使能所有的时钟 *&#x2F;</span><br><span class="line">106 led_init(); &#x2F;* 初始化 led *&#x2F;</span><br><span class="line">107</span><br><span class="line">108 while(1) &#x2F;* 死循环 *&#x2F;</span><br><span class="line">109 &#123;</span><br><span class="line">110 led_off(); &#x2F;* 关闭 LED *&#x2F;</span><br><span class="line">111 delay(500); &#x2F;* 延时 500ms *&#x2F;</span><br><span class="line">112</span><br><span class="line">113 led_on(); &#x2F;* 打开 LED *&#x2F;</span><br><span class="line">114 delay(500); &#x2F;* 延时 500ms *&#x2F;</span><br><span class="line">115 &#125;</span><br><span class="line">116</span><br><span class="line">117 return 0;</span><br><span class="line">118 &#125;</span><br></pre></td></tr></table></figure><p>main.c 有 7 个函数，这 7 个函数的含义都一样，只是本例程使用的是移植好的 NXP 官方 SDK 里面的寄存器定义</p><p>led_init 函数中的第 31 行和第 43 行使 用 了 两 个 函 数 IOMUXC_SetPinMux 和 IOMUXC_SetPinConfig ， 其 中 函 数 IOMUXC_SetPinMux 是 用 来 设 置 IO 复 用 功 能 的 ， 最 终设置的是寄存器 “IOMUXC_SW_MUX_CTL_PAD_XX”。函数 IOMUXC_SetPinConfig 设置的是 IO 的上下拉、 速度等的，也就是寄存器“IOMUXC_SW_PAD_CTL_PAD_XX”</p><p>函数 IOMUXC_SetPinMux 在文件 fsl_iomuxc.h 中定义，函数源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static inline void IOMUXC_SetPinMux(uint32_t muxRegister,</span><br><span class="line"> uint32_t muxMode,</span><br><span class="line">uint32_t inputRegister,</span><br><span class="line"> uint32_t inputDaisy,</span><br><span class="line"> uint32_t configRegister,</span><br><span class="line">uint32_t inputOnfield)</span><br><span class="line">&#123;</span><br><span class="line"> *((volatile uint32_t *)muxRegister) &#x3D;</span><br><span class="line"> IOMUXC_SW_MUX_CTL_PAD_MUX_MODE(muxMode) |</span><br><span class="line">IOMUXC_SW_MUX_CTL_PAD_SION(inputOnfield);</span><br><span class="line"> if (inputRegister)</span><br><span class="line"> &#123;</span><br><span class="line"> *((volatile uint32_t *)inputRegister) &#x3D;</span><br><span class="line">IOMUXC_SELECT_INPUT_DAISY(inputDaisy);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 IOMUXC_SetPinMux 有 6 个参数，这 6 个参数的函数如下</p><table><thead><tr><th>muxRegister</th><th>IO 的 复 用 寄 存 器 地 址 ， 比 如 GPIO1_IO03 的 IO 复 用 寄 存 器 SW_MUX_CTL_PAD_GPIO1_IO03 的地址为 0X020E0068</th></tr></thead><tbody><tr><td>muxMode</td><td>IO 复用值，也就是 ALT0<del>ALT8，对应数字 0</del>8，比如要将 GPIO1_IO03 设置 为 GPIO 功能的话此参数就要设置为 5</td></tr><tr><td>inputRegister</td><td>外设输入 IO 选择寄存器地址，有些 IO 在设置为其他的复用功能以后还需 要设置 IO 输入寄存器，比如 GPIO1_IO03 要复用为 UART1_RX 的话还需要设置寄存器 UART1_RX_DATA_SELECT_INPUT，此寄存器地址为 0X020E0624</td></tr><tr><td>inputDaisy</td><td>寄存器 inputRegister 的值，比如 GPIO1_IO03 要作为 UART1_RX 引脚的话此 参数就是 1</td></tr><tr><td>configRegister</td><td>未使用，函数 IOMUXC_SetPinConfig 会使用这个寄存器</td></tr><tr><td>inputOnfield</td><td>IO 软 件 输 入 使 能 ， 以 GPIO1_IO03 为 例 就 是 寄 存 器 SW_MUX_CTL_PAD_GPIO1_IO03 的 SION 位(bit4)。如果需要使能 GPIO1_IO03 的软件输入功 能的话此参数应该为 1，否则的话就为 0</td></tr></tbody></table><p>IOMUXC_SetPinMux 的函数体很简单，就是根据参数对寄存器 muxRegister 和 inputRegister 进行赋值</p><p>NXP 的 SDK 库将一个 IO 的所有复用功能都定义了一个宏</p><p>GPIO1_IO03 就有如下 9 个宏定义</p><p><em>IOMUXC_GPIO1_IO03_I2C1_SDA</em> </p><p><em>IOMUXC_GPIO1_IO03_GPT1_COMPARE3</em> </p><p><em>IOMUXC_GPIO1_IO03_USB_OTG2_OC</em> </p><p><em>IOMUXC_GPIO1_IO03_USDHC1_CD_B</em> </p><p><em>IOMUXC_GPIO1_IO03_GPIO1_IO03</em> </p><p><em>IOMUXC_GPIO1_IO03_CCM_DI0_EXT_CLK</em> </p><p><em>IOMUXC_GPIO1_IO03_SRC_TESTER_ACK</em> </p><p><em>IOMUXC_GPIO1_IO03_UART1_RX</em> </p><p><em>IOMUXC_GPIO1_IO03_UART1_TX</em></p><p>上面 9 个宏定义分别对应着 GPIO1_IO03 的九种复用功能，比如复用为 GPIO 的宏定义就是： <code>#define IOMUXC_GPIO1_IO03_GPIO1_IO03 0x020E0068U, 0x5U, 0x00000000U, 0x0U, 0x020E02F4U</code></p><p>即</p><p><code>IOMUXC_SetPinMux (0x020E0068U, 0x5U, 0x00000000U, 0x0U, 0x020E02F4U, 0);</code></p><p>函数 IOMUXC_SetPinConfig，在文件 fsl_iomuxc.h 中定义源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static inline void IOMUXC_SetPinConfig(uint32_t muxRegister,</span><br><span class="line"> uint32_t muxMode,</span><br><span class="line"> uint32_t inputRegister,</span><br><span class="line"> uint32_t inputDaisy,</span><br><span class="line"> uint32_t configRegister,</span><br><span class="line"> uint32_t configValue)</span><br><span class="line">&#123;</span><br><span class="line"> if (configRegister)</span><br><span class="line"> &#123;</span><br><span class="line"> *((volatile uint32_t *)configRegister) &#x3D; configValue;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cofigRegister 参数是 IO 配置寄存 器地址</p><p>参数 configValue 就是要写入到寄存器 configRegister 的值</p></li><li><p>编写 Makefile 和链接脚本</p><p>Makefile 文件内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1 CROSS_COMPILE ?&#x3D; arm-linux-gnueabihf2 NAME ?&#x3D; ledc</span><br><span class="line">3</span><br><span class="line">4 CC :&#x3D; $(CROSS_COMPILE)gcc</span><br><span class="line">5 LD :&#x3D; $(CROSS_COMPILE)ld</span><br><span class="line">6 OBJCOPY :&#x3D; $(CROSS_COMPILE)objcopy</span><br><span class="line">7 OBJDUMP :&#x3D; $(CROSS_COMPILE)objdump</span><br><span class="line">8</span><br><span class="line">9 OBJS :&#x3D; start.o main.o</span><br><span class="line">10</span><br><span class="line">11 $(NAME).bin:$(OBJS)</span><br><span class="line">12 $(LD) -Timx6ul.lds -o $(NAME).elf $^</span><br><span class="line">13 $(OBJCOPY) -O binary -S $(NAME).elf $@</span><br><span class="line">14 $(OBJDUMP) -D -m arm $(NAME).elf &gt; $(NAME).dis</span><br><span class="line">15</span><br><span class="line">16 %.o:%.s</span><br><span class="line">17 $(CC) -Wall -nostdlib -c -O2 -o $@ $&lt;</span><br><span class="line">18</span><br><span class="line">19 %.o:%.S</span><br><span class="line">20 $(CC) -Wall -nostdlib -c -O2 -o $@ $&lt;</span><br><span class="line">21</span><br><span class="line">22 %.o:%.c</span><br><span class="line">23 $(CC) -Wall -nostdlib -c -O2 -o $@ $&lt;</span><br><span class="line">24</span><br><span class="line">25 clean:</span><br><span class="line">26 rm -rf *.o $(NAME).bin $(NAME).elf $(NAME).dis</span><br></pre></td></tr></table></figure><p>链接 脚本 imx6ul.lds</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 SECTIONS&#123;</span><br><span class="line">2 . &#x3D; 0X87800000;</span><br><span class="line">3 .text :</span><br><span class="line">4 &#123;</span><br><span class="line">5 start.o</span><br><span class="line">6 main.o</span><br><span class="line">7 *(.text)</span><br><span class="line">8 &#125;</span><br><span class="line">9 .rodata ALIGN(4) : &#123;*(.rodata*)&#125;</span><br><span class="line">10 .data ALIGN(4) : &#123; *(.data) &#125;</span><br><span class="line">11 __bss_start &#x3D; .;</span><br><span class="line">12 .bss ALIGN(4) : &#123; *(.bss) *(COMMON) &#125;</span><br><span class="line">13 __bss_end &#x3D; .;</span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><h1 id="BSP-工程管理实验"><a href="#BSP-工程管理实验" class="headerlink" title="BSP 工程管理实验"></a>BSP 工程管理实验</h1></li></ul><p>不同的功能模块文件放到不同的文件夹中，比如驱动文 件就放到 HARDWARE 文件夹中，ST 的官方库就放到 STM32F10x_FWLib 文件夹中，编译产 生的过程文件放到 OBJ 文件夹中</p><ul><li><p>举栗举栗</p><p>新建名为“5_ledc_bsp”的文件夹，在里面新建 bsp、imx6ul、obj 和 project 这 4 个文件夹</p><p>其中 bsp 用来存放驱动文件；imx6ul 用来存放跟芯片有关的文件，比如 NXP 官方的 SDK 库文件；obj 用来存放编译生成的.o 文件；project 存放 start.S 和 main.c 文件，也就是应用文件；将 cc.h、fsl_common.h、fsl_iomuxc.h 和 MCIMX6Y2.h 这四个文件拷贝到文件 夹 imx6ul 中；将 start.S 和 main.c 这两个文件拷贝到文件夹 project 中</p><p>所有 的驱动相关的函数都写到了 main.c 文件中，比如函数 clk_enable、led_init 和 delay，这三个函数 可以分为三类：时钟驱动、LED 驱动和延时驱动</p><p>在 bsp 文件夹下创建三个子文 件夹：clk、delay 和 led，分别用来存放时钟驱动文件、延时驱动文件和 LED 驱动文件，这样 main.c 函数就会清爽很多，程序功能模块清晰</p></li><li><p>实验程序编写</p><ol><li><p>新建文件 imx6ul.h，然后保存到文件夹 imx6ul 中</p></li><li><p>新建 bsp_led.h 和 bsp_led.c 两个文件，将这两个文件存放到 bsp/led 中</p></li><li><p>新建 bsp_clk.h 和 bsp_clk.c 两个文件，将这两个文件存放到 bsp/clk 中</p></li><li><p>新建 bsp_delay.h 和 bsp_delay.c 两个文件，将这两个文件存放到 bsp/delay 中</p></li><li><p>修改 main.c 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1 #include &quot;bsp_clk.h&quot;</span><br><span class="line">2 #include &quot;bsp_delay.h&quot;</span><br><span class="line">3 #include &quot;bsp_led.h&quot;</span><br><span class="line">4</span><br><span class="line">5 &#x2F;*</span><br><span class="line">6 * @description : main 函数</span><br><span class="line">7 * @param : 无</span><br><span class="line">8 * @return : 无</span><br><span class="line">9 *&#x2F;</span><br><span class="line">10 int main(void)</span><br><span class="line">11 &#123;</span><br><span class="line">12 clk_enable(); &#x2F;* 使能所有的时钟 *&#x2F;</span><br><span class="line">13 led_init(); &#x2F;* 初始化 led *&#x2F;</span><br><span class="line">14</span><br><span class="line">15 while(1) </span><br><span class="line">16 &#123;</span><br><span class="line">17 &#x2F;* 打开 LED0 *&#x2F;</span><br><span class="line">18 led_switch(LED0,ON);</span><br><span class="line">19 delay(500);</span><br><span class="line">20</span><br><span class="line">21 &#x2F;* 关闭 LED0 *&#x2F;</span><br><span class="line">22 led_switch(LED0,OFF);</span><br><span class="line">23 delay(500);</span><br><span class="line">24 &#125;</span><br><span class="line">25</span><br><span class="line">26 return 0;</span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="6"><li><p>在工程根目录下新建 Makefile 和 imx6ul.lds 这两个文件</p><p>使用时候只要将所需要编译的源文件所在的目录添加到 Makefile 中即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1 CROSS_COMPILE ?&#x3D; arm-linux-gnueabihf2 TARGET ?&#x3D; bsp</span><br><span class="line">3</span><br><span class="line">4 CC :&#x3D; $(CROSS_COMPILE)gcc</span><br><span class="line">5 LD :&#x3D; $(CROSS_COMPILE)ld</span><br><span class="line">6 OBJCOPY :&#x3D; $(CROSS_COMPILE)objcopy</span><br><span class="line">7 OBJDUMP :&#x3D; $(CROSS_COMPILE)objdump</span><br><span class="line">8</span><br><span class="line">9 INCDIRS :&#x3D; imx6ul \</span><br><span class="line">10 bsp&#x2F;clk \</span><br><span class="line">11 bsp&#x2F;led \</span><br><span class="line">12 bsp&#x2F;delay</span><br><span class="line">13</span><br><span class="line">14 SRCDIRS :&#x3D; project \</span><br><span class="line">15 bsp&#x2F;clk \</span><br><span class="line">16 bsp&#x2F;led \</span><br><span class="line">17 bsp&#x2F;delay</span><br><span class="line">18</span><br><span class="line">19 INCLUDE :&#x3D; $(patsubst %, -I %, $(INCDIRS))</span><br><span class="line">20</span><br><span class="line">21 SFILES :&#x3D; $(foreach dir, $(SRCDIRS), $(wildcard $(dir)&#x2F;*.S))</span><br><span class="line">22 CFILES :&#x3D; $(foreach dir, $(SRCDIRS), $(wildcard $(dir)&#x2F;*.c))</span><br><span class="line">23</span><br><span class="line">24 SFILENDIR :&#x3D; $(notdir $(SFILES))</span><br><span class="line">25 CFILENDIR :&#x3D; $(notdir $(CFILES))</span><br><span class="line">26</span><br><span class="line">27 SOBJS :&#x3D; $(patsubst %, obj&#x2F;%, $(SFILENDIR:.S&#x3D;.o))</span><br><span class="line">28 COBJS :&#x3D; $(patsubst %, obj&#x2F;%, $(CFILENDIR:.c&#x3D;.o))</span><br><span class="line">29 OBJS :&#x3D; $(SOBJS) $(COBJS)</span><br><span class="line">30</span><br><span class="line">31 VPATH :&#x3D; $(SRCDIRS)</span><br><span class="line">32</span><br><span class="line">33 .PHONY: clean</span><br><span class="line">34</span><br><span class="line">35 $(TARGET).bin : $(OBJS)</span><br><span class="line">36 $(LD) -Timx6ul.lds -o $(TARGET).elf $^</span><br><span class="line">37 $(OBJCOPY) -O binary -S $(TARGET).elf $@</span><br><span class="line">38 $(OBJDUMP) -D -m arm $(TARGET).elf &gt; $(TARGET).dis</span><br><span class="line">39</span><br><span class="line">40 $(SOBJS) : obj&#x2F;%.o : %.S</span><br><span class="line">41 $(CC) -Wall -nostdlib -c -O2 $(INCLUDE) -o $@ $&lt;</span><br><span class="line">42</span><br><span class="line">43 $(COBJS) : obj&#x2F;%.o : %.c</span><br><span class="line">44 $(CC) -Wall -nostdlib -c -O2 $(INCLUDE) -o $@ $&lt;</span><br><span class="line">45</span><br><span class="line">46 clean:</span><br><span class="line">47 rm -rf $(TARGET).elf $(TARGET).dis $(TARGET).bin $(COBJS) $(SOBJS)</span><br></pre></td></tr></table></figure><p>第 1~7 行定义了一些变量，除了第 2 行以外其它的都是跟编译器有关的</p><p>第 2 行的变量 TARGET 目标名字，不同的程序名字不一样</p><p>第 9 行的变量 INCDIRS 包含整个工程的.h 头文件目录，文件中的所有头文件目录都要添 加到变量INCDIRS中。比如本程序中包含.h头文件的目录有imx6ul、bsp/clk、bsp/delay和bsp/led， 所以就需要在变量 INCDIRS 中添加这些目录，即: </p><p>INCDIRS := imx6ul bsp/clk bsp/led bsp/delay </p><p>发现第 9~11 行后面都会有一个符号“\”，这个相当于“换行符”，表示本行和下一行属于同一行，一般一行写不下的时候就用符号“\”来换行。后面需要根据实际情况来在变量 INCDIRS 中添加头文件目录</p><p>第 14 行是变量 SRCDIRS，和变量 INCDIRS 一样，只是 SRCDIRS 包含的是整个工程的所 有.c 和.S 文件目录。比如本程序包含有.c 和.S 的目录有 bsp/clk、bsp/delay、bsp/led 和 project， 即： </p><p>SRCDIRS := project bsp/clk bsp/led bsp/delay </p><p>后面需要根据实际情况在变量 SRCDIRS 中添加相应的文件目录。 </p><p>第 19 行的变量 INCLUDE 是用到了函数 patsubst，通过函数 patsubst 给变量 INCDIRS 添加 一个“-I”，即： </p><p>INCLUDE := -I imx6ul -I bsp/clk -I bsp/led -I bsp/delay </p><p>加“-I”的目的是因为 Makefile 语法要求指明头文件目录的时候需要加上“-I”。 </p><p>第 21 行变量 SFILES 保存工程中所有的.s 汇编文件(包含绝对路径)，变量 SRCDIRS 已经存放了工程中所有的.c 和.S 文件，所以我们只需要从里面挑出所有的.S 汇编文件即可，这里借助了函数 foreach 和函数 wildcard，最终 SFILES 如下：</p><p>SFILES := project/start.S </p><p>第 22 行变量 CFILES 和变量 SFILES 一样，只是 CFILES 保存工程中所有的.c 文件(包含绝 对路径)，最终 CFILES 如下： </p><p>CFILES = project/main.c bsp/clk/bsp_clk.c bsp/led/bsp_led.c bsp/delay/bsp_delay.c </p><p>第 24 和 25 行的变量 SFILENDIR 和 CFILENDIR 包含所有的.S 汇编文件和.c 文件，相比变 量 SFILES 和 CFILES，SFILENDIR 和 CFILNDIR 只是文件名，不包含文件的绝对路径。使用 函数 notdir 将 SFILES 和 CFILES 中的路径去掉即可，SFILENDIR 和 CFILENDIR 如下： SFILENDIR = start.S CFILENDIR = main.c bsp_clk.c bsp_led.c bsp_delay.c </p><p>第 27 和 28 行的变量 SOBJS 和 COBJS 是.S 和.c 文件编译以后对应的.o 文件目录，默认所 有的文件编译出来的.o 文件和源文件在同一个目录中，这里我们将所有的.o 文件都放到 obj 文 件夹下，SOBJS 和 COBJS 内容如下： </p><p>SOBJS = obj/start.o COBJS = obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o </p><p>第 29 行变量 OBJS 是变量 SOBJS 和 COBJS 的集合，如下： </p><p>OBJS = obj/start.o obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o </p><p>编译完成以后所有的.o 文件就全部存放到了 obj 目录下</p><p>第 31 行的 VPATH 是指定搜索目录的，这里指定的搜素目录就是变量 SRCDIRS 所保存的 目录，这样当编译的时候所需的.S 和.c 文件就会在 SRCDIRS 中指定的目录中查找。</p><p>第 33 行指定了一个伪目标 clean</p></li><li><p>imx6ul.lds 链接脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 SECTIONS&#123;</span><br><span class="line">2 . &#x3D; 0X87800000;</span><br><span class="line">3 .text :</span><br><span class="line">4 &#123;</span><br><span class="line">5 obj&#x2F;start.o</span><br><span class="line">6 *(.text)</span><br><span class="line">7 &#125;</span><br><span class="line">8 .rodata ALIGN(4) : &#123;*(.rodata*)&#125;</span><br><span class="line">9 .data ALIGN(4) : &#123; *(.data) &#125;</span><br><span class="line">10 __bss_start &#x3D; .;</span><br><span class="line">11 .bss ALIGN(4) : &#123; *(.bss) *(COMMON) &#125;</span><br><span class="line">12 __</span><br></pre></td></tr></table></figure><p>注意第 5 行设置的 start.o 文件路径</p></li></ol><hr><p>参考资料：正点原子《I.MX6U嵌入式Linux驱动开发指南V1.5》P354~376</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;官方-SDK-移植&quot;&gt;&lt;a href=&quot;#官方-SDK-移植&quot; class=&quot;headerlink&quot; title=&quot;官方 SDK 移植&quot;&gt;&lt;/a&gt;官方 SDK 移植&lt;/h1</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note11 点亮一盏灯C语言</title>
    <link href="https://chenzhan666.coding.me/2021/02/15/note11-%E7%82%B9%E4%BA%AE%E4%B8%80%E7%9B%8F%E7%81%AFC%E8%AF%AD%E8%A8%80/"/>
    <id>https://chenzhan666.coding.me/2021/02/15/note11-%E7%82%B9%E4%BA%AE%E4%B8%80%E7%9B%8F%E7%81%AFC%E8%AF%AD%E8%A8%80/</id>
    <published>2021-02-15T03:37:38.000Z</published>
    <updated>2021-02-15T06:03:52.622Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><p>简介</p><p>汇编只在开始部分用汇编来初始化一下 C 语言环境，比如初始化 DDR、 设置堆栈指针 SP 等等，当做完这些工作以后就可以进入 C 语言环境，也就是运行 C 语言代码，一般都是进入 main 函数有两部分文件要做：</p><ol><li>汇编文件 汇编文件只是用来完成 C 语言环境搭建</li><li>C 语言文件 C 语言文件就是完成我们的业务层代码的，其实就是我们实际例程要完成的功能</li></ol></li></ul><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a>实验程序编写</h1><p>新建 VScode 工程，工程名字为“ledc”，新建三个文件：start.S、main.c 和 main.h。其中 start.S 是汇编文件，main.c 和 main.h 是 C 语言相关文件</p><ul><li><p>汇编部分实验程序编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">示例代码 start.s 文件代码</span><br><span class="line">&#x2F;***************************************************************</span><br><span class="line">Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span><br><span class="line">文件名 : start.s</span><br><span class="line">作者 : 左忠凯</span><br><span class="line">版本 : V1.0</span><br><span class="line">描述 : I.MX6U-ALPHA&#x2F;I.MX6ULL 开发板启动文件，完成 C 环境初始化，</span><br><span class="line"> C 环境初始化完成以后跳转到 C 代码。</span><br><span class="line">其他 : 无</span><br><span class="line">日志 : 初版 2019&#x2F;1&#x2F;3 左忠凯修改</span><br><span class="line">**************************************************************&#x2F;</span><br><span class="line">1 .global _start &#x2F;* 全局标号 *&#x2F;</span><br><span class="line">2</span><br><span class="line">3 &#x2F;*</span><br><span class="line">4 * 描述： _start 函数，程序从此函数开始执行，此函数主要功能是设置 C</span><br><span class="line">5 * 运行环境。</span><br><span class="line">6 *&#x2F;</span><br><span class="line">7 _start:</span><br><span class="line">8</span><br><span class="line">9 &#x2F;* 进入 SVC 模式 *&#x2F;</span><br><span class="line">10 mrs r0, cpsr</span><br><span class="line">11 bic r0, r0, #0x1f &#x2F;* 将 r0 的低 5 位清零，也就是 cpsr 的 M0~M4 *&#x2F;</span><br><span class="line">12 orr r0, r0, #0x13 &#x2F;* r0 或上 0x13,表示使用 SVC 模式 *&#x2F;</span><br><span class="line">13 msr cpsr, r0 &#x2F;* 将 r0 的数据写入到 cpsr_c 中 *&#x2F;</span><br><span class="line">14</span><br><span class="line">15 ldr sp, &#x3D;0X80200000 &#x2F;* 设置栈指针 *&#x2F;</span><br><span class="line">16 b main &#x2F;* 跳转到 main 函数 *&#x2F;</span><br></pre></td></tr></table></figure><p>第 1 行定义了一个全局标号_start</p><p>第 7 行就是标号start 开始的地方，相当于是一个start 函数，这个_start 就是第一行代码</p><p>第 10<del>13 行就是设置处理器进入 SVC 模式(Cortex-A 有九个运行模型之一)，处理器模式的 设置是通过修改 CPSR(程序状态)寄存器来完成的，其中 M[4:0]就是设置处理器运行模式的，M[4:0]就要等于 0X13。11</del>13 行代码就是先使用指令 MRS 将 CPSR 寄存器的值读取到 R0 中，然后修改 R0 中的值，设置 R0 的 bit[4:0]为 0X13，然后再使用指令 MSR 将修改后的 R0 重新写入到 CPSR 中</p><p>第 15 行通过 ldr 指令设置 SVC 模式下的 SP 指针=0X80200000。由于 Cortex-A7 的堆栈是向下增长的，所以将 SP 指针设置为 0X80200000， 因此 SVC 模式的栈大小 0X80200000-0X80000000=0X200000=2MB</p><p>第 16 行就是跳转到 main 函数，main 函数就是 C 语言代码</p><p>汇编部分程序执行完成，就几行代码，用来设置处理器运行到 SVC 模式下、然后初始 化 SP 指针、最终跳转到 C 文件的 main 函数中</p><p>另外DDR3 不需要在 start.s 文 件中完成初始化，DCD 数据包含了 DDR 配置 参数，I.MX6U 内部的 Boot ROM 会读取 DCD 数据中的 DDR 配置参数然后完成 DDR 初始化</p></li></ul><ul><li><p>C 语言部分实验程序编写</p></li><li><p>C 语言部分有两个文件 main.c 和 main.h，main.h 里面主要是定义的寄存器地址，在 main.h 里面输入代码：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">示例代码 10.3.2.1 main.h 文件代码</span><br><span class="line">#ifndef __MAIN_H</span><br><span class="line">#define __MAIN_H</span><br><span class="line">&#x2F;******************************************************************</span><br><span class="line">Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span><br><span class="line">文件名 : main.h</span><br><span class="line">作者 : 左忠凯</span><br><span class="line">版本 : V1.0</span><br><span class="line">描述 : 时钟 GPIO1_IO03 相关寄存器地址定义。</span><br><span class="line">其他 : 无</span><br><span class="line">日志 : 初版 V1.0 2019&#x2F;1&#x2F;3 左忠凯创建</span><br><span class="line">*****************************************************************&#x2F;</span><br><span class="line">1 &#x2F;*</span><br><span class="line">2 * CCM 相关寄存器地址</span><br><span class="line">3 *&#x2F;</span><br><span class="line">4 #define CCM_CCGR0 *((volatile unsigned int *)0X020C4068)</span><br><span class="line">5 #define CCM_CCGR1 *((volatile unsigned int *)0X020C406C)</span><br><span class="line">6 #define CCM_CCGR2 *((volatile unsigned int *)0X020C4070)</span><br><span class="line">7 #define CCM_CCGR3 *((volatile unsigned int *)0X020C4074)</span><br><span class="line">8 #define CCM_CCGR4 *((volatile unsigned int *)0X020C4078)</span><br><span class="line">9 #define CCM_CCGR5 *((volatile unsigned int *)0X020C407C)</span><br><span class="line">10 #define CCM_CCGR6 *((volatile unsigned int *)0X020C4080)</span><br><span class="line">11</span><br><span class="line">12 &#x2F;*</span><br><span class="line">13 * IOMUX 相关寄存器地址</span><br><span class="line">14 *&#x2F;</span><br><span class="line">15 #define SW_MUX_GPIO1_IO03 *((volatile unsigned int *)0X020E0068)</span><br><span class="line">16 #define SW_PAD_GPIO1_IO03 *((volatile unsigned int *)0X020E02F4)</span><br><span class="line">17</span><br><span class="line">18 &#x2F;*</span><br><span class="line">19 * GPIO1 相关寄存器地址</span><br><span class="line">20 *&#x2F;</span><br><span class="line">21 #define GPIO1_DR *((volatile unsigned int *)0X0209C000)</span><br><span class="line">22 #define GPIO1_GDIR *((volatile unsigned int *)0X0209C004)</span><br><span class="line">23 #define GPIO1_PSR *((volatile unsigned int *)0X0209C008)</span><br><span class="line">24 #define GPIO1_ICR1 *((volatile unsigned int *)0X0209C00C)</span><br><span class="line">25 #define GPIO1_ICR2 *((volatile unsigned int *)0X0209C010)</span><br><span class="line">26 #define GPIO1_IMR *((volatile unsigned int *)0X0209C014)</span><br><span class="line">27 #define GPIO1_ISR *((volatile unsigned int *)0X0209C018)</span><br><span class="line">28 #define GPIO1_EDGE_SEL *((volatile unsigned int *)0X0209C01C)</span><br><span class="line">29</span><br><span class="line">30 #endif</span><br></pre></td></tr></table></figure><p>在 main.h 中以宏定义的形式定义了要使用到的所有寄存器，后面的数字就是其地址， 比如 CCM_CCGR0 寄存器的地址就是 0X020C4068</p><ul><li>在 main.c 里面输入如下所示代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">示例代码 10.3.2.2 main.c 文件代码</span><br><span class="line">&#x2F;**************************************************************</span><br><span class="line">Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span><br><span class="line">文件名 : main.c</span><br><span class="line">作者 : 左忠凯</span><br><span class="line">版本 : V1.0</span><br><span class="line">描述 : I.MX6U 开发板裸机实验 2 C 语言点灯</span><br><span class="line">使用 C 语言来点亮开发板上的 LED 灯，学习和掌握如何用 C 语言来</span><br><span class="line"> 完成对 I.MX6U 处理器的 GPIO 初始化和控制。</span><br><span class="line">其他 : 无</span><br><span class="line">日志 : 初版 V1.0 2019&#x2F;1&#x2F;3 左忠凯创建</span><br><span class="line">**************************************************************&#x2F;</span><br><span class="line">1 #include &quot;main.h&quot;</span><br><span class="line">2</span><br><span class="line">3 &#x2F;*</span><br><span class="line">4 * @description : 使能 I.MX6U 所有外设时钟</span><br><span class="line">5 * @param : 无</span><br><span class="line">6 * @return : 无</span><br><span class="line">7 *&#x2F;</span><br><span class="line">8 void clk_enable(void)</span><br><span class="line">9 &#123;</span><br><span class="line">10 CCM_CCGR0 &#x3D; 0xffffffff;</span><br><span class="line">11 CCM_CCGR1 &#x3D; 0xffffffff;</span><br><span class="line">12 CCM_CCGR2 &#x3D; 0xffffffff;</span><br><span class="line">13 CCM_CCGR3 &#x3D; 0xffffffff;</span><br><span class="line">14 CCM_CCGR4 &#x3D; 0xffffffff;</span><br><span class="line">15 CCM_CCGR5 &#x3D; 0xffffffff;</span><br><span class="line">16 CCM_CCGR6 &#x3D; 0xffffffff;</span><br><span class="line">17 &#125;</span><br><span class="line">18</span><br><span class="line">19 &#x2F;*</span><br><span class="line">20 * @description : 初始化 LED 对应的 GPIO</span><br><span class="line">21 * @param : 无</span><br><span class="line">22 * @return : 无</span><br><span class="line">23 *&#x2F;</span><br><span class="line">24 void led_init(void)</span><br><span class="line">25 &#123;</span><br><span class="line">26 &#x2F;* 1、初始化 IO 复用, 复用为 GPIO1_IO03 *&#x2F;</span><br><span class="line">27 SW_MUX_GPIO1_IO03 &#x3D; 0x5;</span><br><span class="line">28</span><br><span class="line">29 &#x2F;* 2、配置 GPIO1_IO03 的 IO 属性</span><br><span class="line">30 *bit 16:0 HYS 关闭</span><br><span class="line">31 *bit [15:14]: 00 默认下拉</span><br><span class="line">32 *bit [13]: 0 kepper 功能</span><br><span class="line">33 *bit [12]: 1 pull&#x2F;keeper 使能</span><br><span class="line">34 *bit [11]: 0 关闭开路输出</span><br><span class="line">35 *bit [7:6]: 10 速度 100Mhz</span><br><span class="line">36 *bit [5:3]: 110 R0&#x2F;6 驱动能力</span><br><span class="line">37 *bit [0]: 0 低转换率</span><br><span class="line">38 *&#x2F;</span><br><span class="line">SW_PAD_GPIO1_IO03 &#x3D; 0X10B0;</span><br><span class="line">40</span><br><span class="line">41 &#x2F;* 3、初始化 GPIO, GPIO1_IO03 设置为输出 *&#x2F;</span><br><span class="line">42 GPIO1_GDIR &#x3D; 0X0000008;</span><br><span class="line">43</span><br><span class="line">44 &#x2F;* 4、设置 GPIO1_IO03 输出低电平，打开 LED0 *&#x2F;</span><br><span class="line">45 GPIO1_DR &#x3D; 0X0;</span><br><span class="line">46 &#125;</span><br><span class="line">47</span><br><span class="line">48 &#x2F;*</span><br><span class="line">49 * @description : 打开 LED 灯</span><br><span class="line">50 * @param : 无</span><br><span class="line">51 * @return : 无</span><br><span class="line">52 *&#x2F;</span><br><span class="line">53 void led_on(void)</span><br><span class="line">54 &#123;</span><br><span class="line">55 &#x2F;*</span><br><span class="line">56 * 将 GPIO1_DR 的 bit3 清零</span><br><span class="line">57 *&#x2F;</span><br><span class="line">58 GPIO1_DR &amp;&#x3D; ~(1&lt;&lt;3);</span><br><span class="line">59 &#125;</span><br><span class="line">60</span><br><span class="line">61 &#x2F;*</span><br><span class="line">62 * @description : 关闭 LED 灯</span><br><span class="line">63 * @param : 无</span><br><span class="line">64 * @return : 无</span><br><span class="line">65 *&#x2F;</span><br><span class="line">66 void led_off(void)</span><br><span class="line">67 &#123;</span><br><span class="line">68 &#x2F;*</span><br><span class="line">69 * 将 GPIO1_DR 的 bit3 置 1</span><br><span class="line">70 *&#x2F;</span><br><span class="line">71 GPIO1_DR |&#x3D; (1&lt;&lt;3);</span><br><span class="line">72 &#125;</span><br><span class="line">73</span><br><span class="line">74 &#x2F;*</span><br><span class="line">75 * @description : 短时间延时函数</span><br><span class="line">76 * @param - n : 要延时循环次数(空操作循环次数，模式延时)</span><br><span class="line">77 * @return : 无</span><br><span class="line">78 *&#x2F;</span><br><span class="line">79 void delay_short(volatile unsigned int n)</span><br><span class="line">80 &#123;</span><br><span class="line">81 while(n--)&#123;&#125;</span><br><span class="line">82 &#125;</span><br><span class="line">83</span><br><span class="line">84 &#x2F;*</span><br><span class="line">85 * @description : 延时函数,在 396Mhz 的主频下延时时间大约为 1ms</span><br><span class="line">86 * @param - n : 要延时的 ms 数</span><br><span class="line">87 * @return : 无</span><br><span class="line">88 *&#x2F;</span><br><span class="line">89 void delay(volatile unsigned int n)</span><br><span class="line">90 &#123;</span><br><span class="line">91 while(n--)</span><br><span class="line">92 &#123;</span><br><span class="line">93 delay_short(0x7ff);</span><br><span class="line">94 &#125;</span><br><span class="line">95 &#125;</span><br><span class="line">96</span><br><span class="line">97 &#x2F;*</span><br><span class="line">98 * @description : main 函数</span><br><span class="line">99 * @param : 无</span><br><span class="line">100 * @return : 无</span><br><span class="line">101 *&#x2F;</span><br><span class="line">102 int main(void)</span><br><span class="line">103 &#123;</span><br><span class="line">104 clk_enable(); &#x2F;* 使能所有的时钟 *&#x2F;</span><br><span class="line">105 led_init(); &#x2F;* 初始化 led *&#x2F;</span><br><span class="line">106</span><br><span class="line">107 while(1) &#x2F;* 死循环 *&#x2F;</span><br><span class="line">108 &#123;</span><br><span class="line">109 led_off(); &#x2F;* 关闭 LED *&#x2F;</span><br><span class="line">110 delay(500); &#x2F;* 延时大约 500ms *&#x2F;</span><br><span class="line">111</span><br><span class="line">112 led_on(); &#x2F;* 打开 LED *&#x2F;</span><br><span class="line">113 delay(500); &#x2F;* 延时大约 500ms *&#x2F;</span><br><span class="line">114 &#125;</span><br><span class="line">115</span><br><span class="line">116 return 0;</span><br><span class="line">117 &#125;</span><br></pre></td></tr></table></figure><p>main.c 文件里面一共有 7 个函数</p><ol><li>clk_enable 函数是使能 CCGR0~CCGR6 所控制的所有外设时钟</li><li>led_init 函数是初始化 LED 灯所使用的 IO，包括设置 IO 的复用功能、IO 的属性配置和 GPIO 功能，最终控制 GPIO 输出低电平来打开 LED 灯</li><li> led_on 和 led_off 这两个函数看名字就知道，用来控制 LED 灯的亮灭的</li><li>delay_short()和 delay() 这两个函数是延时函数，delay_short()函数是靠空循环来实现延时的，delay()是对 delay_short() 的 简 单 封 装 ，在 I.MX6U 工作 在 396MHz(Boot ROM 设 置的 396MHz)的 主 频 的 时候 delay_short(0x7ff)基本能够实现大约 1ms 的延时，所以 delay()函数我们可以用来完成 ms 延时</li><li>main 函数就是我们的主函数了，在 main 函数中先调用函数 clk_enable()和 led_init()来完成时钟 使能和 LED 初始化，最终在 while(1)循环中实现 LED 循环亮灭，亮灭时间大约是 500ms。</li></ol><ul><li>编译下载验证</li><li>编写 Makefile</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例代码 10.3.2.2 main.c 文件代码</span><br><span class="line">1 objs :&#x3D; start.o main.o</span><br><span class="line">2</span><br><span class="line">3 ledc.bin:$(objs)</span><br><span class="line">4 arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf $^</span><br><span class="line">5 arm-linux-gnueabihf-objcopy -O binary -S ledc.elf $@</span><br><span class="line">6 arm-linux-gnueabihf-objdump -D -m arm ledc.elf &gt; ledc.dis</span><br><span class="line">7</span><br><span class="line">8 %.o:%.s</span><br><span class="line">9 arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o $@ $&lt;</span><br><span class="line">10</span><br><span class="line">11 %.o:%.S</span><br><span class="line">12 arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o $@ $&lt;</span><br><span class="line">13</span><br><span class="line">14 %.o:%.c</span><br><span class="line">15 arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o $@ $&lt;</span><br><span class="line">16</span><br><span class="line">17 clean:</span><br><span class="line">18 rm -rf *.o ledc.bin ledc.elf ledc.dis</span><br></pre></td></tr></table></figure><p>第 1 行定义了一个变量 objs，objs 包含着要生成 ledc.bin 所需的材料：start.o 和 main.o，也 就是当前工程下的 start.s 和 main.c 这两个文件编译后的.o 文件。这里要注意 start.o 一定要放到 最前面！因为在后面链接的时候 start.o 要在最前面，因为 start.o 是最先要执行的文件！ </p><p>第 3 行就是默认目标，目的是生成最终的可执行文件 ledc.bin，ledc.bin 依赖 start.o 和 main.o 如果当前工程没有 start.o 和 main.o 的时候就会找到相应的规则去生成 start.o 和 main.o。比如 start.o 是 start.s 文件编译生成的，因此会执行第 8 行的规则</p><p>第 4 行是使用 arm-linux-gnueabihf-ld 进行链接，链接起始地址是 0X87800000，但是这一行 用到了自动变量“$^”，“$^”的意思是所有依赖文件的集合，在这里就是 objs 这个变量的值： start.o 和 main.o。链接的时候 start.o 要链接到最前面，因为第一行代码就是 start.o 里面的，因 此这一行就相当于： </p><p>arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf start.o main.o </p><p>第 5 行使用 arm-linux-gnueabihf-objcopy 来将 ledc.elf 文件转为 ledc.bin，本行也用到了自动变量 “$@”，“$@”的意思是目标集合，在这里就是“ledc.bin”，那么本行就相当于： </p><p>arm-linux-gnueabihf-objcopy -O binary -S ledc.elf ledc.bin</p><p>第 6 行使用 arm-linux-gnueabihf-objdump 来反汇编，生成 ledc.dis 文件</p><p>第 8~15 行就是针对不同的文件类型将其编译成对应的.o 文件，其实就是汇编.s(.S)和.c 文 件，比如 start.s 就会使用第 8 行的规则来生成对应的 start.o 文件</p><p>第 9 行就是具体的命令，这 行也用到了自动变量“$@”和“$&lt;”，其中“$&lt;”的意思是依赖目标集合的第一个文件。比如 start.s 要编译成 start.o 的话第 8 行和第 9 行就相当于： </p><p>start.o:start.s arm-linux-gnueabihf-gcc -Wall -nostdlib -c -O2 -o start.o start.s </p><p>第 17 行就是工程清理规则，通过命令“make clean”就可以清理工程。 Makefile 文件做到这里，可以将整个工程拿到 Ubuntu 下去编译，编译完成以后可以使用 软件 imxdownload 将其下载到 SD 卡中，命令如下：</p><p> chmod 777 imxdownload //给予 imxdownoad 可执行权限，一次即可 </p><p>./imxdownload ledc.bin /dev/sdd //下载到 SD 卡中</p><ul><li><p>链接脚本</p><p>arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf $^ 上面语句中我们是通过“-Ttext”来指定链接地址是 0X87800000 的，这样的话所有的文件 都会链接到以 0X87800000 为起始地址的区域。但是有时候我们很多文件需要链接到指定的区 域，或者叫做段里面，比如在 Linux 里面初始化函数就会放到 init 段里面。因此我们需要能够 自定义一些段，这些段的起始地址我们可以自由指定，同样的我们也可以指定一个文件或者函 数应该存放到哪个段里面去。要完成这个功能我们就需要使用到链接脚本，看名字就知道链接 脚本主要用于链接的，用于描述文件应该如何被链接在一起形成最终的可执行文件。其主要目 的是描述输入文件中的段如何被映射到输出文件中，并且控制输出文件中的内存排布。比如我 们编译生成的文件一般都包含 text 段、data 段等等</p><p>链接脚本的语法很简单，就是编写一系列的命令，这些命令组成了链接脚本，每个命令是 一个带有参数的关键字或者一个对符号的赋值，可以使用分号分隔命令。像文件名之类的字符 串可以直接键入，也可以使用通配符“*”。最简单的链接脚本可以只包含一个命令“SECTIONS”, 我们可以在这一个“SECTIONS”里面来描述输出文件的内存布局。我们一般编译出来的代码 都包含在 text、data、bss 和 rodata 这四个段内，假设现在的代码要被链接到 0X10000000 这个 地址，数据要被链接到 0X30000000 这个地方，下面就是完成此功能的最简单的链接脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例代码 10.4.2.1 链接脚本演示代码</span><br><span class="line">1 SECTIONS&#123;</span><br><span class="line">2 . &#x3D; 0X10000000;</span><br><span class="line">3 .text : &#123;*(.text)&#125;</span><br><span class="line">4 . &#x3D; 0X30000000;</span><br><span class="line">5 .data ALIGN(4) : &#123; *(.data) &#125;</span><br><span class="line">6 .bss ALIGN(4) : &#123; *(.bss) &#125;</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure><p>第 1 行我们先写了一个关键字“SECTIONS”，后面跟了一个大括号，这个大括号和第 7 行 的大括号是一对</p><p>第 2 行对一个特殊符号“.”进行赋值，“.”在链接脚本里面叫做定位计数器，默认的定位 计数器为 0。我们要求代码链接到以 0X10000000 为起始地址的地方，因此这一行给“.”赋值0X10000000，表示以 0X10000000 开始，后面的文件或者段都会以 0X10000000 为起始地址开 始链接</p><p>第 3 行的“.text”是段名，后面的冒号是语法要求，冒号后面的大括号里面可以填上要链 接到“.text”这个段里面的所有文件，“*(.text)”中的“*”是通配符，表示所有输入文件的.text 段都放到“.text”中</p><p>第 4 行，我们的要求是数据放到 0X30000000 开始的地方，所以我们需要重新设置定位计 数器“.”，将其改为 0X30000000</p><p>第 5 行跟第 3 行一样，定义了一个名为“.data”的段，然后所有文件的“.data”段都放到 这里面。但是这一行多了一个“ALIGN(4)”，这是什么意思呢？这是用来对“.data”这个段的起 始地址做字节对齐的，ALIGN(4)表示 4 字节对齐。也就是说段“.data”的起始地址要能被 4 整 除，一般常见的都是 ALIGN(4)或者 ALIGN(8)，也就是 4 字节或者 8 字节对齐</p><p>第 6 行定义了一个“.bss”段，所有文件中的“.bss”数据都会被放到这个里面，“.bss”数 据就是那些定义了但是没有被初始化的变量</p><p>本试验的链接脚本要求如下：</p><p> 、链接起始地址为 0X87800000</p><p> 、start.o 要被链接到最开始的地方，因为 start.o 里面包含这第一个要执行的命令</p><p>根据要求，在 Makefile 同目录下新建一个名为“imx6ul.lds”的文件，然后在此文件里面输 入如下所示代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例代码 10.4.2.2 imx6ul.lds 链接脚本代码</span><br><span class="line">1 SECTIONS&#123;</span><br><span class="line">2 . &#x3D; 0X87800000;</span><br><span class="line">3 .text :</span><br><span class="line">4 &#123;</span><br><span class="line">5 start.o</span><br><span class="line">6 main.o</span><br><span class="line">7 *(.text)</span><br><span class="line">8 &#125;</span><br><span class="line">9 .rodata ALIGN(4) : &#123;*(.rodata*)&#125;</span><br><span class="line">10 .data ALIGN(4) : &#123; *(.data) &#125;</span><br><span class="line">11 __bss_start &#x3D; .;</span><br><span class="line">12 .bss ALIGN(4) : &#123; *(.bss) *(COMMON) &#125;</span><br><span class="line">13 __bss_end &#x3D; .;</span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><p>第 2 行设置定位计数器为 0X87800000，因为我们的链接地址就是0X87800000。第5行设置链接到开始位置的文件为start.o， 因为 start.o 里面包含着第一个要执行的指令，所以一定要链接到最开始的地方。第 6 行是 main.o 这个文件，其实可以不用写出来，因为 main.o 的位置就无所谓了，可以由编译器自行决定链接 位置。在第 11、13 行有“__bss_start”和“__bss_end”这两个东西？这个是什么呢？“__bss_start” 和“__bss_end”是符号，第 11、13 这两行其实就是对这两个符号进行赋值，其值为定位符“.”， 这两个符号用来保存.bss 段的起始地址和结束地址。.bss 段是定义了但是没有被初始化的变量，我们需要手动对.bss 段的变量清零的，因此我们需要知道.bss 段的起始和结束地址， 这样我们直接对这段内存赋 0 即可完成清零。通过第 11、13 行代码，.bss 段的起始地址和结束 地址就保存在了“__bss_start”和“__bss_end”中，我们就可以直接在汇编或者 C 文件里面使 用这两个符号</p></li><li><p>修改 Makefile</p><p>使用这个链接脚 本文件的，将 Makefile 中的如下一行代码： </p><p>arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf $^</p><p>改为： </p><p>arm-linux-gnueabihf-ld -Timx6ul.lds -o ledc.elf $^</p><p>其实就是将-T 后面的 0X87800000 改为 imx6ul.lds，表示使用 imx6ul.lds 这个链接脚本文 件</p></li><li><p>下载验证</p><p>chmod 777 imxdownload //给予 imxdownload 可执行权限，一次即可</p><p>./imxdownload ledc.bin /dev/sdd //烧写到 SD 卡中 </p><p>烧写成功以后将 SD 卡插到开发板的 SD 卡槽中，然后复位开发板，如果代码运行正常的 话 LED0 就会以 500ms 的时间间隔亮灭</p></li></ul><hr><p>参考资料：正点原子《I.MX6U嵌入式Linux驱动开发指南V1.5》P332~343</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简介&lt;/p&gt;
&lt;p&gt;汇编只在开始部分用汇编来初始化一下 C 语言环境，比如初始化 DDR、 设置堆栈指针 SP 等等，当做完这些工作以后就可以进入 C 语言环境，也</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note10 I.MX6U启动方式</title>
    <link href="https://chenzhan666.coding.me/2021/02/14/note10-I-MX6U%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://chenzhan666.coding.me/2021/02/14/note10-I-MX6U%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2021-02-14T14:36:40.000Z</published>
    <updated>2021-02-26T09:58:37.444Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><p>启动方式选择</p><p>BOOT 的处理过程是发生在 I.MX6U 芯片上电以后，芯片会根据 BOOT_MODE[1:0]的设置 来选择 BOOT 方式</p><p>BOOT_MODE[1:0]的值可以改变，有两种方式，一是改写 eFUSE(熔 丝)，一是修改相应的 GPIO 高低电平。修改 eFUSE 的方式只能修改一次，后面就不能再修改了，不使用。选择通过修改BOOT_MODE[1:0]对应的 GPIO 高低电平来选择启动方式，I.MX6U 有一个 BOOT_MODE1 引脚和 BOOT_MODE0 引脚，这两个引脚对应着 BOOT_MODE[1:0]</p><p>BOOT_MODE1 和 BOOT_MODE0 在芯片内部是有 100KΩ下拉电阻的，所以默认是 0</p><p>I.MX6U 有四个 BOOT 模式，这四个 BOOT 模式由 BOOT_MODE[1:0]来控制</p><table><thead><tr><th>BOOT_MODE[1:0]</th><th>BOOT 类型</th></tr></thead><tbody><tr><td>00</td><td>从 FUSE 启动</td></tr><tr><td>01</td><td>串行下载</td></tr><tr><td>10</td><td>内部 BOOT 模式</td></tr><tr><td>11</td><td>保留</td></tr></tbody></table></li><li><p>串行下载</p><p>当 BOOT_MODE1 为 0，BOOT_MODE0 为 1 的时候此模式使能，串行下载的意思就是可 以通过 USB 或者 UART 将代码下载到板子上的外置存储设备中</p></li><li><p>内部BOOT模式</p><p>芯片会执 行内部的 boot ROM 代码，这段 boot ROM 代码会进行硬件初始化(一部分外设)，然后从 boot 设 备(就是存放代码的设备、比如 SD/EMMC、NAND)中将代码拷贝出来复制到指定的 RAM 中， 一般是 DDR</p></li><li><p>BOOT ROM初始化模式</p><p>设置 BOOT 模式为“内部 BOOT 模式”以后，I.MX6U 内部的 boot ROM 代码就会执行，这个boot ROM代码首先肯定初始化时钟</p><p>boot ROM 会将 I.MX6U 的内核时钟设置为 396MHz，也就是主频为 396Mhz。System PLL=528Mhz，USB PLL=480MHz，AHB=132MHz， IPG=66MHz</p><p>内部 boot ROM 为了加快执行速度会打开 MMU 和 Cache，下载镜像的时候 L1 ICache 会打 开，验证镜像的时候 L1 DCache、L2 Cache 和 MMU 都会打开。一旦镜像验证完成，boot ROM 就会关闭 L1 DCache、L2 Cache 和 MMU。 中断向量偏移会被设置到 boot ROM 的起始位置，当 boot ROM 启动了用户代码以后就可 以重新设置中断向量偏移了。一般是重新设置到我们用户代码的开始地方</p></li><li><p>启动设备</p><p>当 BOOT_MODE 设置为内部 BOOT 模式以后，可以从以下设备中启动：</p><ol><li>接到 EIM 接口的 CS0 上的 16 位 NOR Flash</li><li>接到 EIM 接口的 CS0 上的 OneNAND Flash</li><li>接到 GPMI 接口上的 MLC/SLC NAND Flash，NAND Flash 页大小支持 2KByte、4KByte 和 8KByte，8 位宽</li><li>Quad SPI Flash</li><li>接到 USDHC 接口上的 SD/MMC/eSD/SDXC/eMMC 等设备 </li><li>SPI 接口的 EEPROM</li></ol><p>通过 GPIO 来选择启动设备</p><p>如启动模式由 BOOT_MODE[1:0]来选择一样，启动设备是通过BOOT_CFG1[7:0]、BOOT_CFG2[7:0]和 BOOT_CFG4[7:0]这 24 个配置 IO，这 24 个配置 IO 刚 好对应着 LCD 的 24 根数据线 LCD_DATA0~LCDDATA23，当启动完成以后这 24 个 IO 就可以 作为 LCD 的数据线使用。这 24 根线和 BOOT_MODE1、BOOT_MODE0 共同组成了 I.MX6U 的启动选择引脚</p><p>实际需要调整的只有那几个 IO，其它的 IO 全部下拉 接地即可，也就是设置为 0</p><table><thead><tr><th>BOOT_CFG 引脚</th><th>对应LCD 引脚</th><th>含义</th></tr></thead><tbody><tr><td>BOOT_CFG2[3]</td><td>LCD_DATA11</td><td>为0 时从 SDHC1 上的 SD/EMMC 启动，为 1 时从SDHC2 上的  SD/EMMC 启动</td></tr><tr><td>BOOT_CFG1[3]</td><td>LCD_DATA3</td><td>当从  SD/EMMC 启动的时候设置启动速度，当从 NAND 启动的话设置 NAND 数量</td></tr><tr><td>BOOT_CFG1[4]</td><td>LCD_DATA4</td><td>BOOT_CFG1[7:4]：     0000 NOR/OneNAND(EIM)启动。     0001 QSPI 启动。     0011 SPI 启动。     010x SD/eSD/SDXC 启动。     011x MMC/eMMC 启动。     1xxx NAND Flash 启动。</td></tr><tr><td>BOOT_CFG1[5]</td><td>LCD_DATA5</td><td>同上BOOT_CFG1[4]</td></tr><tr><td>BOOT_CFG1[6]</td><td>LCD_DATA6</td><td>同上BOOT_CFG1[4]</td></tr><tr><td>BOOT_CFG1[7]</td><td>LCD_DATA7</td><td>同上BOOT_CFG1[4]</td></tr></tbody></table></li><li><p>镜像烧写</p><p>bin 文件添加的头部信息</p><p>需要在.bin 文件前面添加一些头信息构成 满足 I.MX6U 需求的最终可烧写文件，I.MX6U 的最终可烧写文件组成如下：</p><ol><li>Image vector table，简称 IVT，IVT 里面包含了一系列的地址信息，这些地址信息在 ROM 中按照固定的地址存放着</li><li>Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等</li><li>Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置</li><li>用户代码可执行文件，比如 led.bin</li></ol><p>最终烧写到 I.MX6U 中的程序其组成为：IVT+Boot data+DCD+.bin</p><p>内部 Boot ROM 会将 load.imx 拷贝到 DDR 中，用户代码是要一定要从 0X87800000 这个地方开始的，因 为链接地址为 0X87800000，load.imx 在用户代码前面又有 3KByte 的 IVT+Boot Data+DCD 数 据，因此 load.imx 在 DDR 中的起始地址就是 0X87800000- 3072=0X877FF400</p></li><li><p>IVT和Boot Data数据</p><p>IVT 包含了镜像程序的入口点、指向 DCD 的指 针和一些用作其它用途的指针。内部 Boot ROM 要求 IVT 应该放到指定的位置，不同的启动设 备位置不同，而 IVT 在整个 load.imx 的最前面，其实就相当于要求 load.imx 在烧写的时候应该 烧写到存储设备的指定位置去。整个位置都是相对于存储设备的起始地址的偏移</p><p>SD/EMMC 为例，IVT 偏移为 1Kbyte（两个512字节），IVT+Boot data+DCD 的总大小为4KByte1KByte=3KByte</p><p>假如 SD/EMMC 每个扇区为 512 字节，那么 load.imx 应该从第三个扇区开始 烧写，前两个扇区要留出来</p><p>扇区，是指磁盘上划分的区域。磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区，硬盘的读写以扇区为基本单位</p><p>第一个存放的就是 header(头)</p><p>Tag 为一个字节长度，固定为 0XD1，Length 是两个字节，保存着 IVT 长 度，为大端格式，也就是高字节保存在低内存中。最后的 Version 是一个字节，为 0X40 或者0X41</p><p>软件winhex 可以直接 查看一个文件的二进制格式数据</p><table><thead><tr><th>offset</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>00000000</td><td>D1</td><td>00</td><td>20</td><td>40</td></tr></tbody></table><p>据按照 4 个字节一组组合在一起就是：0X402000D1</p><p>44 个字节的数据就是 IVT 和 Boot Data 数据</p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note10-I-MX6U启动方式\image-20210215014640520.png" alt="image-20210215014640520"></p><p><img src="/Personalwebsite/blog/myBlog/.me//Personalwebsite\blog\myBlog\source_posts\note10-I-MX6U启动方式\image-20210215014703327.png" alt="image-20210215014703327"></p></li><li><p>DCD数据</p><p> I.MX6U 提出了一个 DCD(Device Config Data)的概念</p><p>DCD 也是添加到 load.imx 里面的，紧跟在 IVT 和 Boot Data 后面，IVT 里面也指定了 DCD 的位置。DCD 其实就是 I.MX6U 寄存器地址和对应 的配置信息集合，Boot ROM 会使用这些寄存器地址和配置集合来初始化相应的寄存器，比如 开启某些外设的时钟、初始化 DDR 等等。DCD 区域不能超过 1768Byte</p><p>其中 Tag 是单字节，固定为 0XD2，Length 为两个字节，表示 DCD 区域的大小，包含 header， 同样是大端模式，Version 是单字节，固定为 0X40 或者 0X41</p><p>CMD 就是要初始化的寄存器地址和相应的寄存器值</p><p>Tag 为一个字节，固定为 0XCC。Length 是两个字节，包含写入的命令数据长 度，包含 header，同样是大端模式。Parameter 为一个字节</p><p>其中各个位 bytes 表示是目标位置宽度，单位为 byte，可以选择 1、2、和 4 字节。flags 是命令控制标志位</p><p>Address 和 Vlalue/Mask 就是要初始化的寄存器地址和相应的寄存器值，采用的是大端模式</p><p>DCD 数据是从 0X2C 地址开始的</p></li></ul><p>  大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p><p>  小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值</p><p>  DCD 里面的初始化配置主要包括三方面：</p><ol><li>设置 CCGR0~CCGR6 这 7 个外设时钟使能寄存器，默认打开所有的外设时钟</li><li>配置 DDR3 所用的所有 IO</li><li>配置 MMDC 控制器，初始化 DDR3</li></ol><p>  I.MX6U 的启动模式、启 动设备类型和镜像烧写过程，需要在.bin 文件前面加上 IVT、Boot Data 和 DCD 这三个数据块。这三个数据块是有指定格式的， 我们必须按照格式填写，然后将其放到.bin 文件前面，最终合成的才是可以直接烧写到 SD 卡 中的文件</p><hr><p>  参考资料：正点原子《I.MX6U嵌入式Linux驱动开发指南V1.5》P320~331</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;启动方式选择&lt;/p&gt;
&lt;p&gt;BOOT 的处理过程是发生在 I.MX6U 芯片上电以后，芯片会根据 BOOT_MODE[1:0]的设置 来选择 BOOT 方式&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note9 点亮一盏LED灯</title>
    <link href="https://chenzhan666.coding.me/2021/02/13/note9-%E7%82%B9%E4%BA%AE%E4%B8%80%E7%9B%8FLED%E7%81%AF/"/>
    <id>https://chenzhan666.coding.me/2021/02/13/note9-%E7%82%B9%E4%BA%AE%E4%B8%80%E7%9B%8FLED%E7%81%AF/</id>
    <published>2021-02-13T15:24:26.000Z</published>
    <updated>2021-02-13T17:21:59.221Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>GPIO通用型输入输出，类似于8051的P0-P3</p><p>GPIO_SetBits输出高</p><p>GPIO_ResetBits输出低</p><p>输出端对负载供电拉电流</p><p>输出端吸收负载电拉电流</p><ul><li><p>I.MX6U IO命名</p><p>参考I.MX6UL参考手册的第30章“Chapter 30: IOMUX Controller(IOMUXC)”</p><p>命名形式就是“IOMUXC_SW_MUC_CTL_PAD_XX_XX”，后面的“XX_XX”就是 GPIO 命名</p></li><li><p>IO复用</p><p>通过</p><p>Address:20E_0000h base+5Ch offset=20E_005Ch</p><p>可以得到</p><p>寄存器地址为0X020E005C</p><p>寄存器是 32 位的，但是只用到了最低5 位，其中bit0~bit3(MUX_MODE)就是设置 GPIO1_IO00 的复用功能的</p><p>GPIO1_IO00 一共可以复用为 9种功能 IO，分别对应 ALT0~ALT8，其中 ALT5 就是作为 GPIO1_IO00</p><p>某个 IO 要作为某个外设引脚使用的话，是需要配置复用寄存器的</p></li><li><p>寄存器 IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO00 的各个位的含义：</p><ul><li><p>HYS(bit16)</p><p>当 IO 作为输入功能的时候有效，用于设置输入接收器的施密特触发器是否使能。如果需要对输入波形进行整形的话可以使能此位。此位为 0 的时候禁止迟滞比较器，为 1 的时候使能迟滞比较器</p></li><li><p>PUS(bit15:14)</p><p>用来设置上下拉电阻的，一共有四种选项可以选择，如下所示：</p><table><thead><tr><th>位设置</th><th>含义</th></tr></thead><tbody><tr><td>00</td><td>100K 下拉</td></tr><tr><td>01</td><td>47K 上拉</td></tr><tr><td>10</td><td>100K 上拉</td></tr><tr><td>11</td><td>22K 上拉</td></tr></tbody></table></li><li><p>PUE(bit13)</p><p>当 IO 作为输入的时候，这个位用来设置 IO 使用上下拉还是状态保持器。当为 0 的时候使用状态保持器，当为 1 的时候使用上下拉。状态保持器在IO 作为输入的时候才有用，即当外部电路断电以后此 IO 口可以保持住以前的状态</p></li><li><p>PKE(bit12)</p><p>用来使能或者禁止上下拉/状态保持器功能，为0 时禁止上下拉/状态保持器，为 1 时使能上下拉和状态保持器</p></li><li><p>ODE(bit11)</p><p>当 IO 作为输出的时候，此位用来禁止或者使能开路输出，此位为 0 的时候禁止开路输出，当此位为 1 的时候就使能开路输出功能</p></li><li><p>SPEED(bit7:6)</p><p>当 IO 用作输出的时候，此位用来设置 IO 速度，设置如下所示：</p><table><thead><tr><th>位设置</th><th>速度</th></tr></thead><tbody><tr><td>00</td><td>低速 50M</td></tr><tr><td>01</td><td>中速 100M</td></tr><tr><td>10</td><td>中速 100M</td></tr><tr><td>11</td><td>最大速度 200M</td></tr></tbody></table></li><li><p>DSE(bit5:3)</p><p>当 IO 用作输出的时候用来设置 IO 的驱动能力，总共有 8 个可选选项，如下所示：</p><table><thead><tr><th>位设置</th><th>速度</th></tr></thead><tbody><tr><td>000</td><td>输出驱动关闭</td></tr><tr><td>001</td><td>R0(3.3V 下 R0 是 260Ω，1.8V 下 R0 是 150Ω，接 DDR 的时候是 240Ω)</td></tr><tr><td>010</td><td>R0/2</td></tr><tr><td>011</td><td>R0/3</td></tr><tr><td>100</td><td>R0/4</td></tr><tr><td>101</td><td>R0/5</td></tr><tr><td>110</td><td>R0/6</td></tr><tr><td>111</td><td>R0/7</td></tr></tbody></table></li><li><p>SRE(bit0)</p><p>设置压摆率，当此位为 0 的时候是低压摆率，当为 1的时候是高压摆率。这里的压摆率就是 IO 电平跳变所需要的时间，比如从 0 到 1 需要多少时间，时间越小波形就越陡，说明压摆率越高；反之，时间越多波形就越缓，压摆率就越低。如果你的产品要过 EMC 的话那就可以使用小的压摆率，因为波形缓和，如果你当前所使用的 IO做高速通信的话就可以使用高压摆率。</p></li></ul></li></ul><pre><code>寄存器 IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO00 是用来配置 GPIO1_IO00 的，包括速度设置、驱动能力设置、压摆率设置等等注意区别IOMUXC_SW_**MUX**_CTL_PAD_GPIO1_IO00IOMUXC_SW_**PAD**_CTL_PAD_GPIO1_IO00</code></pre><h1 id="GPIO-配置"><a href="#GPIO-配置" class="headerlink" title="GPIO 配置"></a>GPIO 配置</h1><p>  如果我们要用 GPIO1_IO00 来点个灯、作为按键输入啥的就是使用其 GPIO(通用输入输出)的功能。将其复用为 GPIO 以后还需要对其 GPIO 的功能进行配置</p><ul><li><p>DR</p><p>寄存器是数据寄存器</p><p>DR 寄存器中的每个位都对应一个 GPIO。当 GPIO 被配置为输出功能以后，向指定的位写入数据那么相应的 IO 就会输出相应的高低电平，比如要设置 GPIO1_IO00 输出高电平，那么就应该设置 GPIO1.DR=1。当 GPI被配置为输入模式以后，此寄存器就保存着对应 IO 的电平值，每个位对对应一个 GPIO，例如，当 GPIO1_IO00 这个引脚接地的话，那么 GPIO1.DR 的 bit0 就是 0</p></li><li><p>GDIR </p><p>寄存器，这是方向寄存器，用来设置某个 GPIO 的工作方向的，即输入/输出</p><p>每个 IO 对应一个位，如果要设置 GPIO 为输入的话就设置相应的位为 0，如果要设置为</p><p>输出的话就设置为 1。比如要设置 GPIO1_IO00 为输入，那么 GPIO1.GDIR=0</p></li><li></li><li><p>PSR 寄存器</p><p>寄存器，是 GPIO 状态寄存器</p><p>读取相应的位即可获取对应的 GPIO 的状态，也就是 GPIO 的高低电平值。</p></li><li><p>ICR1和ICR2</p><p>这两个寄存器，都是中断控制寄存器，ICR1用于配置低16个GPIO，ICR2 用于配置高 16 个 GPIO</p><p>ICR1 用于 IO0<del>15 的配置， ICR2 用于 IO16</del>31 的配置。ICR1 寄存器中一个 GPIO 用两个位，这两个位用来配置中断的触发方式</p><table><thead><tr><th>00</th><th>低电平触发</th></tr></thead><tbody><tr><td>01</td><td>高电平触发</td></tr><tr><td>10</td><td>上升沿触发</td></tr><tr><td>11</td><td>下降沿触发</td></tr></tbody></table></li><li><p>IMR 寄存器</p><p>这是中断屏蔽寄存器</p><p>IMR 寄存器用来控制 GPIO 的中断禁止和使能，如果使能某个 GPIO 的中断，那么设置相应的位为 1 即可，反之，如果要禁止中断，那么就设置相应的位为 0 即可</p></li><li><p>ISR 是中断状态寄存器</p><p>只要某个 GPIO 的中断发生，那么ISR 中相应的位就会被置 1。所以，我们可以通过读取 ISR 寄存器来判断 GPIO 中断是否发生，相当于 ISR 中的这些位就是中断标志位。当我们处理完中断以后，必须清除中断标志位，清除方法就是向 ISR 中相应的位写 1，也就是写 1 清零</p></li><li><p>EDGE_SEL 寄存器</p><p>这是边沿选择寄存器</p><p>EDGE_SEL 寄存器用来设置边沿中断，这个寄存器会覆盖 ICR1 和 ICR2 的设置，同样是一个 GPIO 对应一个位。如果相应的位被置 1，那么就相当与设置了对应的 GPIO 是上升沿和下降沿(双边沿)触发</p></li><li><p>时钟使能</p><p>如果要使用某个外设的话必须要先使能其时钟</p><h1 id="CCM-CCGR0-是个-32-为寄存器，其中每-2-位控制一个外设的时钟，比如-bit31-30-控制着"><a href="#CCM-CCGR0-是个-32-为寄存器，其中每-2-位控制一个外设的时钟，比如-bit31-30-控制着" class="headerlink" title="CCM_CCGR0 是个 32 为寄存器，其中每 2 位控制一个外设的时钟，比如 bit31:30 控制着"></a>CCM_CCGR0 是个 32 为寄存器，其中每 2 位控制一个外设的时钟，比如 bit31:30 控制着</h1><p>GPIO2 的外设时钟，两个位就有 4 中操作方式，如下所示：</p><table><thead><tr><th>位设置</th><th>时钟控制</th></tr></thead><tbody><tr><td>00</td><td>所有模式下都关闭外设时钟</td></tr><tr><td>01</td><td>只有在运行模式下打开外设时钟，等待模式和停止模式下均关闭外设时钟</td></tr><tr><td>10</td><td>未使用(保留)</td></tr><tr><td>11</td><td>除了停止模式以外，其他所有模式下时钟都打开</td></tr></tbody></table><p>要将 I.MX6U 的 IO 作为 GPIO 使用，需要以下几步：</p></li></ul><ol><li><pre><code> 使能 GPIO 对应的时钟。</code></pre></li><li><pre><code> 设置寄存器 IOMUXC_SW_MUX_CTL_PAD_XX_XX，设置 IO 的复用功能，使其复用为 GPIO 功能。</code></pre></li><li><pre><code> 设置寄存器 IOMUXC_SW_PAD_CTL_PAD_XX_XX，设置 IO 的上下拉、速度等等。</code></pre></li><li><p>   第②步已经将 IO 复用为了 GPIO 功能，所以需要配置 GPIO，设置输入/输出、是否使用中断、默认输出电平等。</p></li></ol><h1 id="硬件原理分析"><a href="#硬件原理分析" class="headerlink" title="硬件原理分析"></a>硬件原理分析</h1><p>LED0 接到了 GPIO_3 上，GPIO_3 就是 GPIO1_IO03，当 GPIO1_IO03输出低电平(0)的时候发光二极管 LED0 就会导通点亮，当 GPIO1_IO03 输出高电平(1)的时候发光二极管 LED0 不会导通，因此 LED0 也就不会点亮。所以 LED0 的亮灭取决于 GPIO1_IO03的输出电平，输出 0 就亮，输出 1 就灭</p><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a>实验程序编写</h1><p>需要对 GPIO1_IO03 做如下设置：</p><ol><li><p>使能 GPIO1 时钟</p><p>GPIO1 的时钟由 CCM_CCGR1 的 bit27 和 bit26 这两个位控制，将这两个位都设置位 11 即可。</p></li><li><p>设置 GPIO1_IO03 的复用功能</p><p>找到 GPIO1_IO03 的复用寄存器“IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03”的地址为0X020E0068，然后设置此寄存器，将 GPIO1_IO03 这个 IO 复用为 GPIO 功能，也就是 ALT5。</p></li><li><p>配置 GPIO1_IO03</p><p>找到 GPIO1_IO03 的配置寄存器“IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03”的地址为0X020E02F4，根据实际使用情况，配置此寄存器。</p></li><li><p>设置 GPIO</p><p>已经将 GPIO1_IO03 复用为了 GPIO 功能，需要配置 GPIO。找到 GPIO3 对应的 GPIO 组寄存器地址，在《IMX6ULL 参考手册》的 1357 页， 本实验中 GPIO1_IO03 是作为输出功能的，因此 GPIO1_GDIR 的 bit3 要设置为 1，表示输出。</p></li><li><p>控制 GPIO 的输出电平</p><p>GPIO1_IO03 已经配置好了，只需要向 GPIO1_DR 寄存器的 bit3 写入 0 即可控制 GPIO1_IO03 输出低电平，打开 LED，向 bit3 写入 1 可控制 GPIO1_IO03 输出高电平，关闭 LED。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2 .global _start &#x2F;* 全局标号 *&#x2F;</span><br><span class="line">3</span><br><span class="line">4 &#x2F;*</span><br><span class="line">5 * 描述： _start 函数，程序从此函数开始执行此函数完成时钟使能、</span><br><span class="line">6 * GPIO 初始化、最终控制 GPIO 输出低电平来点亮 LED 灯。</span><br><span class="line">7 *&#x2F;</span><br><span class="line">8 _start:</span><br><span class="line">9 &#x2F;* 例程代码 *&#x2F;</span><br><span class="line">10 &#x2F;* 1、使能所有时钟 *&#x2F;</span><br><span class="line">11 ldr r0, &#x3D;0X020C4068 &#x2F;* 寄存器 CCGR0 *&#x2F;</span><br><span class="line">12 ldr r1, &#x3D;0XFFFFFFFF</span><br><span class="line">13 str r1, [r0]</span><br><span class="line">14</span><br><span class="line">15 ldr r0, &#x3D;0X020C406C &#x2F;* 寄存器 CCGR1 *&#x2F;</span><br><span class="line">16 str r1, [r0]</span><br><span class="line">17</span><br><span class="line">18 ldr r0, &#x3D;0X020C4070 &#x2F;* 寄存器 CCGR2 *&#x2F;</span><br><span class="line">19 str r1, [r0]</span><br><span class="line">20</span><br><span class="line">21 ldr r0, &#x3D;0X020C4074 &#x2F;* 寄存器 CCGR3 *&#x2F;</span><br><span class="line">22 str r1, [r0]</span><br><span class="line">23</span><br><span class="line">24 ldr r0, &#x3D;0X020C4078 &#x2F;* 寄存器 CCGR4 *&#x2F;</span><br><span class="line">25 str r1, [r0]</span><br><span class="line">26</span><br><span class="line">27 ldr r0, &#x3D;0X020C407C &#x2F;* 寄存器 CCGR5 *&#x2F;</span><br><span class="line">28 str r1, [r0]</span><br><span class="line">29</span><br><span class="line">30 ldr r0, &#x3D;0X020C4080 &#x2F;* 寄存器 CCGR6 *&#x2F;</span><br><span class="line">31 str r1, [r0]</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34 &#x2F;* 2、设置 GPIO1_IO03 复用为 GPIO1_IO03 *&#x2F;</span><br><span class="line">35 ldr r0, &#x3D;0X020E0068 &#x2F;* 将寄存器 SW_MUX_GPIO1_IO03_BASE 加载到 r0 中 *&#x2F;</span><br><span class="line">36 ldr r1, &#x3D;0X5 &#x2F;* 设置寄存器 SW_MUX_GPIO1_IO03_BASE 的 MUX_MODE 为 5 *&#x2F;</span><br><span class="line">37 str r1,[r0]</span><br><span class="line">38</span><br><span class="line">39 &#x2F;* 3、配置 GPIO1_IO03 的 IO 属性</span><br><span class="line">40 *bit 16:0 HYS 关闭</span><br><span class="line">41 *bit [15:14]: 00 默认下拉</span><br><span class="line">42 *bit [13]: 0 kepper 功能</span><br><span class="line">43 *bit [12]: 1 pull&#x2F;keeper 使能</span><br><span class="line">44 *bit [11]: 0 关闭开路输出</span><br><span class="line">45 *bit [7:6]: 10 速度 100Mhz</span><br><span class="line">46 *bit [5:3]: 110 R0&#x2F;6 驱动能力</span><br><span class="line">47 *bit [0]: 0 低转换率</span><br><span class="line">48 *&#x2F;</span><br><span class="line">49 ldr r0, &#x3D;0X020E02F4 &#x2F;*寄存器 SW_PAD_GPIO1_IO03_BASE *&#x2F;</span><br><span class="line">50 ldr r1, &#x3D;0X10B0</span><br><span class="line">51 str r1,[r0]</span><br><span class="line">52</span><br><span class="line">53 &#x2F;* 4、设置 GPIO1_IO03 为输出 *&#x2F;</span><br><span class="line">54 ldr r0, &#x3D;0X0209C004 &#x2F;*寄存器 GPIO1_GDIR *&#x2F;</span><br><span class="line">55 ldr r1, &#x3D;0X0000008</span><br><span class="line">56 str r1,[r0]</span><br><span class="line">57</span><br><span class="line">58 &#x2F;* 5、打开 LED0</span><br><span class="line">59 * 设置 GPIO1_IO03 输出低电平</span><br><span class="line">60 *&#x2F;</span><br><span class="line">61 ldr r0, &#x3D;0X0209C000 &#x2F;*寄存器 GPIO1_DR *&#x2F;</span><br><span class="line">62 ldr r1, &#x3D;0</span><br><span class="line">63 str r1,[r0]</span><br><span class="line">64</span><br><span class="line">65 &#x2F;*</span><br><span class="line">66 * 描述： loop 死循环</span><br><span class="line">67 *&#x2F;</span><br><span class="line">68 loop:</span><br><span class="line">69 b loop</span><br><span class="line">70</span><br></pre></td></tr></table></figure><p>第 2 行定义了一个全局标号_start，代码就是从_start 这个标号开始顺序往下执行的。</p><p>第 11 行使用 ldr 指令向寄存器 r0 写入 0X020C4068，也就是 r0=0X020C4068，这个是CCM_CCGR0 寄存器的地址。</p><p>第 12 行使用 ldr 指令向寄存器 r1 写入 0XFFFFFFFF，也就是 r1=0XFFFFFFFF。因为我们要开启所有的外设时钟，因此 CCM_CCGR0~CCM_CCGR6 所有寄存器的 32 位都要置 1，也就是写入 0XFFFFFFFF。</p><p>第 13 行使用 str 将 r1 中的值写入到 r0 所保存的地址中去，也就是给 0X020C4068 这个地址写入 0XFFFFFFFF，相当于 CCM_CCGR0=0XFFFFFFFF，就是打开 CCM_CCGR0 寄存器所控制的所有外设时钟。</p><p>第 15<del>31 行都是向 CCM_CCGRX(X=1</del>6)寄存器写入 0XFFFFFFFF。这样我就通过汇编代码使能了 I.MX6U 的所有外设时钟。</p><p>第35~37行是设置GPIO1_IO03的复用功能，GPIO1_IO03的复用寄存器地址为0X020E0068,寄 存 器 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 的 MUX_MODE 设置为 5 就 是 将GPIO1_IO03 设置为 GPIO。</p><p>第 49~51 行 是 设 置 GPIO1_IO03 的 配 置 寄 存 器 ， 也 就 是 寄 存 器IOMUX_SW_PAD_CTL_PAD_GPIO1_IO03 的值，此寄存器地址为 0X020E02F4，代码里面已经给出了这个寄存器详细的位设置。</p><p>第 54<del>63 行是设置 GPIO 功能，经过上面几步操作，GPIO1_IO03 这个 IO 已经被配置为了GPIO 功能，所以还需要设置跟 GPIO 有关的寄存器。第 54</del>56 行是设置 GPIO1-&gt;GDIR 寄存器，将 GPIO1_IO03 设置为输出模式，也就是寄存器的 GPIO1_GDIR 的 bit3 置 1。</p><p>第 61~63 行设置 GPIO1-&gt;DR 寄存器，也就是设置 GPIO1_IO03 的输出，我们要点亮开发板上的 LED0，那么 GPIO1_IO03 就必须输出低电平，所以这里设置 GPIO1_DR 寄存器为 0。</p><p>第 68~69 行是死循环，通过 b 指令，CPU 重复不断的跳到 loop 函数执行，进入一个死循环。</p><p>“存储地址”就是可执行文件存储在哪里，可执行文件的存储地址可以随意选择。“运行地址”就是代码运行的时候所处的地址。比如 I.MX6U 支持 SD 卡、EMMC、NAND 启动，因此代码可以存储到 SD 卡、EMMC 或者 NAND中。运行需要拷贝到其运行地址(链接地址)处。链接地址可以在 I.MX6U 的内部 128KB RAM 中 (0X900000~0X91FFFF)，也可以在外部的 DDR 中。学习过程中正点原子裸机例程的链接地址都在 DDR 中，链接起始地址为 0X87800000。</p><p>“-o”选项指定链接生成的 elf 文件名</p><p>“-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出，选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试信息</p><p>“-D”选项表示反汇编所有的段</p><p>0X87800000 处就是全局标号_start，也就是程序开始的地方</p><ul><li><p>编译代码</p><table><thead><tr><th>编译文件</th><th>arm-linux-gnueabihf-gcc -g -c led.s -o led.o</th></tr></thead><tbody><tr><td>链接文件</td><td>arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf</td></tr><tr><td>格式转换</td><td>arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</td></tr><tr><td>反汇编</td><td>arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis</td></tr></tbody></table></li><li><p>创建 Makefile 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">led.bin:led.s</span><br><span class="line">arm-linux-gnueabihf-gcc -g -c led.s -o led.o</span><br><span class="line">arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf</span><br><span class="line"> arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</span><br><span class="line"> arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis</span><br><span class="line">clean:</span><br><span class="line">rm -rf *.o led.bin led.elf led.dis</span><br></pre></td></tr></table></figure></li><li><p>代码烧写</p></li></ul><ol><li><pre><code> 将 imxdownload 拷贝到工程根目录和 led.bin 处于同一个文件夹下</code></pre></li><li><p>给予 imxdownload 可执行权限</p><p>  chmod 777 imxdownload</p></li><li><p>确定要烧写的 SD 卡。</p><p>  Ubuntu 下所有的设备文件都在目录“/dev”里面，所以插上 SD 卡以后也会出现在“/dev”里面，其中存储设备都是以“/dev/sd”开头的。</p></li><li><p>向 SD 卡烧写 bin 文件</p><p> /imxdownload &lt;.bin file&gt; <SD card></SD></p><p> 其中.bin 就是要烧写的.bin 文件，SD Card 就是你要烧写的 SD 卡，烧写完成以后会在当前工程目录下生成一个 load.imx 的文件</p></li></ol><hr><p>参考资料：正点原子《I.MX6U嵌入式Linux驱动开发指南V1.5》P292~319</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;GPIO通用型输入输出，类似于8051的P0-P3&lt;/p&gt;
&lt;p&gt;GPIO_SetBits输出高&lt;/p&gt;
&lt;p&gt;GPIO_ResetBits输出低&lt;/p&gt;
&lt;p&gt;输出端对负载供电拉电</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note8 ARM汇编基础</title>
    <link href="https://chenzhan666.coding.me/2021/02/13/note8-ARM%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <id>https://chenzhan666.coding.me/2021/02/13/note8-ARM%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</id>
    <published>2021-02-13T15:24:04.000Z</published>
    <updated>2021-02-13T16:28:10.541Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>因为 Cortex-A 芯片一上电 SP 指针还没初始化，C 环境还没准备好，所以肯定不能运行 C 代码，必须先用汇编语言设置好 C 环境，比如初始化 DDR、设置 SP指针等等</p><p>C 语言中的函数调用涉及到出栈入栈，出栈入栈就要对堆栈进行操作，所谓的堆栈其实就是一段内存，这段内存比较特殊，由 SP 指针访问，SP 指针指向栈顶。</p><p>初始化 DDR</p><h1 id="GNU-汇编语法"><a href="#GNU-汇编语法" class="headerlink" title="GNU 汇编语法"></a>GNU 汇编语法</h1><p>ARM汇编，编译使用的 GCC 交叉编译器，所以我们的汇编代码要符合 GNU 语法</p><p>GNU 汇编语法适用于所有的架构，由一系列的语句组成，每行一条语句，每条语句有三个可选部分</p><p>label：instruction @ comment</p><ul><li><p>label </p><p>即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号</p></li><li><p>instruction</p><p>即指令，也就是汇编指令或伪指令</p></li><li><p>@符号</p><p>表示后面的是注释，就跟 C 语言里面的“/<em>”和“</em>/”一样，其实在 GNU 汇编文件中我们也可以使用“/<em>”和“</em>/”来注释</p></li><li><p>comment</p><p>就是注释内容</p></li></ul><p>注意！ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。</p><p>用户可以使用.section 伪操作来定义一个段</p><p>汇编程序的默认入口标号是_start，不过我们也可以在链接脚本中使用 ENTRY 来指明其它的入口点</p><p>.global 是伪操作，表示_start 是一个全局标号</p><p>常见的伪操作有：</p><table><thead><tr><th>.byte</th><th>定义单字节数据，比如.byte 0x12</th></tr></thead><tbody><tr><td>.short</td><td>定义双字节数据，比如.short 0x1234</td></tr><tr><td>.long</td><td>定义一个 4 字节数据，比如.long 0x12345678</td></tr><tr><td>.equ</td><td>赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示 num=0x12</td></tr><tr><td>.align</td><td>数据字节对齐，比如：.align 4 表示 4 字节对齐</td></tr><tr><td>.end</td><td>表示源文件结束</td></tr><tr><td>.global</td><td>定义一个全局符号，格式为：.global symbol，比如：.global _start</td></tr></tbody></table><p>GNU 汇编同样也支持函数，函数格式如下：</p><p>函数名:</p><p>函数体</p><p>返回语句</p><p><code>汇编写的 Cortex-A7 中断服务函数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 未定义中断 *&#x2F;</span><br><span class="line">Undefined_Handler:</span><br><span class="line"> ldr r0, &#x3D;Undefined_Handler</span><br><span class="line"> bx r0</span><br><span class="line">&#x2F;* SVC 中断 *&#x2F;</span><br><span class="line">SVC_Handler:</span><br><span class="line"> ldr r0, &#x3D;SVC_Handler</span><br><span class="line"> bx r0</span><br><span class="line">&#x2F;* 预取终止中断 *&#x2F;</span><br><span class="line">PrefAbort_Handler:</span><br><span class="line"> Ldr r0, &#x3D;PrefAbort_Handler</span><br><span class="line">bx r0</span><br></pre></td></tr></table></figure><h1 id="Cortex-A7-常用汇编指令"><a href="#Cortex-A7-常用汇编指令" class="headerlink" title="Cortex-A7 常用汇编指令"></a>Cortex-A7 常用汇编指令</h1><ul><li>处理器内部数据传输指令</li></ul><ol><li><pre><code> 将数据从一个寄存器传递到另外一个寄存器。</code></pre></li><li><pre><code>将数据从一个寄存器传递到特殊寄存器，如 CPSR 和 SPSR 寄存器。</code></pre></li><li><p>将立即数传递到寄存器。</p><p>数据传输常用的指令有三个：MOV、MRS 和 MSR</p></li></ol><ul><li><p>MOV 指令</p><p>MOV 指令用于将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面，使用示例如下：</p><p>MOV R0，R1 @将寄存器 R1 中的数据传递给 R0，即 R0=R1</p><p>MOV R0, #0X12 @将立即数 0X12 传递给 R0 寄存器，即 R0=0X12</p></li><li><p>MRS 指令</p><p>MRS 指令用于将特殊寄存器(如 CPSR 和 SPSR)中的数据传递给通用寄存器，要读取特殊寄存器的数据只能使用 MRS 指令！使用示例如下：</p><p>MRS R0, CPSR @将特殊寄存器 CPSR 里面的数据传递给 R0，即 R0=CPSR</p></li><li><p>MSR 指令</p><p>MSR 指令和 MRS 刚好相反，MSR 指令用来将普通寄存器的数据传递给特殊寄存器，也就 是写特殊寄存器，写特殊寄存器只能使用 MSR，使用示例如下： </p><p>MSR CPSR, R0 @将 R0 中的数据复制到 CPSR 中，即 CPSR=R0</p></li><li><p>存储器访问指令</p><p>用汇编来配置 I.MX6UL 寄存器的时候需要借助存储器访问指令，一般先将要配置的值</p><p>写入到 Rx(x=0~12)寄存器中，然后借助存储器访问指令将 Rx 中的数据写入到 I.MX6UL 寄存器。</p><p>常用的存储器访问指令有两种：LDR 和STR</p><p>LDR Rd, [Rn , #offset] 从存储器 Rn+offset 的位置读取数据存放到 Rd 中</p><p>STR Rd, [Rn, #offset] 将 Rd 中的数据写入到存储器中的 Rn+offset 位置</p></li><li><p>LDR 指令</p><p>LDR 主要用于从存储加载数据到寄存器 Rx 中，也可以将一个立即数加载到寄存器 Rx中，LDR 加载立即数的时候要使用“=”，而不是“#”。在嵌入式开发中，LDR 最常用的就是读取 CPU 的寄存器值</p><p>I.MX6UL 有个寄存器 GPIO1_GDIR，其地址为 0X0209C004，要读取这个寄存器中的数据示例代码如下：</p><p>LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</p><p>LDR R1, [R0] @读取地址 0X0209C004 中的数据到 R1 寄存器中</p><p>上述代码就是读取寄存器 GPIO1_GDIR 中的值，读取到的寄存器值保存在 R1 寄存器中，上面代码中 offset 是 0，也就是没有用到 offset</p></li><li><p>STR 指令</p><p>LDR 是从存储器读取数据，STR 就是将数据写入到存储器中</p><p>要配置I.MX6UL寄存器 GPIO1_GDIR 的值为 0X2000002，示例代码如下：</p><p>LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</p><p>LDR R1, =0X20000002 @R1 保存要写入到寄存器的值，即 R1=0X20000002</p><p>STR R1, [R0] @将 R1 中的值写入到 R0 中所保存的地址中</p><p>LDR 和 STR 是按照字进行读取和写入的，也就是操作的 32 位数据，如果要按照字节、半字进行操作的话可以在指令“LDR”后面加上 B 或 H，比如按字节操作的指令就是 LDRB 和STRB，按半字操作的指令就是 LDRH 和 STRH</p></li><li><p>压栈和出栈指令</p><p>将当前处理器状态保存起来(就是保存 R0~R15 这些寄存器值)</p><p>保存 R0<del>R15 寄存器的操作就叫做现场保护，恢复 R0</del>R15 寄存器的操作就叫做恢复现场。在进行现场保护的时候需要进行压栈(入栈)操作，恢复现场就要进行出栈操作。</p><p><strong>压栈的指令为 PUSH**</strong>，出栈的指令为 POP**，PUSH 和 POP 是一种多存储和多加载指令，即可以一次操作多个寄存器数据，他们利用当前的栈指针 SP 来生成地址</p></li></ul><p>  处理器的堆栈是向下增长的</p><p>  出栈的就是从栈顶，也就是 SP 当前执行的位置开始，地址依次减小来提取堆栈中的数据到要恢复的寄存器列表中。PUSH 和 POP 的另外一种写法是“STMFD SP！”和“LDMFD SP!”</p><p>  LDR 和 STR，这两个是数据加载和存储指令，但是每次只能读写存储器中的一个数据</p><p>  FD 是 Full Descending 的缩写，即满递减的意思</p><p>  根据 ATPCS 规则,ARM 使用的 FD 类型的堆栈，SP 指向最后一个入栈的数值，堆栈是由高地址向下增长的</p><p>  STM 和 LDM 的指令寄存器列表中编号小的对应低地址，编号高的对应高地址</p><ul><li><p>跳转指令</p><ul><li><p>B 指令</p><p>如果要调用的函数不会再返回到原来的执行处，那就可以用 B 指令如下示例：</p><p> _start:</p><p> ldr sp,=0X80200000 @设置栈指针</p><p> b main @跳转到 main 函数</p><p>上述代码就是典型的在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行，只是初始化了 SP 指针，跳转到 C 文件以后再也不会回到汇编</p></li><li><p>BL 指令</p><p>跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值</p><p>处理完成以后是需要返回来继续执行下面的程序，所以使用了 BL 指令</p></li></ul></li></ul><h1 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h1><ul><li><p>加法运算，指令为 ADD</p><p>ADD Rd, Rn, Rm </p><p>Rd = Rn + Rm </p><p>ADD Rd, Rn, #immed </p><p>Rd = Rn + #immed</p></li><li><p>带进位的加法运算，指令为 ADC</p><p>带进位的加法运算，指令为 ADC</p><p>ADC Rd, Rn, Rm </p><p>Rd = Rn + Rm + 进位 </p><p>ADC Rd, Rn, #immed </p><p>Rd = Rn + #immed +进位</p></li><li><p>减法</p><p>SUB Rd, Rn, Rm </p><p>Rd = Rn – Rm</p><p>SUB Rd, #immed </p><p>Rd = Rd - #immed</p><p>SUB Rd, Rn, #immed </p><p>Rd = Rn - #immed</p></li><li><p>带借位的减法</p><p>SBC Rd, Rn, #immed </p><p>Rd = Rn - #immed – 借位 </p><p>SBC Rd, Rn ,Rm </p><p>Rd = Rn – Rm – 借位</p></li><li><p>乘法(32 位)</p><p>MUL Rd, Rn, Rm </p><p>Rd = Rn * Rm</p></li><li><p>无符号除法</p><p>UDIV Rd, Rn, Rm </p><p>Rd = Rn / Rm </p></li><li><p>有符号除法</p><p>SDIV Rd, Rn, Rm </p><p>Rd = Rn / Rm </p></li><li><p>逻辑运算指令</p><p>AND Rd, Rn </p><p>Rd = Rd &amp;Rn</p><p>AND Rd, Rn, #immed </p><p>Rd = Rn &amp;#immed </p><p>AND Rd, Rn, Rm </p><p>Rd = Rn &amp; Rm</p></li><li><p>按位或</p><p>ORR Rd, Rn </p><p>Rd = Rd | Rn</p><p>ORR Rd, Rn, #immed </p><p>Rd = Rn | #immed </p><p>ORR Rd, Rn, Rm </p><p>Rd = Rn | Rm</p></li><li><p>位清除</p><p>BIC Rd, Rn </p><p>Rd = Rd &amp; (~Rn)</p><p>BIC Rd, Rn, #immed </p><p>Rd = Rn &amp; (~#immed) 位清除</p><p>BIC Rd, Rn , Rm </p><p>Rd = Rn &amp; (~Rm)</p></li><li><p>按位或非</p><p>ORN Rd, Rn, #immed </p><p>Rd = Rn | (#immed)</p><p>ORN Rd, Rn, Rm </p><p>Rd = Rn | (Rm)</p></li><li><p>按位异或</p><p>EOR Rd, Rn </p><p>Rd = Rd ^ Rn</p><p>EOR Rd, Rn, #immed </p><p>Rd = Rn ^ #immed </p><p>EOR Rd, Rn, Rm </p><p>Rd = Rn ^ Rm</p></li></ul><hr><p>参考资料：正点原子《I.MX6U嵌入式Linux驱动开发指南V1.5》P284~291</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;因为 Cortex-A 芯片一上电 SP 指针还没初始化，C 环境还没准备好，所以肯定不能运行 C 代码，必须先用汇编语言设置好 C 环境，比如初始化 DDR、设置 SP指针等等&lt;/</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note7 Cortex-A7 MPCore架构</title>
    <link href="https://chenzhan666.coding.me/2021/02/13/note7-Cortex-A7-MPCore%E6%9E%B6%E6%9E%84/"/>
    <id>https://chenzhan666.coding.me/2021/02/13/note7-Cortex-A7-MPCore%E6%9E%B6%E6%9E%84/</id>
    <published>2021-02-13T15:23:30.000Z</published>
    <updated>2021-02-13T16:07:57.086Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Cortex-A7 MPcore 处理器支持 1~4 核，通常是和 Cortex-A15 组成 big.LITTLE 架构的，Cortex-A15 作为大核负责高性能运算，比如玩游戏啥的，Cortex-A7 负责普通应用，因为 CortexA7 省电。</p><p>Cache</p><p>高速缓冲存储器</p><p>除了 User(USR)用户模式以外，其它 8 种运行模式都是特权模式。这几个运行模式可以通过软件进行任意切换，也可以通过中断或者异常来进行切换。</p><p>当中断或者异常发生以后，处理器就会进入到相应的异常模式种，每一种模式都有一组寄存器供异常处理程序使用，这样的目的是为了保证在进入异常模式以后，用户模式下的寄存器不会被破坏。</p><p>ARM 架构提供了 16 个 32 位的通用寄存器(R0<del>R15)供软件使用，前 15 个(R0</del>R14)可以用作通用的数据存储，R15 是程序计数器 PC，用来保存将要执行的指令。ARM 还提供了一个当前程序状态寄存器 CPSR 和一个备份程序状态寄存器 SPSR，SPSR 寄存器就是 CPSR 寄存器的备份。</p><p>浅色字体的是与 User 模式所共有的寄存器，蓝绿色背景的是各个模式所独有的寄存器。</p><p>低寄存器组(R0~R7)是共享同一组物理寄存器的。</p><p>比如 FIQ 模式下 R8~R14 是独立的物理寄存器。</p><p>CortexA 内核寄存器组成如下：</p><ol><li>   34 个通用寄存器，包括 R15 程序计数器(PC)，这些寄存器都是 32 位的。</li><li>   8 个状态寄存器，包括 CPSR 和 SPSR。</li><li>   Hyp 模式下独有一个 ELR_Hyp 寄存器。</li></ol><p>R13 也叫做 SP，用来做为栈指针。</p><p>用户模式(User)、系统模式(Sys)和超级监视模式(Hyp)</p><p>每种处理器模式使用 R14(LR)来存放当前子程序的返回地址</p><p>ARM 处理器 3 级流水线：取指-&gt;译码-&gt;执行</p><p>CPSR 寄存器当前程序状态寄存器，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志等一些状态位以及一些控制位。</p><hr><p>参考资料：正点原子《I.MX6U嵌入式Linux驱动开发指南V1.5》P277~282</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;Cortex-A7 MPcore 处理器支持 1~4 核，通常是和 Cortex-A15 组成 big.LITTLE 架构的，Cortex-A15 作为大核负责高性能运算，比如玩游戏</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
  <entry>
    <title>note6 ARM裸机开发环境搭建</title>
    <link href="https://chenzhan666.coding.me/2021/02/13/note6-ARM%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://chenzhan666.coding.me/2021/02/13/note6-ARM%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-02-13T15:22:26.000Z</published>
    <updated>2021-02-13T16:01:50.107Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一些名词（持续更新）"><a href="#一些名词（持续更新）" class="headerlink" title="一些名词（持续更新）"></a><strong>一些名词（持续更新）</strong></h1><ul><li><p>FTP</p><p>文件传输协议，TCP/IP协议组之一</p></li><li><p>NFS</p><p>网络文件系统</p></li><li><p>SSH</p><p>安全协议外壳</p></li><li><p>SOC</p><p>系统级芯片，片上系统</p></li></ul><p>Ubuntu 作为 FTP 服务器，FileZilla 作为 FTP 客户端</p><p> ssh 的配置文件为/etc/ssh/sshd_config，使用默认配置即可</p><p>命令“arm-linux-gnueabihf-gcc”，“arm-linux-gnueabihfgcc”的含义如下：</p><ol><li><p>   arm 表示这是编译 arm 架构代码的编译器。</p></li><li><p>   linux 表示运行在 linux 环境下。</p></li><li><p>   gnueabihf 表示嵌入式二进制接口。</p></li><li><p>   gcc 表示是 gcc 工具。</p></li></ol><p>Source Insight 新建工程不能有中文路径！</p><hr><p>参考资料：正点原子《I.MX6U嵌入式Linux驱动开发指南V1.5》P153~219</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;一些名词（持续更新）&quot;&gt;&lt;a href=&quot;#一些名词（持续更新）&quot; class=&quot;headerlink&quot; title=&quot;一些名词（持续更新）&quot;&gt;&lt;/a&gt;&lt;strong&gt;一些</summary>
      
    
    
    
    
    <category term="ARM(MX6U)" scheme="https://chenzhan666.coding.me/tags/ARM-MX6U/"/>
    
  </entry>
  
</feed>
