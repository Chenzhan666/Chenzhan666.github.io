<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHENZHAN</title>
  
  <subtitle>CHENZHAN</subtitle>
  <link href="https://www.chenzhan.club/atom.xml" rel="self"/>
  
  <link href="https://www.chenzhan.club/"/>
  <updated>2021-08-11T17:10:43.294Z</updated>
  <id>https://www.chenzhan.club/</id>
  
  <author>
    <name>Chenzhan666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>note63.10-TCP客户端服务器</title>
    <link href="https://www.chenzhan.club/2021/08/12/note63-10-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://www.chenzhan.club/2021/08/12/note63-10-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-08-11T17:09:32.000Z</published>
    <updated>2021-08-11T17:10:43.294Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>网络通信<br>1.网络和网络协议<br>1)什么是计算机网络？<br>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过有形或无形的通信线路连接起来，在网络操作系统、网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。<br>2)什么是网络协议？<br>网络协议是一种特殊的软件，是计算机网络实现其功能的最基本的机制。网路协议的本质就是规则，即各种硬件和软件必须遵循的共同守则。网络协议并不是一套单独的软件，它融合于所有涉及网络通信的软件甚至硬件之中，因此可以说协议于网络中无处不在。<br>3)什么是协议栈？<br>为了减少网络设计的复杂性，绝大多数网络采用分层设计的方法。所谓分层设计，就是按照信息流动的过程将网络的整体功能分解为一个个的功能层，不同机器上的同等功能层之间采用相同的协议，同一机器上相邻功能层之间通过接口进行信息传递。各层的协议和接口统称为协议栈。<br>ISO(国际标准化组织)/OSI(Open System Interconnection, 开放系统互联)网络协议模型：<br>应用层：业务逻辑                             <br>表示层：数据的表现形式                   | -&gt; 应用层</p><p>会话层：建立、管理和终止通信过程 /</p><p>传输层：源到目的地的点对点传输<br>网络层：路径选择、路由、寻址等网络结构拓扑<br>数据链路层：物理寻址、数据通道、错误检测等通信路径<br>物理层：在数据和电平信号之间进行转换<br>比喻：<br>买点心（应用层：业务需求）<br>选择包装（表示层：数据形式）<br>选择快递公司（会话层：通信过程）<br>填写收寄单（传输层：点对点）<br>选择路径（网络层：通路）<br>中途周转（数据链路层：多点连线）<br>送货过程（物理层：实际通信）<br>4)TCP/IP协议栈<br>传输层：TCP、UDP<br>网络层：IP、ICMP、IGMP<br>链路层：ARP、RARP<br>5)消息包和数据流<br>应用层：HTTP请求=用户数据包<br>传输层：TCP头+用户数据包=TCP包<br>网络层：IP头+TCP包=IP包<br>链路层：以太网头+IP包+以太网尾=以太网帧<br>物理层：以太网帧-&gt;电平信号<br>                                    |   ^<br>                                   v    |<br>                                传输线路<br>发送数据流：消息自协议栈顶层向底层流动，逐层打包。<br>接收数据流：消息自协议栈底层向顶层流程，逐层解析。<br>6)IP地址<br>IP地址(Internet Protocol Address，互联网协议地址)是一种地址格式，为互联网上的每个网络和主机分配一个逻辑地址，其目的是消除物理地址的差异性。<br>IP地址的计算机内部用一个网络字节序的32位(4个字节)无符号整数表示。通常习惯将其表示为点分十进制整数字符串的形式。例如：<br>点分十进制整数字符串：1.2.3.4<br>32位(4个字节)无符号整数：0x01020304<br>内存布局：| 0x01 | 0x02 | 0x03 | 0x04 |<br>                   低地址—————&gt;高地址<br>网络字节序就是大端字节序，高位在低地址，低位在高地址。<br>中国北京市东城区珠市口大街珍贝大厦三层第一教室<br>一台计算机的IP地址=网络地址+主机地址<br>A级地址：以0为首8位网络地址+24位主机地址<br>B级地址：以10为首16位网络地址+16位主机地址<br>C级地址：以110为首24位网络地址+8位主机地址<br>D级地址：以1110为首的32为多(组)播地址<br>例如：某台计算机的IP地址为192.168.182.48，其网络地址和主机地址分别为何？<br>           192            168            182              48<br>11000000 10101000 10110110 00110000<br>以110为首，C级地址，网络地址是192.168.182.0，主机地址是48。<br>主机IP地址 &amp; 子网掩码 = 网络地址<br>主机IP地址 &amp; ~子网掩码 = 主机地址<br>例如：主机IP地址192.168.182.48，子网掩码255.255.255.0，其网络地址和主机地址分别为何？<br>192.168.182.48 &amp; 255.255.255.0 = 192.168.182.0<br>192.168.182.48 &amp; 0.0.0.255 = 0.0.0.48<br>2.套接字<br>1)什么是套接字？<br>Socket，电源插座-&gt;套接字<br>一个由系统内核负责维护，通过文件描述符访问的对象， 可用于在同一台机器或不同机器中的进程之间实现通信。<br>进程表项<br>    文件描述符表<br>    0: 文件描述符标志 | * -&gt; 标准输入文件表项 -&gt; 键盘<br>    1: 文件描述符标志 | * -&gt; 标准输出文件表项 -&gt; 显示器<br>    2: 文件描述符标志 | * -&gt; 标准错误文件表项 -&gt; 显示器<br>    3: 文件描述符标志 | * -&gt; 套接字对象 -&gt; 网卡<br>           应用程序                       应用程序<br>                 v                                   v<br>磁盘文件的文件描述符 表示网络的文件描述符<br>                 v                                   v<br>           文件对象                      套接字对象<br>                 v                                   v<br>           文件系统                      网络协议栈<br>                 v                                   v<br>           磁盘设备                       网络设备<br>套接字也可以被视为是围绕表示网络的文件描述符的一套函数库。调用其中的函数就可以访问网络上的数据，实现不同主机间的通信功能。<br>2)绑定和连接<br>   套接字就是系统内核内存中的一块数据——逻辑对象<br>                                                                            | 绑定(bind)<br>包含了IP地址和端口号等参数的网络设备——物理对象<br>互联网<br>     | &lt;-网络地址：192.168.182.0<br>子网络<br>     | &lt;-主机地址：0.0.0.48<br>计算机<br>     | &lt;-端口号：80<br>  应用<br>通过IP地址(网络地址+主机地址)端口号就可以唯一定位互联网上的一个通信引用。<br>主机A<br>应用程序<br>      |<br>逻辑对象(套接字)<br>      | 绑定(bind)                  连接(connection)<br>物理对象(IP地址和端口号)———物理对象(IP地址和端口号)<br>                                                             | 绑定(bind)<br>                                                       逻辑对象(套接字)<br>                                                             |<br>                                                       应用程序<br>                                                       主机B<br>3)常用函数<br>创建套接字<br>#include &lt;sys/socket.h&gt;<br>int socket(int domain, int type, int protocol);<br>成功返回套接字描述符，失败返回-1。<br>domain - 通信域，即协议族，可取以下值：<br>PF_LOCAL/PF_UNIX: 本地通信，进程间通信<br>PF_INET: 互联网通信<br>PF_PACKET: 底层包通信（嗅探器、端口扫描）<br>type - 套接字类型，可取以下值：<br>SOCK_STREAM: 流式套接字，使用TCP协议<br>SOCK_DGRAM: 数据报式套接字，使用UDP协议<br>SOCK_RAW: 原始套接字，使用自定义协议<br>protocol - 特殊协议<br>                  对于流式套接字和数据报式套接字，取0<br>套接字描述符与文件描述符在逻辑层面是一致的，所有关于文件描述符的规则对于套接字描述符也同样成立。同样也通过close函数关闭套接字，即释放内核中的有关资源。<br>基本地址结构：<br>struct sockaddr {<br>    sa_family_t sa_family; // 地址族<br>    char sa_data[14]; // 地址值<br>};<br>基本地址结构仅用于给函数传参时做强制类型转换。<br>本地地址结构：<br>#include &lt;sys/un.h&gt;<br>struct sockaddr_un {<br>    sa_family_t sun_family; // 地址族<br>                                             // (AF_LOCAL/AF_UNIX)<br>    char sun_path[]; // 套接字文件路径<br>};<br>网络地址结构：<br>#include &lt;sys/in.h&gt;<br>struct sockaddr_in {<br>    sa_family_t sin_family; // 地址族(AF_INET)<br>    in_port_t sin_port; // 端口号(网络字节序)<br>    struct in_addr sin_addr; // IP地址<br>};<br>struct in_addr {<br>    in_addr_t s_addr; // 网络字节序32位无符号整数形式的<br>                                   // IP地址<br>};<br>typedef uint32_t in_addr_t;<br>typedef uint16_t in_port_t;<br>小端字节序的主机A              大端字节序的主机B<br>short a = 0x1234;<br>| 0x34 | 0x12 |                    | 0x34 | 0x12 |<br>    低         高                             低         高<br>                                             a: 0x3412<br>发送：主机字节序-&gt;网络(大端)字节序<br>接收：网络(大端)字节序-&gt;主机字节序<br>小端字节序的主机A             大端字节序的主机B<br>0x1234<br>主：0x34 | 0x12<br>           L        H<br>网：0x12 | 0x34      -&gt;      网：0x12 | 0x34<br>                                                       L         H<br>                                            主：0x12 | 0x34<br>                                            0x1234<br>                                            ——————–<br>                                            小端字节序的主机C<br>                                  -&gt;      网：0x12 | 0x34<br>                                                       L         H<br>                                            主：0x34 | 0x12<br>                                            0x1234<br>将套接字对象和自己的地址结构绑定在一起<br>int bind(int sockfd, const struct sockaddr* addr,<br>    socklen_t addrlen);<br>成功返回0，失败返回-1。<br>sockfd - 套接字描述符<br>addr - 自己的地址结构<br>addrlen - 地址结构字节数<br>addr-&gt;sa_family: AF_LOCAL/AF_UNIX<br>     ((struct sockaddr_un*)addr)-&gt;sun_path: 套接字文件<br>addr-&gt;sa_family: AF_INET<br>     ((struct sockaddr_in*)addr)-&gt;sin_port/sin_addr:<br>                                                                     IP地址和端口号<br>将套接字对象所代表的物理对象和对方的地址结构连接在一起<br>int connect(int sockfd, const struct sockaddr* addr,<br>    socklen_t addrlen);<br>成功返回0，失败返回-1。<br>sockfd - 套接字描述符<br>addr - 对方的地址结构<br>addrlen - 地址结构字节数<br>通过套接字描述符接收和发送数据的过程完全与通过文件描述符读取和写入数据的过程完全一样。<br>ssize_t read(int sockfd, void* buf, size_t count);<br>ssize_t write(int sockfd, const void* buf, size_t count);<br>字节序转换<br>通过网络传输多字节整数，需要在发送前转换为网络字节序，在接收后转换为主机字节序。<br>#include &lt;arpa/inet.h&gt;<br>uint32_t htonl(uint32_t hostlong);<br>uint16_t htons(uint16_t hostshort);<br>uint32_t ntohl(uint32_t netlong);<br>uint16_t ntohs(uint16_t netshort);<br>h - host，主机(字节序)<br>to - 到，把…转换到…<br>n - network，网络(字节序)<br>l - long版本，32位无符号整数<br>s - short版本，16位无符号整数<br>IP地址转换<br>(网络字节序32位无符号)整数&lt;=&gt;(点分十进制)字符串<br>#include &lt;arpa/inet.h&gt;<br>in_addr_t inet_addr(const char* cp); // 串-&gt;数<br>int inet_aton(const char* cp, struct in_addr* inp);<br>// 串-&gt;数<br>转换成功返回0，失败返回-1。<br>char* inet_ntoa(struct in_addr in); // 数-&gt;串<br>转换成功返回字符串指针，失败返回NULL。<br>基于本地套接字的进程间通信：<br>服务器：提供业务服务的计算机程序。<br>客户机：请求业务服务的计算机程序。<br>服务器                                     客户机<br>创建套接字(socket)                创建套接字(socket)<br>准备地址结构(sockaddr_un)  准备地址结构(sockaddr_un)<br>绑定地址(bind)                       建立连接(connect)<br>接收请求(read)                       发送请求(write)<br>业务处理(…)                            等待处理(…)<br>发送响应(write)                      接收响应(read)<br>关闭套接字(close)                   关闭套接字(close)<br>代码：locsvr.c、loccli.c<br>基于网络套接字的进程间通信：<br>服务器                                     客户机<br>创建套接字(socket)                创建套接字(socket)<br>准备地址结构(sockaddr_in)   准备地址结构(sockaddr_in)<br>绑定地址(bind)                       建立连接(connect)<br>接收请求(read)                       发送请求(write)<br>业务处理(…)                            等待处理(…)<br>发送响应(write)                      接收响应(read)<br>关闭套接字(close)                   关闭套接字(close)<br>代码：netsvr.c、netcli.c<br>3.基于并发的TCP客户机/服务器模型<br>1)TCP协议的基本特征<br>A.面向连接：参与通信的双发在正式通信之前需要先建立连接，已形成一条虚拟电路，所有的后续通信都在这条虚电路上完成。类似于电话通信业务。正式通话之前要先拨号，拨通了才能讲话。拨号的过程就是一个建立连接的过程。<br>三路握手<br>    客户机                                                  服务器<br>发起连接请求 ——–SYN(n)——–&gt; 被动侦听<br>   等待应答     &lt;-ACK(n+1)+SYN(m)- 可以接受<br>   反向确认     ——ACK(m+1)——&gt; 连接成功<br>一旦三路握手完成，客户机和服务器的网络协议栈中就会保存有关连接的信息，此后的通信内容全部基于此连接实现数据传输。通信过程中任何原因导致的连接中断，都无法再继续通信，除非重新建立连接。<br>B.可靠传输：超时重传。每次发送一个数据包，对方都需要在一个给定的时间窗口内予以应答，如果超过时间没有收到对方的应答，发送方就会重发该数据包，只有重试过足够多的次数依然失败才会最终放弃。<br>C.保证顺序：发送端为每一个数据包编制序列号，接收端会根据序列号对所接收到的数据包进行重排，避免重复和乱序。<br>D.流量控制：协议栈底层在从另一端接收数据时，会不断告知对方它能够接收多少字节的数据，即所谓通告窗口。任何时候，这个窗口都反映了接收缓冲区可用空间的大小，从而确保不会因为发送方发送数据过快或过慢导致接收缓冲区出现上溢出或下溢出。<br>E.流式传输：以字节流形式传输数据，数据包在传输过程中没有记录边界。应用程序需要根据自己的规则来划分出数据包的记录边界。<br>a)定长记录<br>b)不定长记录加分隔符<br>c)定长长度加不定长记录<br>F.全双工：在给定的连接上，应用程序在任何时候都既可以发送数据也可以接收数据。因此TCP必须跟踪每个方向上数据流的状态信息，如序列号和通告窗口大小等。<br>2)TCP连接的生命周期<br>被动打开：通过侦听套接字感知其它主机发起的连接请求。<br>三路握手：TCP连接的建立过程。<br>| TCP包头 | TCP包体 |<br>&lt;20字节&gt;<br>含有6个标志位：SYN/ACK/FIN/RST/…<br>发送序列号和应答序列号<br>…<br>数据传输：超时重传、流量控制、面向字节流、全双工<br>终止连接：<br>  客户机                                            服务器<br>主动关闭 ———FIN(n)——-&gt; 被动关闭<br>等待应答 &lt;—–ACK(n+1)——   关闭应答<br>确定关闭 ———FIN(m)——&gt;  已经关闭<br>关闭应答 ——ACK(m+1)—–&gt;  等待应答<br>3)常用函数<br>在指定套接字上启动对连接请求的侦听，即将该套接字置为被动模式，因为套接字都缺省为主动模式。<br>int listen(int sockfd, int backlog);<br>成功返回0，失败返回-1。<br>sockfd - 套接字描述符<br>backlog - 未决连接请求队列的最大长度<br>在指定的侦听套接字上等待并接受连接请求<br>int accept(int sockfd, struct sockaddr* addr,<br>    size_t* addrlen);<br>成功返回连接套接字描述符用于后续通信，失败返回-1。<br>sockfd - 侦听套接字描述符<br>addr - 输出连接请求发起者的地址信息<br>addrlen - 输入输出连接请求发起者地址信息的字节数<br>该函数由TCP服务器调用，返回排在已决连接队列首部的连接套接字对象的描述符，若已决连接队列为空，该函数会阻塞。<br>                                                                      ^^^^^^^^<br>非并发的TCP服务器<br>创建套接字(socket)<br>绑定地址(bind)<br>启动侦听(listen)<br>等待连接(accept)&lt;–+<br>接收请求(read)&lt;-+   |<br>业务处理(…)          |    |<br>发送响应(write)–+–+</p><p>并发的TCP服务器<br>创建套接字(socket)<br>绑定地址(bind)<br>启动侦听(listen)<br>等待连接(accept)&lt;—+<br>                                    |<br>产生客户子进程(fork)-+<br>    接收请求(read)&lt;-+<br>    业务处理(…)          |<br>    发送响应(write)–+<br>接收数据<br>ssize_t recv(int sockfd, void* buf, size_t len, int flags);<br>flags - 接收标志，取0等价于read<br>    MSG_DONTWAIT: 非阻塞接收<br>    对于阻塞模式，当接收缓冲区为空时，该函数会阻塞，直到<br>    接收缓冲区不空为止。如果使用了此标志位，当接收缓冲区<br>    为空时，该函数会返回-1，并置errno为EAGAIN或<br>    EWOULDBLOCK。<br>    MSG_OOB: 接收带外数据。<br>    MSG_PEEK: 瞄一眼数据，只讲接收缓冲区中的数据复制到<br>    buf缓冲区中，但并不将其从接收缓冲区中删除。<br>    MSG_WAITALL: 接收到所有期望接收的数据才返回，如果<br>    接收缓冲区中的数据不到len个字节，该函数会阻塞，直到可<br>    接收到len个字节为止。<br>发送数据<br>ssize_t send(int sockfd, const void* buf, size_t len,<br>    int flags);<br>flags - 接收标志，取0等价于write<br>     MSG_DONTWAIT: 非阻塞发送<br>     对于阻塞模式，当发送缓冲区的空余空间不足以容纳期望发      送的字节数时，该函数会阻塞，直到发送缓冲区的空余空间<br>     足以容纳期望发送的字节数为止。如果使用了此标志位，能<br>     发送多少字节就发送多少字节，不会阻塞，甚至可能返回0<br>     表示发送缓冲区满，无法发送数据。<br>     MSG_OOB: 发送带外数据。<br>     MSG_DONTROUT: 不查路由表，直接在本地网中寻找目<br>     的主机。<br>代码：tcpsvr.c、tcpcli.c</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;网络通信&lt;br&gt;1.网络和网络协议&lt;br&gt;1)什么是计算机网络？&lt;br&gt;计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过有形或无形的通信线路连接起来，在网络操</summary>
      
    
    
    
    
    <category term="网络编程" scheme="https://www.chenzhan.club/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>note62.11-综合一些知识点</title>
    <link href="https://www.chenzhan.club/2021/08/12/note62-11-%E7%BB%BC%E5%90%88%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://www.chenzhan.club/2021/08/12/note62-11-%E7%BB%BC%E5%90%88%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-08-11T17:07:20.000Z</published>
    <updated>2021-08-11T17:08:25.660Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>C++ 的 SCL 中的 vector ,每次扩充容量时，新的容量都是上一次的两倍。</p></li><li><p>当声明一个数组时，数组名也像一个指针，该指针指向数组的第一个元素。</p></li><li><p>在32位系统上，对任意指针求 sizeof 结果都是4。</p></li><li><p>在 C/C++ 中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针。</p></li><li><p>宏定义本质为字符的简单替换。宏替换，先替换再按优先级计算，不要自作主张加括号之类。</p></li><li><p>虚函数不可以内联，因为虚函数是在运行期的时候确定具体调用的函数，内联是在编译期的时候进行代码展开，两者冲突。</p></li><li><p>effective C++中作者说尽量以 const enum inline 替换 define 条款，宏定义由预编译器来预处理，而不是编译器。</p></li><li><pre><code>struct Node&#123;   int size;   char data[0];&#125;;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   柔性数组(Flexible Array)也叫伸缩性数组、变长数组，编译器认为这是一个长度为0的数组, 支持对于数组data的越界访问，它只能放在结构体末尾, 声明一个长度为0的数组，使得结构体可变长。对于编译器来说，长度为0的数组不占用空间，因为数组名本身不占空间，只是一个偏移量， 数组名这个符号本身代表了一个不可修改的地址常量 （注意：数组名不是指针 ）。0长数组的这个特点，很容易构造出缓冲区，数据包等等结构体。构造缓冲区方便管理内存缓冲区,减少内存碎片化,它的作用不是标志结构体结束,而是扩展柔性数组是C99的扩展，就是一个在struct结构里的标识占位符（不占结构struct的空间）</span><br><span class="line"></span><br><span class="line">9. 静态函数属于类本身，不与类绑定，因此不能用this指针。</span><br><span class="line"></span><br><span class="line">   在类定义时，无法使用构造函数，因而无法完成对象的初始化</span><br><span class="line"></span><br><span class="line">   一般成员变量需要在类内进行初始化</span><br><span class="line"></span><br><span class="line">   静态成员变量必须在类外初始化，静态成员常量在类中初始化。</span><br><span class="line"></span><br><span class="line">10. **bss**段 通常是指用来存放程序中未初始化的全局变量的一块内存区域，在程序载入时由内核清0。BSS段属于静态内存分配。初始值由用户自己定义的连接定位文件所确定，用户应该将它定义在可读写的RAM区内，源程序中使用malloc分配的内存就是这一块，它不是根据data大小确定，主要由程序中同时分配内存最大值所确定，如果超出了范围，也就是分配失败，可以等空间释放之后再分配。</span><br><span class="line"></span><br><span class="line">    **text**段 是程序代码段，在AT91库中是表示程序段的大小，由编译器在编译连接时自动计算的，当你在链接定位文件中将该符号放置在代码段后，那么该符号表示的值就是代码段大小，编译连接时，该符号所代表的值会自动代入到源程序中。</span><br><span class="line"></span><br><span class="line">    **data**段 包含静态初始化的数据，所以有初值的全局变量和static变量在data区。段的起始位置也是由连接定位文件所确定，大小在编译连接时自动分配，它和程序大小没有关系，但和程序使用到的全局变量，常量数量相关。</span><br><span class="line"></span><br><span class="line">11. 运算符优先级由高到低：！，&lt;&#x3D;，&amp;&amp;</span><br><span class="line"></span><br><span class="line">    有：!x&amp;&amp;i&lt;&#x3D;5相当于(!x)&amp;&amp;(i&lt;&#x3D;5)</span><br><span class="line"></span><br><span class="line">    !x不会改变x本身的值，！x始终为真。</span><br><span class="line"></span><br><span class="line">12. &amp; amp; f1;&#x3D;&#x3D;&amp;f1。</span><br><span class="line"></span><br><span class="line">13. int (*pf)(float )表示定义了一个返回值为int，参数为float型的函数指针，要想调用他就必须满足返回值和参数类型匹配。</span><br><span class="line"></span><br><span class="line">14. C++中函数可以嵌套调用，但是不可以嵌套定义。</span><br><span class="line"></span><br><span class="line">15. int a[][4]&#x3D;&#123;0,0&#125;;&#x3D;a[1] [4]&#x3D;&#123;0，0，0，0&#125;；</span><br><span class="line"></span><br><span class="line">16. std::auto_ptr是C++标准库里面的模版类， 属于智能指针。</span><br><span class="line"></span><br><span class="line">17. 1，代表文件类型，一般有三类，- 代表普通的二进制文件，l 代表符号链接文件（软链接），d 代表目录文件；</span><br><span class="line"></span><br><span class="line">    2-4，代表文件所有者的权限表示情况，分别对应 可读(r) 可写(w) 可执行(w)，- 代表没有该项权限；</span><br><span class="line"></span><br><span class="line">    5-7，代表文件所有这所属组的权限表示情况。分别对应 可读(r) 可写(w) 可执行(w)，- 代表没有该项权限；</span><br><span class="line"></span><br><span class="line">    8-10,代表除文件所有者和所属组的其他人所拥有的权限表示情况。分别对应 可读(r) 可写(w) 可执行(w)，- 代表没有该项权限。</span><br><span class="line"></span><br><span class="line">18. r0-r7是未备份寄存器。对于未备份寄存器，在所有的工作模式下，寄存器Ri均指向同一个物理寄存器。该类寄存器没有被系统用于特殊用途。在所有工作模式下，（R0-R7  ）都指向同一个物理寄存器，即各模式共享。</span><br><span class="line"></span><br><span class="line">19. tar是操作.tar的命令</span><br><span class="line">    gzip是压缩.gz压缩包的命令</span><br><span class="line">    compress：压缩.Z文件</span><br><span class="line">    uncompress：解压缩.Z文件</span><br><span class="line"></span><br><span class="line">20. Linux系统大致启动流程是：uEFI-&gt; MBR -&gt; grub -&gt; initrd</span><br><span class="line"></span><br><span class="line">21. 要为所有的用户配置一个自定义注册项，你怎样用最简捷的操作，才能将这个自定义注册项添加到一个组策略对象（GPO）中？配置一个ADM模板并把这个模板添加到GPO</span><br><span class="line"></span><br><span class="line">22. 产生死锁的四个必要条件：（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span><br><span class="line"></span><br><span class="line">23. 通过管道统计prog.c函数中for语句通过的次数，需要使用的指令分别是grep、wc。</span><br><span class="line"></span><br><span class="line">24. &#96;&#96;&#96;</span><br><span class="line">    #include &lt;stdio.h&gt;&#x2F;&#x2F;#包含&lt;stdio.h&gt;</span><br><span class="line">     </span><br><span class="line">    int main(int argc,char* argv[])    &#x2F;&#x2F;整数类型主函数(整数类型统计参数个数,字符类型指针数组指向字符串参数)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,argc);           &#x2F;&#x2F;格式化输出</span><br><span class="line">        while(argc)                    &#x2F;&#x2F;当(统计参数个数)</span><br><span class="line">            printf(&quot;%s\n&quot;,argv[--argc]);   &#x2F;&#x2F;格式化输出</span><br><span class="line">        return 0;                      &#x2F;&#x2F;返回0;正常退出</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 假设将其编译为 test.exe 在命令行下 \&gt; test.exe test hello 得到的输出结果为 3 hello test test.exe main(int argc, char* argv[ ])，其中argc是指变量的个数，本例中即指test和hello这两个变量和程序运行的全路径名或程序的名字，argc即为3。 argv是一个char *的数组，其中存放指向参数变量的指针，此处argv[0]指向test.exe的全路径名或test.exe，argv[1]指向test，argv[2]指向hello。</code></pre></li><li><pre><code>enum string&#123;        x1,        x2,        x3=10,        x4,        x5,    &#125; x;</code></pre><p>0，1，10，11，12</p></li><li><p>C++中volatile关键字在使用的时候，使用volatile修饰的变量，不会被编译器优化，每一次都是重新从内存中取值，而不是从寄存器中，volatile变量间的操作，是不会被编译器交换顺序的，但是只限制用该关键字修饰的变量的操作顺序</p></li><li><p>重写时方法的访问权限只能相等或更大，而抛出的异常只能相等或更小；</p><p>方法重写时，返回值类型需要相同；</p><p>非static方法，重写时子类中也要是非static的。。而static方法重写时，子类中也要是static的。</p></li><li><p>进程是操作系统进行任务调度的基本单位。 一个进程可以包含多个线程，同一个进程下的线程共享运算资源等。</p></li><li><p>死锁是两个或以上的进程竞争资源产生的，只有一个进程是不会产生死锁的</p></li><li><p>cat -n file1file2 命令的意思是？</p><p>将几个文件合并为一个文件： $cat file1 file2 </p><p>-n 或 –number 由 1 开始对所有输出的行数编号</p><p>上述命令即将file1和file2的文件内容连在一起然后输出到屏幕，并打印行号，file1和file2文件内容不变 </p></li><li><p>页式管理就是把各进程的虚拟空间划分为若干长度相等的页面，把指令按页面大小划分后存放在内存中执行。或者只在内存中存放那些经常被执行和即将被执行的页面，而那些不被经常执行以及在近期内不可能被执行的页面则存放于外存中，按一定规则调入的一种内存管理方式。</p><p>静态页式管理不能实现虚存，这是因为静态页式管理要求进程或作业在执行前全部被装入内存，作业或进程的大小仍受内存可用页面数的限制。静态页式管理是一次性为要求内存的进程分配足够多的页面，无法将外存的空间利用起来实现虚存</p></li><li><p>用户交给计算机的工作称为作业，作业由<strong>程序、数据、作业说明</strong>3部分组成。</p><p>作业和进程的区别：</p><ul><li>一个进程是一个程序对某个数据集的执行过程，是分配资源的基本单位。</li><li>作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合。</li><li>一个作业的完成要经过作业提交、作业收容、作业执行和作业完成4个阶段。</li><li>进程是对已提交完毕的程序所执行过程的描述，是资源分配的基本单位。</li></ul></li><li><p>文件的 <strong>逻辑结构</strong> 主要有：</p><p>(1)连续结构 (2)多重结构 (3)转置结构 (4)顺序结构</p><p>文件的 <strong>物理存储</strong> 主要有：</p><p>(1)顺序结构 (2)链接结构 (3)索引结构</p><p>文件的 <strong>目录结构</strong> 主要有：</p><p>(1)一级目录结构 (2)二级目录结构 (3)树形结构 (4)无环图</p></li><li><p>死锁的处理都有哪些方法？</p><p>鸵鸟策略<br>预防策略<br>避免策略<br>检测与解除死锁</p></li><li><p>Strlen（text）字符串的字符数</p><p>Sizeof（text[0]）每个字符的字节数</p><p>两者相乘得到字符串的总字节数</p></li></ol><hr><p>参考资料：牛客网</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;C++ 的 SCL 中的 vector ,每次扩充容量时，新的容量都是上一次的两倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当声明一个数组时，数组名也像一个指针，该指针指向数组的第一个元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在32位系统上，对任意指针求 si</summary>
      
    
    
    
    
    <category term="其他" scheme="https://www.chenzhan.club/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>note61.9-Qt控件-部件简略</title>
    <link href="https://www.chenzhan.club/2021/07/26/note61-9-Qt%E6%8E%A7%E4%BB%B6-%E9%83%A8%E4%BB%B6%E7%AE%80%E7%95%A5/"/>
    <id>https://www.chenzhan.club/2021/07/26/note61-9-Qt%E6%8E%A7%E4%BB%B6-%E9%83%A8%E4%BB%B6%E7%AE%80%E7%95%A5/</id>
    <published>2021-07-26T15:49:33.000Z</published>
    <updated>2021-08-11T17:02:19.108Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>这里这是简略看看，等具体做一个东西在回来仔细看</p><h1 id="输入窗口部件"><a href="#输入窗口部件" class="headerlink" title="输入窗口部件"></a><strong>输入窗口部件</strong></h1><p>Qt Designer 窗口部件提供的面板中，提供了 16 种输入部件</p><p>QComboBox 类提供了 Qt 下拉组合框的组件。</p><p>QFontComboBox 类提供了下拉选择字体系列的组合框小部件。</p><p>QLineEdit 小部件是一个单行文本编辑器。行编辑允许用户使用一组有用的编辑函数输入和编辑一行纯文本。包括撤消和重做、剪切和粘贴以及拖放。通过更改行编辑的 echoMode()，它还可以用作“只写”字段，用于输入如密码等。</p><p>QTextEdit 类提供了一个查看器/编辑器小部件。</p><p>QPlainTextEdit 类提供了一个用于编辑和显示纯文本的小部件，常用于显示多行文本或简单文本。</p><p>QSpinBox 类提供了一个微调框小部件。</p><p>QDoubleSpinBox 类提供了一个用于处理浮点值微调框小部件。与 QSpinBox 作用基本一样，与 QSpinBox 不同的是，QDoubleSpinBox 类处理的是浮点值数据。</p><p>QTimeEdit 类提供一个基于 QDateTimeEdit 类编辑时间的小部件。</p><p>QDateEdit 类提供一个基于 QDateTimeEdit 类编辑时间的小部件。</p><p>从名字可知 QDateTimeEdit 类提供了一个用于编辑日期和时间的小部件。QDateTimeEdit允许用户使用键盘或箭头键编辑日期，以增加或减少日期和时间值。箭头键可用于在QDateTimeEdit 框中从一个区域移动到另一个区域。实际上是 QDateTimeEdit 和 QDateEdit 的组合。</p><p>QDial 类提供了一个圆形范围控制(如速度计或电位器)。QDial 用于当用户需要在可编程定义的范围内控制一个值，并且该范围要么是环绕的(例如，从 0 到 359 度测量的角度)，要么对话框布局需要一个正方形小部件。由于 QDial 从 QAbstractSlider 继承，因此拨号的行为与滑块类似。 当 wrapping（）为 false（默认设置）时，滑块和刻度盘之间没有真正的区别。 它们共享相同的信号，插槽和成员功能。 您使用哪一个取决于您的用户期望和应用程序类型。</p><p>QScrollBar 继承 QAbstractSlider。QScrollBar 小部件提供垂直或水平滚动条，允许用户访问比用于显示文档的小部件大的文档部分。它提供了用户在文档中的当前位置和可见文档数量的可视化指示。滚动条通常配有其他控件，可以实现更精确的导航(这里指浏览到精确的位置)。</p><p>QSlider 继承 QAbstractSlider。QScrollBar 类提供垂直或水平滑动条小部件，滑动条是用于控制有界值的典型小部件。它允许用户沿着水平或垂直凹槽移动滑块手柄，并将手柄的位置转换为合法范围内的整数值。</p><p>QKeySequenceEdit 继承 QWidget。这个小部件允许用户选择 QKeySequence, QKeySequence通常用作快捷方式。当小部件接收到焦点并在用户释放最后一个键后一秒结束时，将启动记录，通常用作记录快捷键。</p><h1 id="显示窗口部件"><a href="#显示窗口部件" class="headerlink" title="显示窗口部件"></a><strong>显示窗口部件</strong></h1><p>QLabel 提供了一种用于文本或图像显示的小部件。</p><p>QCalendarWidget 类提供了一个基于月的日历小部件，允许用户选择日期。CalendarWidget 小部件是用当前月份和年份初始化的，QCalendarWidget 还提供了几个公共插槽来更改显示的年份和月份。</p><p>QLCDNumber 小部件显示一个类似于 lcd 的数字。</p><p>QLCDNumber 小部件可以显示任意大小的数字。它可以显示十进制、十六进制、八进制或二进制数字。使用 display()插槽很容易连接到数据源，该插槽被重载以接受五种参数类型中的任何一种。</p><p>QProgressBar 小部件提供了一个水平或垂直的进度条。进度条用于向用户显示操作的进度，并向他们确认应用程序仍在运行。</p><p>QFrame 类是有框架的窗口部件的基类，它绘制框架并且调用一个虚函数 drawContents()来填充这个框架。这个函数是被子类重新实现的。这里至少还有两个有用的函数：drawFrame()和 frameChanged()。QPopupMenu 使用这个来把菜单“升高”，高于周围屏幕。QProgressBar 有“凹陷”的外观。QLabel 有平坦的外观。这些有框架的窗口部件可以被改变。QFrame::Shape 这个枚举类型定义了 QFrame 的框架所使用的外形。当前定义的效果有：</p><blockquote><p> NoFrame - QFrame 不画任何东西</p><p> Box - QFrame 在它的内容周围画一个框</p><p> Panel - QFrame 画一个平板使内容看起来凸起或者凹陷</p><p> WinPanel - 像 Panel，但 QFrame 绘制三维效果的方式和 Microsoft Windows 95（及其它）</p><p>的一样</p><p> ToolBarPanel - QFrame 调用 QStyle::drawToolBarPanel()</p><p> MenuBarPanel - QFrame 调用 QStyle::drawMenuBarPanel()</p><p> HLine - QFrame 绘制一个水平线，但没有框任何东西（作为分隔是有用的）</p><p> VLine - QFrame 绘制一个竖直线，但没有框任何东西（作为分隔是有用的）</p><p> StyledPanel - QFrame 调用 QStyle::drawPanel()</p><p> PopupPanel - QFrame 调用 QStyle::drawPopupPanel()</p><p>阴影风格有：</p><p> Plain 使用调色板的前景颜色绘制（没有任何三维效果）。</p><p> Raised 使用当前颜色组的亮和暗颜色绘制三维的凸起线。</p><p> Sunken 使用当前颜色组的亮和暗颜色绘制三维的凹陷线。</p></blockquote><h1 id="显示窗口部件之浏览器"><a href="#显示窗口部件之浏览器" class="headerlink" title="显示窗口部件之浏览器"></a><strong>显示窗口部件之浏览器</strong></h1><p>QTextBrowser 继承 QTextEdit，QTextBrowser 类提供了一个具有超文本导航的文本浏览器。该类扩展了 QTextEdit(在只读模式下)，添加了一些导航功能，以便用户可以跟踪超文本文档中的链接。</p><p>QGraphicsView 是图形视图框架的一部分，它提供了基于图元的模型/视图编程。QGraphicsView 在可滚动视图中可视化 QGraphicsScene 的内容。要创建带有几何项的场景，请参阅 QGraphicsScene 的文档。要可视化场景，首先构造一个 QGraphicsView 对象，将要可视化的场景的地址传递给 QGraphicsView 的构造函数。或者，可以调用 setScene()在稍后设置场景。</p><h1 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a><strong>布局管理</strong></h1><p>QBoxLayout 类提供水平或垂直地排列子部件。QBoxLayout 获取从它的父布局或从 parentWidget()中所获得的空间，将其分成一列框，并使每个托管小部件填充一个框。</p><p>QGridLayout 类提供了布局管理器里的一种以网格（二维）的方式管理界面组件，以按钮组件为例，它们所对应网格的坐标下表，与二维数组类似。QGridLayout获取可用的空间(通过其父布局或parentWidget()))，将其分为行和列，并将其管理的每个小部件放入正确的单元格中。由于网格布局管理器中的组件也是会随着窗口拉伸而发生变化的，所以也是需要设置组件之间的比例系数的，与QBoxLayout 不同的是网格布局管理器还需要分别设置行和列的比例系数。</p><p>QFormLayout 类管理输入小部件及其关联标签的表单。QFormLayout 是一个方便的布局类，它以两列的形式布局其子类。左列由标签组成，右列由“字段”小部件(QLineEdit(行编辑器)、QSpinBox(旋转框等))组成。通常使用 setRowWrapPolicy(RowWrapPolicy policy)接口函数设置布局的换行策略进行布局等。</p><h1 id="空间间隔"><a href="#空间间隔" class="headerlink" title="空间间隔"></a><strong>空间间隔</strong></h1><p>QSpacerItem 类在布局中提供空白(空间间隔)。所以 QSpacerItem 是在布局中使用的原因。</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a><strong>容器</strong></h1><p>QGroupBox 小部件提供一个带有标题的组框框架。一般与一组或者是同类型的部件一起使用。</p><p>QScrollArea 类提供到另一个小部件的滚动视图。</p><p>QToolBox（工具盒类）提供了一种列状的层叠窗体，中文译为工具箱，类似抽屉。</p><p>QTabWidget 类提供了一组选项卡（多页面）小部件。QTabWidget 主要是用来分页显示的，每一页一个界面，众多界面公用一块区域，节省了界面大小，很方便的为用户显示更多的信息。类似浏览器的多标签页面，所以这个控件在实际项目中也会经常用到。</p><p>QStackedWidget 类提供了一个小部件堆栈，其中一次只能看到一个小部件，与 QQ 的设置面板类似。QStackedWidget 可 用 于 创 建 类 似 于 QTabWidget 提供的用户界面。它是构建在QStackedLayout 类之上的一个方便的布局小部件。常与 QListWidget 搭配使用，效果如下图，左边的是 QListWidget 列表，右边的是 QStackedWidget。他们一般与信号槽连接，通过点击左边的 QListWidget 列表，使用信号槽连接后，就可以让右边的 QStackedWidget 显示不同的内容，每次显示一个 widget 小部件。</p><p>QMdiArea 小部件提供一个显示 MDI 窗口的区域。QMdiArea的功能本质上类似于MDI窗口的窗口管理器。大多数复杂的程序，都使用MDI框架， 在 Qt designer 中可以直接将控件 MDI Area 拖入使用。</p><p>QDockWidget类提供了一个小部件，可以停靠在QMainWindow内，也可以作为桌面的顶级窗口浮动。QDockWidget 提供了停靠部件的概念，也称为工具面板或实用程序窗口。停靠窗口是放置在 QMainWindow 中央窗口附近的停靠窗口部件区域中的辅助窗口。停靠窗口可以被移动到当前区域内，移动到新的区域，并由终端用户浮动(例如，不停靠)。QDockWidget API 允许程序员限制 dock widget 的移动、浮动和关闭能力，以及它们可以放置的区域。QDockWidget 的初始停靠区域有 Qt.BottomDockWidgetArea（底部停靠）、Qt.LeftDockWidgetArea（左边停靠、；Qt.RightDockWidgetArea （ 右 边 停 靠 ）、 Qt.TopDockWidgetArea （ 顶 部 停 靠 ） 和Qt.NoDockWidgetArea（不显示 Widget）。</p><h1 id="项目视图组-基于模型"><a href="#项目视图组-基于模型" class="headerlink" title="项目视图组(基于模型)"></a><strong>项目视图组(基于模型)</strong></h1><p>QListView</p><p>QTreeView</p><p>QColumnView</p><p>QUndoView</p><h1 id="项目控件组（基于项）"><a href="#项目控件组（基于项）" class="headerlink" title="项目控件组（基于项）"></a><strong>项目控件组（基于项）</strong></h1><p>QListWidget</p><p>QTreeWidget</p><p>QTableWidget</p><hr><p>参考资料：正点原子嵌入式Qt开发指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;这里这是简略看看，等具体做一个东西在回来仔细看&lt;/p&gt;
&lt;h1 id=&quot;输入窗口部件&quot;&gt;&lt;a href=&quot;#输入窗口部件&quot; class=&quot;headerlink&quot; title=&quot;输入窗</summary>
      
    
    
    
    
    <category term="Qt" scheme="https://www.chenzhan.club/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>note60.6-进程</title>
    <link href="https://www.chenzhan.club/2021/07/22/note60-6-%E8%BF%9B%E7%A8%8B/"/>
    <id>https://www.chenzhan.club/2021/07/22/note60-6-%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-07-22T07:36:50.000Z</published>
    <updated>2021-07-23T07:54:14.392Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a><strong>进程与程序</strong></h1><h2 id="main-函数由谁调用？"><a href="#main-函数由谁调用？" class="headerlink" title="main()函数由谁调用？"></a><strong>main()函数由谁调用？</strong></h2><p>​    操作系统下的应用程序在运行 main()函数之前需要先执行一段引导代码，最终由这段引导代码去调用应用程序的 main()函数，在编写应用程序的时候，不用考虑引导代码的问题，在编译链接时，由链接器将引导代码链接到我们的应用程序当中，一起构成最终的可执行文件。</p><p>main()函数的原型是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">或</span><br><span class="line">int main(int argc, char *argv[])</span><br></pre></td></tr></table></figure><p>​    在 Linux 下输入可执行文件的相对路径或绝对路径就可以运行该程序，譬如./app或/home/dt/app，还可根据应用程序是否接受传参在执行命令时在后面添加传入的参数信息，譬如./app arg1 arg2 或/home/dt/app arg1 arg2。当执行程序时，加载器负责将此应用程序加载内存中去执行。</p><h2 id="程序如何结束？"><a href="#程序如何结束？" class="headerlink" title="程序如何结束？"></a><strong>程序如何结束？</strong></h2><p>正常终止包括：</p><ul><li>main()函数中通过 return 语句返回来终止进程；</li><li>应用程序中调用 exit()函数终止进程；</li><li>应用程序中调用_exit()或_Exit()终止进程；</li></ul><p>异常终止包括：</p><ul><li>应用程序中调用 abort()函数终止进程；</li><li>进程接收到一个信号，譬如 SIGKILL 信号。</li></ul><p><strong>注册进程终止处理函数 atexit()</strong></p><p>​    atexit()库函数用于注册一个进程在<strong>正常终止</strong>时要调用的函数</p><p>​    如果程序当中使用了_exit()或_Exit()终止进程而并非是 exit()函数，那么将不会执行注册的终止处理函数。</p><h2 id="何为进程？"><a href="#何为进程？" class="headerlink" title="何为进程？"></a><strong>何为进程？</strong></h2><p>​    进程其实就是一个可执行程序的实例，可执行程序就是一个可执行文件，文件是一个静态的概念，存放磁盘中，如果可执行文件没有被运行，那它将不会产生什么作用，当它被运行之后，它将会对系统环境产生一定的影响，所以可执行程序的实例就是可执行文件被运行。</p><p>​    进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后它就称为了一个进程，当程序运行结束后也就意味着进程终止，这就是进程的一个生命周期。</p><h2 id="进程号"><a href="#进程号" class="headerlink" title="进程号"></a><strong>进程号</strong></h2><p>​    Linux 系统下的每一个进程都有一个进程号（processID，简称 PID），进程号是一个正数，用于唯一标识系统中的某一个进程。在 Ubuntu 系统下执行 ps 命令可以查到系统中进程相关的一些信息，包括每个进程的进程号</p><p>​    进程号的作用就是用于唯一标识系统中某一个进程，在某些系统调用中，进程号可以作为传入参数、有时也可作为返回值。譬如系统调用 kill()允许调用者向某一个进程发送一个信号，如何表示这个进程呢？则是通过进程号进行标识。</p><p>​    在应用程序中，可通过系统调用 getpid()来获取本进程的进程号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t getpid(void);&#x2F;&#x2F;函数返回值为 pid_t 类型变量，便是对应的进程号。</span><br></pre></td></tr></table></figure><p>​    可以使用 getppid()系统调用获取父进程的进程号</p><h1 id="进程的环境变量"><a href="#进程的环境变量" class="headerlink" title="进程的环境变量"></a><strong>进程的环境变量</strong></h1><p>​    每一个进程都有一组与其相关的环境变量，这些环境变量以字符串形式存储在一个字符串数组列表中，把这个数组称为环境列表。其中每个字符串都是以“名称=值（name=value）”形式定义，所以环境变量是“名称-值”的成对集合，譬如在 shell 终端下可以使用 <strong>env 命令</strong>查看到 shell 进程的所有环境变量</p><p>​    使用 export 命令还可以添加一个新的环境变量或删除一个环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LINUX_APP&#x3D;123456 # 添加 LINUX_APP 环境变量</span><br></pre></td></tr></table></figure><p>​    使用”export -n LINUX_APP”命令则可以删除 LINUX_APP 环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export -n LINUX_APP # 删除 LINUX_APP 环境变量</span><br></pre></td></tr></table></figure><h2 id="应用程序中获取环境变量"><a href="#应用程序中获取环境变量" class="headerlink" title="应用程序中获取环境变量"></a><strong>应用程序中获取环境变量</strong></h2><p>​    进程的环境变量是从其父进程中继承过来的，譬如在 shell 终端下执行一个应用程序，那么该进程的环境变量就是从其父进程（shell 进程）中继承过来的。新的进程在创建之前，会继承其父进程的环境变量副本。</p><p>​    环境变量存放在一个字符串数组中，在应用程序中，通过 environ 变量指向它，environ 是一个全局变量，在我们的应用程序中只需申明它即可使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern char **environ; &#x2F;&#x2F; 申明外部全局变量 environ</span><br></pre></td></tr></table></figure><p><strong>获取指定环境变量</strong> <strong>getenv()</strong></p><p>​    如果只想要获取某个指定的环境变量，可以使用库函数 getenv()</p><p>​    使用 getenv()需要注意，不应该去修改其返回的字符串，修改该字符串意味着修改了环境变量对应的值，Linux 提供了相应的修改函数，如果需要修改环境变量的值应该使用这些函数，不应直接改动该字符串。</p><h2 id="添加-删除-修改环境变量"><a href="#添加-删除-修改环境变量" class="headerlink" title="添加/删除/修改环境变量"></a><strong>添加/删除/修改环境变量</strong></h2><p>​    C 语言函数库中提供了用于修改、添加、删除环境变量的函数，譬如 putenv()、setenv()、unsetenv()、clearenv()函数等。</p><p><strong>putenv()函数</strong></p><p>​    putenv()函数可向进程的环境变量数组中添加一个新的环境变量，或者修改一个已经存在的环境变量对应的值</p><p>​    该函数调用成功之后，参数 string 所指向的字符串就成为了进程环境变量的一部分了，换言之，putenv()函数将设定 environ 变量（字符串数组）中的某个元素（字符串指针）指向该 string 字符串，而不是指向它的复制副本，这里需要注意！因此，不能随意修改参数 string 所指向的内容，这将影响进程的环境变量，出于这种原因，参数 string 不应为自动变量（即在栈中分配的字符数组），因为定义吃变量。</p><p><strong>setenv()函数</strong></p><p>​    setenv()函数可以替代 putenv()函数，用于向进程的环境变量列表中添加一个新的环境变量或修改现有环境变量对应的值</p><p>​    setenv()函数为形如 name=value 的字符串分配一块内存缓冲区，并将参数 name 和参数 value 所指向的字符串复制到此缓冲区中，以此来创建一个新的环境变量，所以，由此可知，setenv()与 putenv()函数有两个区别：</p><ul><li>putenv()函数并不会为 name=value 字符串分配内存；</li><li>setenv()可通过参数overwrite控制是否需要修改现有变量的值而仅以添加变量为目的，显然putenv()并不能进行控制。</li></ul><p>​    推荐使用 setenv()函数，这样使用自动变量作为 setenv()的参数也不会有问题。</p><p>​    可以通过一种更简单地方式向进程环境变量表中添加环境变量，用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAME&#x3D;value .&#x2F;app</span><br></pre></td></tr></table></figure><p>​    在执行程序的时候，在其路径前面添加环境变量，以 name=value 的形式添加，如果是多个环境变量，则在./app 前面放置多对 name=value 即可，以空格分隔。</p><p><strong>unsetenv()函数</strong></p><p>​    unsetenv()函数可以从环境变量表中移除参数 name 标识的环境变量</p><h2 id="清空环境变量"><a href="#清空环境变量" class="headerlink" title="清空环境变量"></a><strong>清空环境变量</strong></h2><p>​    需要清除环境变量表中的所有变量，然后再进行重建，可以通过将全局变量 environ 赋值为 NULL来清空所有变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environ &#x3D; NULL;</span><br></pre></td></tr></table></figure><p>​    也可通过 clearenv()函数来操作</p><p>​    clearenv()函数内部的做法其实就是将environ赋值为NULL。在某些情况下，使用setenv()函数和clearenv()函数可能会导致程序内存泄漏，前面提到过，setenv()函数会为环境变量分配一块内存缓冲区，随之称为进程的一部分；而调用 clearenv()函数时没有释放该缓冲区（clearenv()调用并不知晓该缓冲区的存在，故而也无法将其释放），反复调用者两个函数的程序，会不断产生内存泄漏。</p><h2 id="环境变量的作用"><a href="#环境变量的作用" class="headerlink" title="环境变量的作用"></a><strong>环境变量的作用</strong></h2><p>​    环境变量常见的用途之一是在 shell 中，每一个环境变量都有它所表示的含义，譬如 HOME 环境变量表示用户的家目录，USER 环境变量表示当前用户名，SHELL 环境变量表示 shell 解析器名称，PWD 环境变量表示当前所在目录等</p><h1 id="进程的内存布局"><a href="#进程的内存布局" class="headerlink" title="进程的内存布局"></a><strong>进程的内存布局</strong></h1><p>C 语言程序由以下几部分组成的：</p><ul><li><strong>正文段</strong>。也可称为代码段(text)，这是 CPU 执行的机器语言指令部分，文本段具有只读属性，以防止程序由于意外而修改其指令；正文段是可以共享的，即使在多个进程间也可同时运行同一段程序。</li><li><strong>初始化数据段</strong>。通常将此段称为数据段(data)，包含了显式初始化的全局变量和静态变量，当程序加载到内存中时，从可执行文件中读取这些变量的值。</li><li><strong>未初始化数据段</strong>。包含了未进行显式初始化的全局变量和静态变量，通常将此段称为 bss 段，这一名词来源于早期汇编程序中的一个操作符，意思是“由符号开始的块”（block started by symbol），在程序开始执行之前，系统会将本段内所有内存初始化为 0，可执行文件并没有为 bss 段变量分配存储空间，在可执行文件中只需记录 bss 段的位置及其所需大小，直到程序运行时，由加载器来分配这一段内存空间。</li><li><strong>栈</strong>。函数内的局部变量以及每次函数调用时所需保存的信息都放在此段中，每次调用函数时，函数传递的实参以及函数返回值等也都存放在栈中。栈是一个动态增长和收缩的段，由栈帧组成，系统会为每个当前调用的函数分配一个栈帧，栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。</li><li><strong>堆</strong>。可在运行时动态进行内存分配的一块区域，譬如使用 malloc()分配的内存空间，就是从系统堆内存中申请分配的。</li></ul><p>​    Linux 下的 size 命令可以查看二进制可执行文件的文本段、数据段、bss 段的段大小</p><p>​    虚拟地址递增方向由低地址到高地址，分别存放文本段（程序代码段）、初始化数据段，这两都是从可执行文件中读入的；接下来是为初始化数据段（bss），这里加载器初始为0；然后是堆区，堆区是向上增长的，既从低地址向高地址增长；接下来是栈，栈从栈顶向下增长，既从高地址向低地址增长；最后就是放在最高地址的命令行参数和环境变量。</p><h1 id="进程的虚拟地址空间"><a href="#进程的虚拟地址空间" class="headerlink" title="进程的虚拟地址空间"></a><strong>进程的虚拟地址空间</strong></h1><p>​    在 Linux 系统中，采用了虚拟内存管理技术，在 Linux 系统中，每一个进程都在自己独立的地址空间中运行，在 32 位系统中，每个进程的逻辑地址空间均为 4GB，这 4GB 的内存空间按照 3:1 的比例进行分配，其中用户进程享有 3G 的空间，而内核独自享有剩下的 1G 空间。</p><p>Linux系统下逻辑地址空间划分：</p><p>​    Kernel Space(1GB) 0xFFFFFFFF-0xC0000000</p><p>​    User Mode Space(3GB) 0xC0000000-0x0</p><p>​    虚拟地址会通过硬件 MMU（内存管理单元）映射到实际的物理地址空间中，建立虚拟地址到物理地址的映射关系后，对虚拟地址的读写操作实际上就是对物理地址的读写操作，MMU 会将虚拟地址“翻译”为对应的物理地址</p><p>​    Linux 系统下，应用程序运行在一个虚拟地址空间中，所以程序中读写的内存地址对应也是虚拟地址，并不是真正的物理地址，譬如应用程序中读写 0x80800000 这个地址，实际上并不对应于硬件的 0x80800000这个物理地址。</p><p>​    程序访问存储器所使用的逻辑地址就是虚拟地址，通过逻辑地址映射到真正的物理内存上。所有应用程序运行在自己的虚拟地址空间中，使得进程的虚拟地址空间和物理地址空间隔离开来，这样做带来了很多的优点：</p><ul><li>进程与进程、进程与内核相互隔离。一个进程不能读取或修改另一个进程或内核的内存数据，这是因为每一个进程的虚拟地址空间映射到了不同的物理地址空间。提高了系统的安全性与稳定性。</li><li>在某些应用场合下，两个或者更多进程能够共享内存。因为每个进程都有自己的映射表，可以让不同进程的虚拟地址空间映射到相同的物理地址空间中。通常，共享内存可用于实现进程间通信。</li><li>便于实现内存保护机制。譬如在多个进程共享内存时，允许每个进程对内存采取不同的保护措施，例如，一个进程可能以只读方式访问内存，而另一进程则能够以可读可写的方式访问。</li><li>编译应用程序时，无需关心链接地址。前面提到了，当程序运行时，要求链接地址与运行地址一致，在引入了虚拟地址机制后，便无需关心这个问题。</li></ul><h1 id="fork-创建子进程"><a href="#fork-创建子进程" class="headerlink" title="fork()创建子进程"></a><strong>fork()创建子进程</strong></h1><p>​    一个现有的进程可以调用 fork()函数创建一个新的进程，调用 fork()函数的进程称为父进程，由 fork()函数创建出来的进程被称为子进程（child process），fork()函数原型如下所示（fork()为系统调用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure><p>​    在诸多的应用中，创建多个进程是任务分解时行之有效的方法，譬如，某一网络服务器进程可在监听客户端请求的同时，为处理每一个请求事件而创建一个新的子进程，与此同时，服务器进程会继续监听更多的客户端连接请求。在一个大型的应用程序任务中，创建子进程通常会简化应用程序的设计，同时提高了系统的并发性（即同时能够处理更多的任务或请求，多个进程在宏观上实现同时运行）。</p><p>​    理解 fork()系统调用的关键在于，完成对其调用后将存在两个进程，一个是原进程（父进程）、另一个则是创建出来的子进程，并且每个进程都会从 fork()函数的返回处继续执行，会导致调用 fork()返回两次值，子进程返回一个值、父进程返回一个值。在程序代码中，可通过返回值来区分是子进程还是父进程。</p><p>​    <strong>fork()调用成功后，将会在父进程中返回子进程的 PID，而在子进程中返回值是 0</strong>；如果调用失败，父进程返回值-1，不创建子进程，并设置 errno。 </p><p>​    fork()调用成功后，子进程和父进程会继续执行 fork()调用之后的指令，子进程、父进程各自在自己的进程空间中运行。事实上，子进程是父进程的一个副本，譬如子进程拷贝了父进程的数据段、堆、栈以及继承了父进程打开的文件描述符，父进程与子进程并不共享这些存储空间，这是子进程对父进程相应部分存储空间的完全复制，执行 fork()之后，每个进程均可修改各自的栈数据以及堆段中的变量，而并不影响另一个进程。</p><p>​    虽然子进程是父进程的一个副本，但是对于程序代码段（文本段）来说，两个进程执行相同的代码段，因为代码段是只读的，也就是说父子进程共享代码段，在内存中只存在一份代码段数据。</p><p><strong>使用示例</strong> <strong>1</strong></p><p>使用 fork()创建子进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(void) &#123;</span><br><span class="line"> pid_t pid;</span><br><span class="line"> pid &#x3D; fork();</span><br><span class="line"> switch (pid) &#123;</span><br><span class="line"> case -1:</span><br><span class="line"> perror(&quot;fork error&quot;);</span><br><span class="line"> exit(-1);</span><br><span class="line"> case 0:</span><br><span class="line"> printf(&quot;这是子进程打印信息&lt;pid: %d, 父进程 pid: %d&gt;\n&quot;,</span><br><span class="line"> getpid(), getppid());</span><br><span class="line"> _exit(0); &#x2F;&#x2F;子进程使用_exit()退出</span><br><span class="line"> default:</span><br><span class="line"> printf(&quot;这是父进程打印信息&lt;pid: %d, 子进程 pid: %d&gt;\n&quot;,</span><br><span class="line"> getpid(), pid);</span><br><span class="line"> exit(0);</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure><p>​    由上文可知“fork()调用成功后，将会在父进程中返回子进程的 PID，而在子进程中返回值是 0”，然后子进程和父进程运行的是同一段text（代码段），所以 会有两个返回值，这可以用程序中的两种case区分出来。</p><p>​    上述示例代码中，case 0 是子进程的分支，这里使用了_exit()结束进程而没有使用 exit()。</p><p>​    Tips：C 库函数 exit()建立在系统调用_exit()之上，这里我们强调，在调用了 fork()之后，父、子进程中一般只有一个会通过调用 exit()退出进程，而另一个则应使用_exit()退出！</p><p>​    从打印结果可知，fork()之后的语句被执行了两次，所以 switch…case 语句被执行了两次，第一次进入到了”case 0”分支，通过上面的介绍可知，fork()返回值为 0 表示当前处于子进程；在子进程中我们通过 getpid()获取到子进程自己的 PID（46802），通过 getppid()获取到父进程的 PID（46803），将其打印出来。</p><p>​    第二次进入到了 default 分支，表示当前处于父进程，此时 fork()函数的返回值便是创建出来的子进程对应的 PID。 </p><p>​    fork()函数调用完成之后，父进程、子进程会各自继续执行 fork()之后的指令，最终父进程会执行到 exit()结束进程，而子进程则会通过_exit()结束进程。</p><p><strong>关于子进程</strong></p><p>​    子进程被创建出来之后，便是一个独立的进程，拥有自己独立的进程空间，系统内唯一的进程号，拥有自己独立的 PCB（进程控制块），子进程会被内核同等调度执行，参与到系统的进程调度中。</p><p>​    子进程与父进程之间的这种关系被称为父子进程关系</p><p>Tips：系统调度。Linux 系统是一个多任务、多进程、多线程的操作系统，一般来说系统启动之后会运行成百甚至上千个不同的进程，那么对于单核 CPU 计算机来说，在某一个时间它只能运行某一个进程的代码指令，那其它进程怎么办呢（多核处理器也是如此，同一时间每个核它只能运行某一个进程的代码）？这里就出现了调度的问题，系统是这样做的，每一个进程（或线程）执行一段固定的时间，时间到了之后切换执行下一个进程或线程，依次轮流执行，这就称为调度，由操作系统负责这件事情，当然系统调度的实现本身是一件非常复杂的事情，需要考虑的因素很多，这里只是让大家有个简单地认识，系统调度的基本单元是线程。</p><h1 id="父、子进程间的文件共享"><a href="#父、子进程间的文件共享" class="headerlink" title="父、子进程间的文件共享"></a><strong>父、子进程间的文件共享</strong></h1><p>​    调用 fork()函数之后，子进程会获得父进程所有文件描述符的副本，这些副本的创建方式类似于 dup()，这也意味着父、子进程对应的文件描述符均指向相同的文件表</p><p>​    比如父进程PCB的文件描述表有fd0、fd1、fd2，其中fd0指向文件表1，文件表1包含文件状态标志、当前文件偏移量和i-node指针，i-node指针又指向inode（），子进程PCB的文件描述表也有fd0、fd1、fd2，其中fd0也指向文件表1，另外父进程和子进程的fd1都指向文件表2，fd2都指向文件表3。</p><p>​    可知，子进程拷贝了父进程的文件描述符表，使得父、子进程中对应的文件描述符指向了相同的文件表，也意味着父、子进程中对应的文件描述符指向了磁盘中相同的文件，因而这些文件在父、子进程间实现了共享，譬如，如果子进程更新了文件偏移量，那么这个改变也会影响到父进程中相应文件描述符的位置偏移量。</p><p>​    父进程打开文件之后，然后 fork()创建子进程，此时子进程继承了父进程打开的文件描述符（父进程文件描述符的副本），然后父、子进程同时对文件进行写入操作父、子进程分别对同一个文件进行写入操作，结果是接续写，不管是父进程，还是子进程，在每次写入时都是从文件的末尾写入，很像使用了 O_APPEND 标志的效果。子进程继承了父进程的文件描述符，两个文件描述符都指向了一个相同的文件表，意味着它们的文件偏移量是同一个、绑定在了一起，相互影响，子进程改变了文件的位置偏移量就会作用到父进程，同理，父进程改变了文件的位置偏移量就会作用到子进程。</p><p>​    父进程在调用 fork()之后，此时父进程和子进程都去打开同一个文件，然后再对文件进行写入操作，这种文件共享方式实现的是一种两个进程分别各自对文件进行写入操作，因为父、子进程的这两个文件描述符分别指向的是不同的文件表，意味着它们有各自的文件偏移量，一个进程修改了文件偏移量并不会影响另一个进程的文件偏移量，所以写入的数据会出现覆盖的情况。</p><p><strong>fork()函数使用场景</strong></p><p>fork()函数有以下两种用法：</p><ul><li>父进程希望子进程复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的，父进程等待客户端的服务请求，当接收到客户端发送的请求事件后，调用 fork()创建一个子进程，使子进程去处理此请求、而父进程可以继续等待下一个服务请求。</li><li>一个进程要执行不同的程序。譬如在程序 app1 中调用 fork()函数创建了子进程，此时子进程是要去执行另一个程序 app2，也就是子进程需要执行的代码是 app2 程序对应的代码，子进程将从 app2程序的 main 函数开始运行。这种情况，通常在子进程从 fork()函数返回之后立即调用 exec 族函数来实现。</li></ul><h1 id="系统调用-vfork"><a href="#系统调用-vfork" class="headerlink" title="系统调用 vfork()"></a><strong>系统调用</strong> <strong>vfork()</strong></h1><p>​    除了 fork()系统调用之外，Linux 系统还提供了 vfork()系统调用用于创建子进程，vfork()与 fork()函数在功能上是相同的，并且返回值也相同，在一些细节上存在区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t vfork(void);</span><br></pre></td></tr></table></figure><p>​    可以将 fork()认作对父进程的数据段、堆段、栈段以及其它一些数据结构创建拷贝，由此可以看出，使用 fork()系统调用的代价是很大的，它复制了父进程中的数据段和堆栈段中的绝大部分内容，这将会消耗比较多的时间，效率会有所降低，而且太浪费，原因有很多，其中之一在于，fork()函数之后子进程通常会调用 exec 函数，也就是 fork()第二种使用场景下，这使得子进程不再执行父程序中的代码段，而是执行新程序的代码段，从新程序的 main 函数开始执行、并为新程序重新初始化其数据段、堆段、栈段等；那么在这种情况下，子进程并不需要用到父进程的数据段、堆段、栈段（譬如父程序中定义的局部变量、全局变量等）中的数据，此时就会导致浪费时间、效率降低。</p><p>​    事实上，现代 Linux 系统采用了一些技术来避免这种浪费，其中很重要的一点就是内核采用了写时复制（<strong>copy-on-write</strong>）技术</p><p>​    出于这一原因，引入了 vfork()系统调用，虽然在一些细节上有所不同，但其效率要高于 fork()函数。类似于 fork()，vfork()可以为调用该函数的进程创建一个新的子进程，然而，vfork()是为子进程立即执行 exec()新的程序而专门设计的，也就是 fork()函数的第二个使用场景。</p><p>​    vfork()与 fork()函数主要有以下两个区别：</p><ul><li>vfork()与 fork()一样都创建了子进程，但 vfork()函数并不会将父进程的地址空间完全复制到子进程中，因为子进程会立即调用 exec（或_ exit），于是也就不会引用该地址空间的数据。不过在子进程 调用 exec 或_ exit 之前，它在父进程的空间中运行、子进程共享父进程的内存。这种优化工作方式的实现提高的效率；但如果子进程修改了父进程的数据（除了 vfork 返回值的变量）、进行了函数调用、或者没有调用 exec 或_exit 就返回将可能带来未知的结果。</li><li>另一个区别在于，vfork()保证子进程先运行，子进程调用 exec 之后父进程才可能被调度运行。</li></ul><p>​    虽然 vfork()系统调用在效率上要优于 fork()，但是 vfork()可能会导致一些难以察觉的程序 bug，所以尽量避免使用 vfork()来创建子进程，虽然 fork()在效率上并没有 vfork()高，但是现代的 Linux 系统内核已经采用了写时复制技术来实现 fork()，其效率较之于早期的 fork()实现要高出许多，除非速度绝对重要的场合，我们的程序当中应舍弃 vfork()而使用 fork()。</p><p>​    在正式的使用场合下，一般应在子进程中立即调用 exec，如果 exec 调用失败，子进程则应调用_exit()退出（vfork 产生的子进程不应调用 exit 退出，因为这会导致对父进程 stdio 缓冲区的刷新和关闭）。</p><h1 id="fork-之后的竞争条件"><a href="#fork-之后的竞争条件" class="headerlink" title="fork()之后的竞争条件"></a><strong>fork()之后的竞争条件</strong></h1><p>​    调用 fork()之后，子进程成为了一个独立的进程，可被系统调度运行，而父进程也继续被系统调度运行，这里出现了一个问题，调用 fork 之后，无法确定父、子两个进程谁将率先访问 CPU，也就是说无法确认谁先被系统调用运行（在多核处理器中，它们可能会同时各自访问一个 CPU），这将导致谁先运行、谁后运行这个顺序是不确定的</p><p>​    那如何明确保证某一特性执行顺序呢？这个时候可以通过采用采用某种同步技术来实现，譬如前面给大家介绍的信号，如果要让子进程先运行，则可使父进程被阻塞，等到子进程来唤醒它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">示例代码 利用信号来调整进程间动作</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"></span><br><span class="line">static void sig_handler(int sig) </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;接收到信号\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line"> struct sigaction sig &#x3D; &#123;0&#125;;</span><br><span class="line"> sigset_t wait_mask;</span><br><span class="line"> </span><br><span class="line">&#x2F;* 初始化信号集 *&#x2F;</span><br><span class="line"> sigemptyset(&amp;wait_mask);</span><br><span class="line"> </span><br><span class="line"> &#x2F;* 设置信号处理方式 *&#x2F;</span><br><span class="line"> sig.sa_handler &#x3D; sig_handler;</span><br><span class="line"> sig.sa_flags &#x3D; 0;</span><br><span class="line"> if (-1 &#x3D;&#x3D; sigaction(SIGUSR1, &amp;sig, NULL)) &#123;</span><br><span class="line"> perror(&quot;sigaction error&quot;);</span><br><span class="line"> exit(-1);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> switch (fork()) &#123;</span><br><span class="line"> case -1:</span><br><span class="line"> perror(&quot;fork error&quot;);</span><br><span class="line"> exit(-1);</span><br><span class="line"> </span><br><span class="line"> case 0:</span><br><span class="line"> &#x2F;* 子进程 *&#x2F;</span><br><span class="line"> printf(&quot;子进程开始执行\n&quot;);</span><br><span class="line"> printf(&quot;子进程打印信息\n&quot;);</span><br><span class="line"> printf(&quot;~~~~~~~~~~~~~~~\n&quot;);</span><br><span class="line"> sleep(2);</span><br><span class="line"> kill(getppid(), SIGUSR1); &#x2F;&#x2F;发送信号给父进程、唤醒它</span><br><span class="line"> _exit(0);</span><br><span class="line"> </span><br><span class="line"> default:</span><br><span class="line"> &#x2F;* 父进程 *&#x2F;</span><br><span class="line"> if (-1 !&#x3D; sigsuspend(&amp;wait_mask))&#x2F;&#x2F;挂起、阻塞</span><br><span class="line"> exit(-1);</span><br><span class="line"> </span><br><span class="line"> printf(&quot;父进程开始执行\n&quot;);</span><br><span class="line"> printf(&quot;父进程打印信息\n&quot;);</span><br><span class="line"> exit(0);</span><br><span class="line"> &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>​    这里我们希望子进程先运行打印相应信息，之后再执行父进程打印信息，在父进程分支中，直接调用了 sigsuspend()使父进程进入挂起状态，由子进程通过 kill 命令发送信号唤醒</p><h1 id="进程的诞生与终止"><a href="#进程的诞生与终止" class="headerlink" title="进程的诞生与终止"></a><strong>进程的诞生与终止</strong></h1><h2 id="进程的诞生"><a href="#进程的诞生" class="headerlink" title="进程的诞生"></a><strong>进程的诞生</strong></h2><p>​    一个进程可以通过 fork()或 vfork()等系统调用创建一个子进程，一个新的进程就此诞生！事实上，Linux系统下的所有进程都是由其父进程创建而来，譬如在 shell 终端通过命令的方式执行一个程序./app，那么 app进程就是由 shell 终端进程创建出来的，shell 终端就是该进程的父进程。</p><p>​    在 Ubuntu 系统下使用”ps -aux”命令可以查看到系统下所有进程信息</p><p>​    图中进程号为 1 的进程便是所有进程的父进程，通常称为 init 进程，它是 Linux 系统启动之后运行的第一个进程，它管理着系统上所有其它进程，init 进程是由内核启动，因此理论上说它没有父进程。</p><p>​    init 进程的 PID 总是为 1，它是所有子进程的父进程，一切从 1 开始、一切从 init 进程开始！</p><p>​    <u>一个进程的生命周期便是从创建开始直至其终止。</u></p><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a><strong>进程的终止</strong></h2><p>​    _exit()函数和 exit()函数的 status 参数定义了进程的终止状态（termination status），父进程可以调用 wait()函数以获取该状态。虽然参数 status 定义为 int 类型，但仅有低 8 位表示它的终止状态，一般来说，终止状态为 0 表示进程成功终止，而非 0 值则表示进程在执行过程中出现了一些错误而终止，譬如文件打开失败、读写失败等等，对非 0 返回值的解析并无定例。</p><p>​    在我们的程序当中，一般使用 exit()库函数而非_ exit()系统调用，原因在于 exit()最终也会通过_exit()终止进程，但在此之前，它将会完成一些其它的工作，exit()函数会执行的动作如下：</p><ul><li>如果程序中注册了进程终止处理函数，那么会调用终止处理函数。</li><li>刷新 stdio 流缓冲区。</li><li>执行_exit()系统调用。</li></ul><p>​    exit()函数会比_exit()会多做一些事情，包括执行终止处理函数、刷新 stdio 流缓冲以及调用<em>exit()，在前面曾提到过，在我们的程序当中，父、子进程不应都使用 exit()终止，只能有一个进程使用 exit()、而另一个则使用</em> exit()退出，当然一般推荐的是<strong>子进程使用_exit()退出、而父进程则使用 exit()退出</strong>。其原因就在于调用 exit()函数终止进程时会刷新进程的 stdio 缓冲区。</p><p>​    进程的用户空间内存中维护了 stdio 缓冲区，通过 fork()创建子进程时会复制这些缓冲区，标准输出设备默认使用的是行缓冲，当检测到换行符\n 时会立即显示函数 printf()输出的字符串，读走缓冲区中的数据并显示，读走之后此时缓冲区就空了。</p><ul><li>对于行缓冲设备，可以加上对应换行符，譬如 printf 打印输出字符串时在字符串后面添加\n 换行符，对于 puts()函数来说，本身会自动添加换行符；</li><li>在调用 fork()之前，使用函数 fflush()来刷新 stdio 缓冲区，当然，作为另一种选择，也可以使用setvbuf()和 setbuf()来关闭 stdio 流的缓冲功能；</li><li>子进程调用_ exit()退出进程、而非使用 exit()，调用_exit()在退出时便不会刷新 stdio 缓冲区。</li></ul><h1 id="监视子进程"><a href="#监视子进程" class="headerlink" title="监视子进程"></a><strong>监视子进程</strong></h1><p>​    在很多应用程序的设计中，父进程需要知道子进程于何时被终止，并且需要知道子进程的终止状态信 息，是正常终止、还是异常终止亦或者被信号终止等，意味着父进程会对子进程进行监视。</p><h2 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a><strong>wait()函数</strong></h2><p>​    对于许多需要创建子进程的进程来说，有时设计需要监视子进程的终止时间以及终止时的一些状态信 息，在某些设计需求下这是很有必要的。系统调用 wait()可以等待进程的任一子进程终止，同时获取子进程的终止状态信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">pid_t wait(int *status);</span><br></pre></td></tr></table></figure><p>​    <strong>status</strong>：参数 status 用于存放子进程终止时的状态信息，参数 status 可以为 NULL，表示不接收子进程终止时的状态信息。<strong>返回值：</strong>若成功则返回终止的子进程对应的进程号；失败则返回-1。</p><p>​    系统调用 wait()将执行如下动作：</p><ul><li>调用 wait()函数，如果其所有子进程都还在运行，则 wait()会一直阻塞等待，直到某一个子进程终止；</li><li>如果进程调用 wait()，但是该进程并没有子进程，也就意味着该进程并没有需要等待的子进程，那 么 wait()将返回错误，也就是返回-1、并且会将 errno 设置为 ECHILD。</li><li>如果进程调用 wait()之前，它的子进程当中已经有一个或多个子进程已经终止了，那么调用 wait()也不会阻塞。wait()函数的作用除了获取子进程的终止状态信息之外，更重要的一点，就是回收子进程的一些资源，俗称为子进程“收尸”，所以在调用 wait()函数之前，已经有子进程终止了，意味着正等待着父进程为其“收尸”，所以调用 wait()将不会阻塞，而是会立即替该子进程“收尸”、处理它的“后事”，然后返回到正常的程序流程中，一次 wait()调用只能处理一次。</li></ul><p>​    参数 status 不为 NULL 的情况下，则 wait()会将子进程的终止时的状态信息存储在它指向的 int 变量中，可以通过以下宏来检查 status 参数：</p><ul><li><strong>WIFEXITED(status)：</strong>如果子进程正常终止，则返回 true； </li><li><strong>WEXITSTATUS(status)：</strong>返回子进程退出状态，是一个数值，其实就是子进程调用_ exit()或 exit()时指定的退出状态；wait()获取得到的 status 参数并不是调用_ exit()或 exit()时指定的状态，可通过WEXITSTATUS 宏转换；</li><li><strong>WIFSIGNALED(status)：</strong>如果子进程被信号终止，则返回 true； </li><li><strong>WTERMSIG(status)：</strong>返回导致子进程终止的信号编号。如果子进程是被信号所终止，则可以通过此宏获取终止子进程的信号；</li><li><strong>WCOREDUMP(status)：</strong>如果子进程终止时产生了核心转储文件，则返回 true；</li></ul><p>​    还有一些其它的宏定义，具体的请查看 man 手册。</p><h2 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid()函数"></a><strong>waitpid()函数</strong></h2><p>​    使用 wait()系统调用存在着一些限制，这些限制包括如下：</p><ul><li>如果父进程创建了多个子进程，使用 wait()将无法等待某个特定的子进程的完成，只能按照顺序等待下一个子进程的终止，一个一个来、谁先终止就先处理谁； </li><li>如果子进程没有终止，正在运行，那么 wait()总是保持阻塞，有时我们希望执行非阻塞等待，是否有子进程终止，通过判断即可得知；</li><li>使用 wait()只能发现那些被终止的子进程，对于子进程因某个信号（譬如 SIGSTOP 信号）而停止（注意，这里停止指的暂停运行），或是已停止的子进程收到 SIGCONT 信号后恢复执行的情况就无能为力了</li></ul><p>​    waitpid()则可以突破这些限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">pid_t waitpid(pid_t pid, int *status, int options);</span><br></pre></td></tr></table></figure><p>​    <strong>pid：</strong>参数 pid 用于表示需要等待的某个具体子进程，关于参数 pid 的取值范围如下：</p><ul><li>如果 pid 大于 0，表示等待进程号为 pid 的子进程；</li><li>如果 pid 等于 0，则等待与调用进程（父进程）同一个进程组的所有子进程；</li><li>如果 pid 小于-1，则会等待进程组标识符与 pid 绝对值相等的所有子进程；</li><li>如果 pid 等于-1，则等待任意子进程。wait(&amp;status)与 waitpid(-1, &amp;status, 0)等价。</li></ul><p>​    <strong>status：</strong>与 wait()函数的 status 参数意义相同。</p><p>​    参数 options 是一个位掩码，可以包括 0 个或多个如下标志：</p><ul><li><strong>WNOHANG：</strong>如果子进程没有发生状态改变（终止、暂停），则立即返回，也就是执行非阻塞等待，可以实现轮训 poll，通过返回值可以判断是否有子进程发生状态改变，若返回值等于 0 表示没有发生改变。</li><li><strong>WUNTRACED：</strong>除了返回终止的子进程的状态信息外，还返回因信号而停止（暂停运行）的子进程状态信息；</li><li><strong>WCONTINUED：</strong>返回那些因收到 SIGCONT 信号而恢复运行的子进程的状态信息。</li></ul><h2 id="waitid-函数"><a href="#waitid-函数" class="headerlink" title="waitid()函数"></a><strong>waitid()函数</strong></h2><h2 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a><strong>僵尸进程与孤儿进程</strong></h2><p>​    当一个进程创建子进程之后，它们俩就成为父子进程关系，父进程与子进程的生命周期往往是不相同的，这里就会出现两个问题：</p><ul><li>父进程先于子进程结束。</li><li>子进程先于父进程结束。</li></ul><p><strong>孤儿进程</strong></p><p>​    父进程先于子进程结束，也就是意味着，此时子进程变成了一个“孤儿”，我们把这种进程就称为孤儿进程。在 Linux 系统当中，所有的孤儿进程都自动成为 init 进程（进程号为 1）的子进程，换言之，某一子进程的父进程结束后，该子进程调用 getppid()将返回 1，init 进程变成了孤儿进程的“养父”；这是判定某一子进程的“生父”是否还“在世”的方法之一</p><p>​    事实上，/sbin/upstart 进程与 Ubuntu 系统图形化界面有关系，是图形化界面下的一个后台守护进程，可负责“收养”孤儿进程，所以图形化界面下，upstart 进程就自动成为了孤儿进程的父进程</p><p>​    进入 <strong>Ubuntu 字符界面</strong>，按 Ctrl + Alt + F1 进入，按 Ctrl + Alt + F7 回到 <strong>Ubuntu 图形化界面</strong>。</p><p><strong>僵尸进程</strong></p><p>​    进程结束之后，通常需要其父进程为其“收尸”，回收子进程占用的一些内存资源，父进程通过调用wait()（或其变体 waitpid()、waitid()等）函数回收子进程资源，归还给系统。</p><p>​    如果子进程先于父进程结束，此时父进程还未来得及给子进程“收尸”，那么此时子进程就变成了一个僵尸进程。子进程结束后其父进程并没有来得及立马给它“收尸”，子进程处于“曝尸荒野”的状态，在这么一个状态下，我们就将子进程成为僵尸进程</p><p>​    当父进程调用 wait()（或其变体）为子进程“收尸”后，僵尸进程就会被内核彻底删除。另外一种情况，如果父进程并没有调用 wait()函数然后就退出了，那么此时 init 进程将会接管它的子进程并自动调用 wait()，故而从系统中移除僵尸进程。</p><p>​    如果父进程创建了某一子进程，子进程已经结束，而父进程还在正常运行，但父进程并未调用 wait()回收子进程，此时子进程变成一个僵尸进程。首先来说，这样的程序设计是有问题的，如果系统中存在大量的僵尸进程，它们势必会填满内核进程表，从而阻碍新进程的创建。需要注意的是，僵尸进程是无法通过信号将其杀死的，即使是“一击必杀”信号 SIGKILL 也无法将其杀死，那么这种情况下，只能杀死僵尸进程的父进程（或等待其父进程终止），这样 init 进程将会接管这些僵尸进程，从而将它们从系统中清理掉！所以，在我们的一个程序设计中，一定要监视子进程的状态变化，如果子进程终止了，要调用 wait()将其回收，避免僵尸进程。</p><p>​    子进程已经退出，但其父进程并没调用 wait()为其“收尸”，使得子进程成为一个僵尸进程，使用命令”ps -aux”可以查看到该僵尸进程，可以看到它的状态栏显示的是“Z”（zombie，僵尸），表示它是一个僵尸进程。</p><h2 id="SIGCHLD-信号"><a href="#SIGCHLD-信号" class="headerlink" title="SIGCHLD 信号"></a><strong>SIGCHLD</strong> <strong>信号</strong></h2><p>​    当发生以下两种情况时，父进程会收到该信号：</p><ul><li>当父进程的某个子进程终止时，父进程会收到 SIGCHLD 信号；</li><li>当父进程的某个子进程因收到信号而停止（暂停运行）或恢复时，内核也可能向父进程发送该信号。</li></ul><p>​    子进程的终止属于异步事件，父进程事先是无法预知的，如果父进程有自己需要做的事情，它不能一直wait()阻塞等待子进程终止（或轮训），这样父进程将啥事也做不了，那么有什么办法来解决这样的尴尬情况，当然有办法，那就是通过 SIGCHLD 信号。</p><p>​    那既然子进程状态改变时（终止、暂停或恢复），父进程会收到 SIGCHLD 信号，SIGCHLD 信号的系统默认处理方式是将其忽略，所以我们要捕获它、绑定信号处理函数，在信号处理函数中调用 wait()收回子进程，回收完毕之后再回到父进程自己的工作流程中。</p><p>​    当调用信号处理函数时，会暂时将引发调用的信号添加到进程的信号掩码中（除非 sigaction()指定了 SA_NODEFER 标志），这样一来，当 SIGCHLD 信号处理函数正在为一个终止的子进程“收尸”时，如果相继有两个子进程终止，即使产生了两次 SIGCHLD 信号，父进程也只能捕获到一次 SIGCHLD 信号，结果是，父进程的 SIGCHLD 信号处理函数每次只调用一次 wait()，那么就会导致有些僵尸进程成为“漏网之鱼”。</p><p>​    解决方案就是：在 SIGCHLD 信号处理函数中循环以非阻塞方式来调用 waitpid()，直至再无其它终止的子进程需要处理为止，所以，通常 SIGCHLD 信号处理函数内部代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (waitpid(-1, NULL, WNOHANG) &gt; 0)</span><br><span class="line">continue;</span><br></pre></td></tr></table></figure><p>​    上述代码一直循环下去，直至 waitpid()返回 0，表明再无僵尸进程存在；或者返回-1，表明有错误发生。应在创建任何子进程之前，为 SIGCHLD 信号绑定处理函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">示例代码 9.10.6 异步方式监视 wait 回收子进程</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">static void wait_child(int sig) &#123;</span><br><span class="line"> &#x2F;* 替子进程收尸 *&#x2F;</span><br><span class="line"> printf(&quot;父进程回收子进程\n&quot;);</span><br><span class="line"> while (waitpid(-1, NULL, WNOHANG) &gt; 0)</span><br><span class="line"> continue; &#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line"> struct sigaction sig &#x3D; &#123;0&#125;;</span><br><span class="line"> &#x2F;* 为 SIGCHLD 信号绑定处理函数 *&#x2F;</span><br><span class="line"> sigemptyset(sig.sa_mask);</span><br><span class="line"> sig.sa_handler &#x3D; wait_child;</span><br><span class="line"> sig.sa_flags &#x3D; 0;</span><br><span class="line"> if (-1 &#x3D;&#x3D; sigaction(SIGCHLD, &amp;sig, NULL)) &#123;</span><br><span class="line"> perror(&quot;sigaction error&quot;);</span><br><span class="line"> exit(-1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;* 创建子进程 *&#x2F;</span><br><span class="line"> switch (fork()) &#123;</span><br><span class="line"> case -1:</span><br><span class="line"> perror(&quot;fork error&quot;);</span><br><span class="line"> exit(-1);</span><br><span class="line"> case 0:</span><br><span class="line"> &#x2F;* 子进程 *&#x2F;</span><br><span class="line"> printf(&quot;子进程&lt;%d&gt;被创建\n&quot;, getpid());</span><br><span class="line"> sleep(1);</span><br><span class="line"> printf(&quot;子进程结束\n&quot;);</span><br><span class="line"> _exit(0);</span><br><span class="line">default:</span><br><span class="line"> &#x2F;* 父进程 *&#x2F;</span><br><span class="line"> break;</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(3);</span><br><span class="line"> exit(0);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="执行新程序"><a href="#执行新程序" class="headerlink" title="执行新程序"></a><strong>执行新程序</strong></h1><p>​    当子进程的工作不再是运行父进程的代码段，而是运行另一个新程序的代码，那么这个时候子进程可以通过 exec 函数来实现运行另一个新的程序，从新程序的 main()函数开始运行</p><p><strong>execve()函数</strong></p><p>​    系统调用 execve()可以将新程序加载到某一进程的内存空间，通过调用 execve()函数将一个外部的可执行文件加载到进程的内存空间运行，使用新的程序替换旧的程序，而进程的栈、数据、以及堆数据会被新程序的相应部件所替换，然后从新程序的 main()函数开始执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure><p>​    <strong>filename：</strong>参数 filename 指向需要载入当前进程空间的新程序的路径名，既可以是绝对路径、也可以是相对路径。</p><p>​    <strong>返回值：</strong>execve 调用成功将不会返回；失败将返回-1，并设置 errno。</p><p>​    对 execve()的成功调用将永不返回，而且也无需检查它的返回值，实际上，一旦该函数返回，就表明它发生了错误。</p><p>​    基于系统调用 execve()，还提供了一系列以 exec 为前缀命名的库函数，虽然函数参数各异，当其功能相同，通常将这些函数（包括系统调用 execve()）称为 exec 族函数，所以 exec 函数并不是指某一个函数、而是 exec 族函数</p><p>​    通常将调用这些 exec 函数加载一个外部新程序的过程称为 exec 操作。</p><p>​    通常由 fork()生成的子进程对 execve()的调用最为频繁，也就是子进程执行 exec 操作</p><h2 id="exec-库函数"><a href="#exec-库函数" class="headerlink" title="exec 库函数"></a><strong>exec</strong> <strong>库函数</strong></h2><p>​    exec 族函数中的库函数都是基于系统调用 execve()而实现的，虽然参数各异、但功能相同，包括：execl()、execlp()、execle()、execv()、execvp()、execvpe()</p><h2 id="system-函数"><a href="#system-函数" class="headerlink" title="system()函数"></a><strong>system()函数</strong></h2><p>​    使用 system()函数可以很方便地在我们的程序当中执行任意 shell 命令</p><p>​    system()函数其内部的是通过调用 fork()、execl()以及 waitpid()这三个函数来实现它的功能，首先 system()会调用 fork()创建一个子进程来运行 shell（可以把这个子进程成为 shell 进程），并通过 shell 执行参数command 所指定的命令</p><h1 id="进程状态与进程关系"><a href="#进程状态与进程关系" class="headerlink" title="进程状态与进程关系"></a><strong>进程状态与进程关系</strong></h1><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a><strong>进程状态</strong></h2><p>​    Linux 系统下进程通常存在 6 种不同的状态，分为：就绪态、运行态、僵尸态、可中断睡眠状态（浅度睡眠）、不可中断睡眠状态（深度睡眠）以及暂停态。</p><ul><li><strong>就绪态</strong>（Ready）：指该进程满足被 CPU 调度的所有条件但此时并没有被调度执行，只要得到 CPU就能够直接运行；意味着该进程已经准备好被 CPU 执行，当一个进程的时间片到达，操作系统调度程序会从就绪态链表中调度一个进程；</li><li><strong>运行态</strong>：指该进程当前正在被 CPU 调度运行，处于就绪态的进程得到 CPU 调度就会进入运行态；</li><li>僵尸态：僵尸态进程其实指的就是僵尸进程，指该进程已经结束、但其父进程还未给它“收尸”；</li><li>可中断睡眠状态：可中断睡眠也称为浅度睡眠，表示睡的不够“死”，还可以被唤醒，一般来说可以通过信号来唤醒；</li><li>不可中断睡眠状态：不可中断睡眠称为深度睡眠，深度睡眠无法被信号唤醒，只能等待相应的条件成立才能结束睡眠状态。把浅度睡眠和深度睡眠统称为等待态（或者叫<strong>阻塞态</strong>），表示进程处于一种等待状态，等待某种条件成立之后便会进入到就绪态；所以，处于等待态的进程是无法参与进程系统调度的。</li><li>暂停态：暂停并不是进程的终止，表示进程暂停运行，一般可通过信号将进程暂停，譬如 SIGSTOP信号；处于暂停态的进程是可以恢复进入到就绪态的，譬如收到 SIGCONT 信号。</li></ul><p>​    一个新创建的进程会处于就绪态，只要得到 CPU 就能被执行。</p><p>​    <u>就绪态被调度就会进入运行态，当运行态时间片耗尽就会进入就绪态；运行态如果等待资源到位就会进入等待态，当等待态资源到位之后就会进入就绪态；当运行态进程结束但未被回收时就会进入僵尸态；运行态得到SIGSTOP信号就会进入暂停态，暂停态收到SIGCONT信号后就会进入就绪态。</u></p><h2 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a><strong>进程关系</strong></h2><p>​    在 Linux 系统下，每个进程都有自己唯一的标识：进程号（进程 ID、PID），也有自己的生命周期，进程都有自己的父进程、而父进程也有父进程，这就形成了一个以 init 进程为根的进程家族树；当子进程终止时，父进程会得到通知并能取得子进程的退出状态。</p><p>​    除此之外，进程间还存在着其它一些层次关系，譬如进程组和会话</p><p><strong>1、无关系</strong></p><p>​    两个进程间没有任何关系，相互独立。 </p><p><strong>2、父子进程关系</strong></p><p>​    两个进程间构成父子进程关系，譬如一个进程 fork()创建出了另一个进程，那么这两个进程间就构成了父子进程关系，调用 fork()的进程称为父进程、而被 fork()创建出来的进程称为子进程；当然，如果“生父”先与子进程结束，那么 init 进程（“养父”）就会成为子进程的父进程，它们之间同样也是父子进程关系。</p><p><strong>3、进程组</strong></p><p>​    每个进程除了有一个进程 ID、父进程 ID 之外，还有一个进程组 ID，用于标识该进程属于哪一个进程组，进程组是一个或多个进程的集合，这些进程并不是孤立的，它们彼此之间或者存在父子、兄弟关系，或者在功能上有联系。</p><p>​    Linux 系统设计进程组实质上是为了方便对进程进行管理。假设为了完成一个任务，需要并发运行 100个进程，但当处于某种场景时需要终止这 100 个进程，若没有进程组就需要一个一个去终止，这样非常麻烦且容易出现一些问题；有了进程组的概念之后，就可以将这 100 个进程设置为一个进程组，这些进程共享一个进程组 ID，这样一来，终止这 100 个进程只需要终止该进程组即可。</p><p>关于进程组需要注意以下以下内容：</p><ul><li>每个进程必定属于某一个进程组、且只能属于一个进程组；</li><li>每一个进程组有一个组长进程，组长进程的 ID 就等于进程组 ID； </li><li>在组长进程的 ID 前面加上一个负号即是操作进程组；</li><li>组长进程不能再创建新的进程组；</li><li>只要进程组中还存在一个进程，则该进程组就存在，这与其组长进程是否终止无关；</li><li>一个进程组可以包含一个或多个进程，进程组的生命周期从被创建开始，到其内所有进程终止或离开该进程组； </li><li>默认情况下，新创建的进程会继承父进程的进程组 ID。</li></ul><p>​    通过系统调用 getpgrp()或 getpgid()可以获取进程对应的进程组 ID</p><p>​    这两个函数都用于获取进程组 ID，getpgrp()没有参数，返回值总是调用者进程对应的进程组 ID；而对于 getpgid()函数来说，可通过参数 pid 指定获取对应进程的进程组 ID，如果参数 pid 为 0 表示获取调用者进程的进程组 ID。 </p><p>​    调用系统调用 setpgid()或 setpgrp()可以加入一个现有的进程组或创建一个新的进程组</p><p>​    setpgrp()函数等价于 setpgid(0, 0)。</p><p>​    一个进程只能为它自己或它的子进程设置进程组 ID，在它的子进程调用 exec 函数后，它就不能更改该子进程的进程组 ID 了。</p><p><strong>会话</strong></p><p>​    会话是一个或多个进程组的集合</p><p>​    登录shell组成一个进程组，proc1和proc2组成进程组，pro3、proc4和proc5组成进程组，然后这三个进程组组成会话</p><p>​    一个会话可包含一个或多个进程组，但只能有一个前台进程组，其它的是后台进程组；每个会话都有一个会话首领（leader），即创建会话的进程。一个会话可以有控制终端、也可没有控制终端，在有控制终端的情况下也只能连接一个控制终端，这通常是登录到其上的终端设备（在终端登录情况下）或伪终端设备（譬如通过 SSH 协议网络登录），一个会话中的进程组可被分为一个前台进程组以及一个或多个后台进程组。</p><p>​    会话的首领进程连接一个终端之后，该终端就成为会话的控制终端，与控制终端建立连接的会话首领进程被称为控制进程；产生在终端上的输入和信号将发送给会话的前台进程组中的所有进程，譬如 Ctrl + C（产生 SIGINT 信号）、Ctrl + Z（产生 SIGTSTP 信号）、Ctrl + \（产生 SIGQUIT 信号）等等这些由控制终端产生的信号。</p><p>​    当用户在某个终端登录时，一个新的会话就开始了；当我们在 Linux 系统下打开了多个终端窗口时，实际上就是创建了多个终端会话。</p><p>​    一个进程组由组长进程的 ID 标识，而对于会话来说，会话的首领进程的进程组 ID 将作为该会话的标识，也就是会话 ID（sid），在默认情况下，新创建的进程会继承父进程的会话 ID。通过系统调用 getsid()可以获取进程的会话 ID</p><p>​    如果调用者进程不是进程组的组长进程，调用 setsid()将创建一个新的会话，调用者进程是新会话的首领进程，同样也是一个新的进程组的组长进程，调用 setsid()创建的会话将没有控制终端。</p><h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a><strong>守护进程</strong></h1><p>​    守护进程（Daemon）也称为精灵进程，是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些事情的发生，主要表现为以下两个特点：</p><ul><li><strong>长期运行。</strong>守护进程是一种生存期很长的一种进程，它们一般在系统启动时开始运行，除非强行终止，否则直到系统关机都会保持运行。与守护进程相比，普通进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，但守护进程不受用户登录注销的影响，它们将会一直运行着、直到系统关机。</li><li><strong>与控制终端脱离。</strong>在 Linux 中，系统与用户交互的界面称为终端，每一个从终端开始运行的进程都会依附于这个终端，这是上一小节给大家介绍的控制终端，也就是会话的控制终端。当控制终端被关闭的时候，该会话就会退出，由控制终端运行的所有进程都会被终止，这使得普通进程都是和运行该进程的终端相绑定的；但守护进程能突破这种限制，它脱离终端并且在后台运行，脱离终端的目的是为了避免进程在运行的过程中的信息在终端显示并且进程也不会被任何终端所产生的信息所打断。</li></ul><p>​    守护进程是一种很有用的进程。Linux 中大多数服务器就是用守护进程实现的，譬如，Internet 服务器inetd、Web 服务器 httpd 等。同时，守护进程完成许多系统任务，譬如作业规划进程 crond 等。</p><p>​    守护进程 Daemon，通常简称为 d，一般进程名后面带有 d 就表示它是一个守护进程。守护进程与终端无任何关联，用户的登录与注销与守护进程无关、不受其影响，守护进程自成进程组、自成会话，即pid=gid=sid。通过命令”ps -ajx”查看系统所有的进程</p><p>​    TTY 一栏是问号？表示该进程没有控制终端，也就是守护进程，其中 COMMAND 一栏使用中括号[]括起来的表示内核线程，这些线程是在内核里创建，没有用户空间代码，因此没有程序文件名和命令行，通常采用 k 开头的名字，表示 Kernel。</p><h2 id="编写守护进程程序"><a href="#编写守护进程程序" class="headerlink" title="编写守护进程程序"></a><strong>编写守护进程程序</strong></h2><p><strong>1)</strong> <strong>创建子进程、终止父进程</strong></p><p>​    父进程调用 fork()创建子进程，然后父进程使用 exit()退出，这样做实现了下面几点。第一，如果该守护进程是作为一条简单地 shell 命令启动，那么父进程终止会让 shell 认为这条命令已经执行完毕。第二，虽然子进程继承了父进程的进程组ID，但它有自己独立的进程ID，这保证了子进程不是一个进程组的组长进程，这是下面将要调用 setsid 函数的先决条件！</p><p><strong>2)</strong> <strong>子进程调用</strong> <strong>setsid</strong> <strong>创建会话</strong></p><p>​    这步是关键，在子进程中调用 setsid()函数创建新的会话，由于之前子进程并不是进程组的组长进程，所以调用 setsid()会使得子进程创建一个新的会话，子进程成为新会话的首领进程，同样也创建了新的进程组、子进程成为组长进程，此时创建的会话将没有控制终端。所以这里调用 setsid 有三个作用：让子进程摆脱原会话的控制、让子进程摆脱原进程组的控制和让子进程摆脱原控制终端的控制。在调用 fork 函数时，子进程继承了父进程的会话、进程组、控制终端等，虽然父进程退出了，但原先的会话期、进程组、控制终端等并没有改变，因此，那还不是真正意义上使两者独立开来。setsid 函数能够使子进程完全独立出来，从而脱离所有其他进程的控制。</p><p><strong>3)</strong> <strong>将工作目录更改为根目录</strong></p><p>​    子进程是继承了父进程的当前工作目录，由于在进程运行中，当前目录所在的文件系统是不能卸载的，这对以后使用会造成很多的麻烦。因此通常的做法是让“/”作为守护进程的当前目录，当然也可以指定其 它目录来作为守护进程的工作目录。</p><p><strong>4)</strong> <strong>重设文件权限掩码</strong> <strong>umask</strong></p><p>​    文件权限掩码 umask 用于对新建文件的权限位进行屏蔽，在 5.5.5 小节中有介绍。由于使用 fork 函数新建的子进程继承了父进程的文件权限掩码，这就给子进程使用文件带来了诸多的麻烦。因此，把文件权限掩 码设置为 0，确保子进程有最大操作权限、这样可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是 umask，通常的使用方法为 umask(0)。</p><ol start="5"><li><strong>关闭不再需要的文件描述符</strong></li></ol><p>​    子进程继承了父进程的所有文件描述符，这些被打开的文件可能永远不会被守护进程（此时守护进程指的就是子进程，父进程退出、子进程成为守护进程）读或写，但它们一样消耗系统资源，可能导致所在的文件系统无法卸载，所以必须关闭这些文件，这使得守护进程不再持有从其父进程继承过来的任何文件描述符。</p><p><strong>6)</strong> <strong>将文件描述符号为</strong> <strong>0**</strong>、**<strong>1**</strong>、**<strong>2</strong> <strong>定位到**</strong>/dev/null**</p><p>​    将守护进程的标准输入、标准输出以及标准错误重定向到/dev/null，这使得守护进程的输出无处显示、也无处从交互式用户那里接收输入。</p><p><strong>7)</strong> <strong>其它：忽略</strong> <strong>SIGCHLD</strong> <strong>信号</strong></p><p>​    处理 SIGCHLD 信号不是必须的，但对于某些进程，特别是并发服务器进程往往是特别重要的，服务器进程在接收到客户端请求时会创建子进程去处理该请求，如果子进程结束之后，父进程没有去 wait 回收子进程，则子进程将成为僵尸进程；如果父进程 wait 等待子进程退出，将又会增加父进程的负担、也就是增加服务器的负担，影响服务器进程的并发性能，在 Linux 下，可以将 SIGCHLD 信号的处理方式设置为SIG_IGN，也就是忽略该信号，可让内核将僵尸进程转交给 init 进程去处理，这样既不会产生僵尸进程、又省去了服务器进程回收子进程所占用的时间。</p><p>​    守护进程一般以单例模式运行</p><p>​    守护进程可以通过终端命令行启动，但通常它们是由系统初始化脚本进行启动，譬如/etc/rc*或 /etc/init.d/*等。</p><h2 id="SIGHUP-信号"><a href="#SIGHUP-信号" class="headerlink" title="SIGHUP 信号"></a><strong>SIGHUP</strong> <strong>信号</strong></h2><p>​    当用户准备退出会话时，系统向该会话发出 SIGHUP 信号，会话将 SIGHUP 信号发送给所有子进程，子进程接收到 SIGHUP 信号后，便会自动终止，当所有会话中的所有进程都退出时，会话也就终止了；因为程序当中一般不会对 SIGHUP 信号进行处理，所以对应的处理方式为系统默认方式，SIGHUP 信号的系统默认处理方式便是终止进程。</p><p>​    调用 signal()函数将 SIGHUP 信号的处理方式设置为忽略</p><p>​    当程序当中忽略 SIGHUP 信号之后，进程不会随着终端退出而退出，事实上，控制终端只是会话中的一个进程，只有会话中的所有进程退出后，会话才会结束；很显然当程序中忽略了 SIGHUP 信号，导致该进程不会终止，所以会话也依然会存在</p><h1 id="单例模式运行"><a href="#单例模式运行" class="headerlink" title="单例模式运行"></a><strong>单例模式运行</strong></h1><p>​    通常情况下，一个程序可以被多次执行，即程序在还没有结束的情况下，又再次执行该程序，也就是系统中同时存在多个该程序的实例化对象（进程），譬如大家所熟悉的聊天软件 QQ，我们可以在电脑上同时登陆多个 QQ 账号</p><p>​    但对于有些程序设计来说，不允许出现这种情况，程序只能被执行一次，只要该程序没有结束，就无法再次运行，我们把这种情况称为单例模式运行。譬如系统中守护进程，这些守护进程一般都是服务器进程，服务器程序只需要运行一次即可，能够在系统整个的运行过程中提供相应的服务支持，多次同时运行并没有意义、甚至还会带来错误！</p><p>​    如果希望我们的程序具有单例模式运行的功能，应该如何去实现呢？</p><h2 id="通过文件存在与否进行判断"><a href="#通过文件存在与否进行判断" class="headerlink" title="通过文件存在与否进行判断"></a><strong>通过文件存在与否进行判断</strong></h2><p>​    用一个文件的存在与否来做标志，在程序运行正式代码之前，先判断一个特定的文件是否存在，如果存在则表明进程已经运行，此时应该立马退出；如果不存在则表明进程没有运行，然后创建该文件，当程序结束时再删除该文件即可！</p><p>​    有很大的问题，主要包括如下三个方面：</p><ul><li>程序中使用_exit()退出，那么将无法执行 delete_file()函数，意味着无法删除这个特定的文件；</li><li>程序异常退出。程序异常同样无法执行到进程终止处理函数 delete_file()，同样将导致无法删除这个特定的文件；</li><li>计算机掉电关机。这种情况就更加直接了，计算机可能在程序运行到任意位置时发生掉电关机的情况，这是无法预料的；如果文件没有删除就发生了这种情况，计算机重启之后文件依然存在，导致程序无法执行。</li></ul><p>​    针对第一种情况，我们使用 exit()代替_exit()可以很好的解决这种问题；但是对于第二种情况来说，异常退出，譬如进程接收到信号导致异常终止，有一种解决办法便是设置信号处理方式为忽略信号，这样当进程接收到信号时就会被忽略，或者是针对某些信号注册信号处理函数，譬如 SIGTERM、SIGINT 等，在信号处理函数中删除文件然后再退出进程；但依然有个问题，并不是所有信号都可被忽略或捕获的，譬如SIGKILL 和 SIGSTOP，这两个信号是无法被忽略和捕获的，故而这种也不靠谱。针对第三种情况的解决办法便是，使得该特定文件会随着系统的重启而销毁，这个怎么做呢？其实这个非常简单，将文件放置到系统/tmp 目录下，/tmp 是一个临时文件系统，当系统重启之后/tmp 目录下的文件就会被销毁，所以该目录下的文件的生命周期便是系统运行周期。由此可知，虽然针对第一种情况和第三种情况都有相应的解决办法，但对于第二种情况来说，其解决办法并不靠谱，所以使用这种方法实现单例模式运行并不靠谱。</p><h2 id="使用文件锁"><a href="#使用文件锁" class="headerlink" title="使用文件锁"></a><strong>使用文件锁</strong></h2><p>​    是实现单例模式运行靠谱的方法</p><p>​    同样也需要通过一个特定的文件来实现，当程序启动之后，首先打开该文件，调用 open 时一般使用O_WRONLY | O_CREAT 标志，当文件不存在则创建该文件，然后尝试去获取文件锁，若是成功，则将程序的进程号（PID）写入到该文件中，写入后不要关闭文件或解锁（释放文件锁），保证进程一直持有该文件锁；若是程序获取锁失败，代表程序已经被运行、则退出本次启动。</p><p>​    Tips：当程序退出或文件关闭之后，文件锁会自动解锁！</p><p>​    通过系统调用flock()、fcntl()或库函数 lockf()均可实现对文件进行上锁，以系统调用flock()为例，系统调用 flock()产生的是咨询锁（建议性锁）、并不能产生强制性锁。</p><p>​    这种机制在一些程序尤其是服务器程序中很常见，服务器程序使用这种方法来保证程序的单例模式运行；在 Linux 系统中/var/run/目录下有很多以.pid 为后缀结尾的文件，这个实际上是为了保证程序以单例模式运行而设计的，作为程序实现单例模式运行所需的特定文件</p><p>​    这些以.pid 为后缀的文件，命名方式通常是程序名+.pid，譬如 acpid.pid 对应的程序便是 acpid、lightdm.pid对应的程序便是 lightdm 等等。如果我们要去实现一个以单例模式运行的程序，譬如一个守护进程，那么也应该将这个特定文件放置于 Linux 系统/var/run/目录下，并且文件的命名方式为 name.pid（name 表示进程名）。</p><p>​    <del>后面一些知识实在看得有点爆炸，这里知识点有点多，这里写一个注脚，后面遇到相关问题再回来在看一遍（逃）。。。</del></p><hr><p>参考资料：正点原子嵌入式 Linux C 应用编程指南第九章进程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;进程与程序&quot;&gt;&lt;a href=&quot;#进程与程序&quot; class=&quot;headerlink&quot; title=&quot;进程与程序&quot;&gt;&lt;/a&gt;&lt;strong&gt;进程与程序&lt;/strong&gt;&lt;/h</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note59.9-Qt控件-Button</title>
    <link href="https://www.chenzhan.club/2021/07/20/note59-9-Qt%E6%8E%A7%E4%BB%B6-Button/"/>
    <id>https://www.chenzhan.club/2021/07/20/note59-9-Qt%E6%8E%A7%E4%BB%B6-Button/</id>
    <published>2021-07-20T08:55:58.000Z</published>
    <updated>2021-07-23T07:55:27.190Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Qt 内置了六种按钮部件如下：</p><p>（1） QPushButton:下压按钮</p><p>（2） QToolButton:工具按钮</p><p>（3） QRadioButton:选择按钮</p><p>（4） QCheckBox:检查框</p><p>（5） QCommandLinkButton:命令链接按钮</p><p>（6） QDialogButtonBox:对话框按钮</p><p>这六种按钮部件作用简介如下：</p><p>QPushButton 继承 QAbstractButton 类，被 QCommandLinkButton 继承。通常用于执行命令或触发事件。</p><p>QToolButton 继承 QAbstractButton 类。是一种用于命令或者选项的可以快速访问的按钮，通常在 ToolBar 里面。工具按钮通常显示的是图标，而不是文本标签。ToolButton 支持自动浮起。在自动浮起模式中，按钮只有在鼠标指向它的时候才绘制三维的框架。</p><p>QRadioButton 继承 QAbstractButton 类。RadioButton 单选按钮（单选框）通常成组出现，用于提供两个或多个互斥选项。</p><p>QCheckBox 继承 QAbstractButton。复选按钮（复选框）与 RadioButton 的区别是选择模式，单选按钮提供多选一，复选按钮提供多选多。</p><p>QCommandLinkButton 控件中文名是“命令链接按钮”。QCommandLinkButton 继承 QPushButton。QCommandLinkButton 控件和 RadioButton 相似，都是用于在互斥选项中选择一项。表面上同平面按钮一样，但是 CommandLinkButton 除带有正常的按钮上的文字描述文本外，默认情况下，它也将携带一个箭头图标，表明按下按钮将打开另一个窗口或页面。</p><p>QDialogButtonBox 按 钮 盒 子 （ 按 钮 框 ）， 是 由 QDialogButtonBox 类 包 装 成 的 。</p><p>QDialogButtonBox 继承 QWidget。常用于对话框里自定义按钮，比如“确定”和“取消”按钮。</p><p>工具按钮（QToolButton）区别于普通按钮（QPushButton）的一点是，工具按钮（QToolButton）可以带图标。这里区别s下图标和按钮的背景图片是不一样的。通常我们在 QToolBar 这种工具条（工具栏）上设置不同的按钮，如果这些按钮还带图标和文本，那么 QToolButton 是个不错的选择。</p><p>QRadioButton 部件提供了一个带有文本标签的单选框（单选按钮）。QRadioButton 是一个可以切换选中（checked）或未选中（unchecked）状态的选项按钮。单选框通常呈现给用户一个“多选一”的选择。也就是说，在一组单选框中，一次只能选中一个单选框。默认在同一个父对象下，初始化后点击它们是互斥状态。</p><p>QSS 文件是使用 Qt 程序相关联的样式表文件。它由 GUI（图形用户界面）元素的外观和感觉，包括布局，颜色，鼠标的行为，大小和字体。它的风格，一个可以合并到一个 UI（用户界面）。与 HTML 的 CSS 类似，Qt 的样式表是纯文本的格式定义，在应用程序运行时可以载入和解析这些样式定义，从而使应用程序的界面呈现不同的效果。</p><p>QCheckBox 继承 QAbstractButton。复选按钮（复选框）与 RadioButton 的区别是选择模式，单选按钮提供多选一，复选按钮提供多选多。</p><p>QCommandLinkButton 控件中文名是“命令链接按钮”。QCommandLinkButton 继承QPushButton。CommandLinkButton 控件和 RadioButton 相似，都是用于在互斥选项中选择一项。表面上同平面按钮一样，但是 CommandLinkButton 除带有正常的<strong>按钮上的文字描述文本外，默认情况下，它也将携带一个箭头图标</strong>，表明按下按钮将打开另一个窗口或页面。</p><p>对话框和消息框通常以符合该平台界面指导原则的布局呈现按钮。不同平台的对话框总是有不同的布局。QDialogButtonBox 允许开发人员向其添加按钮，并将自动使用适合用户桌面环境的布局。也就是说我们可以使用系统的自带的对话框按钮，也可以自己定义对话框按钮。</p><p>QDialogButtonBox 常用的按钮有如下几种，更多的可以参考 Qt 帮助文档。</p><p>button_Box = new QDialogButtonBox(QDialogButtonBox::Ok</p><p> | QDialogButtonBox::Cancel</p><p> | QDialogButtonBox::Open</p><p> | QDialogButtonBox::Save</p><p> | QDialogButtonBox::Close</p><p> | QDialogButtonBox::Discard</p><p> | QDialogButtonBox::Apply</p><p> | QDialogButtonBox::Reset</p><p> | QDialogButtonBox::RestoreDefaults</p><p> | QDialogButtonBox::Help</p><p> | QDialogButtonBox::SaveAll);</p><hr><p>参考资料：正点原子嵌入式Qt开发指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;Qt 内置了六种按钮部件如下：&lt;/p&gt;
&lt;p&gt;（1） QPushButton:下压按钮&lt;/p&gt;
&lt;p&gt;（2） QToolButton:工具按钮&lt;/p&gt;
&lt;p&gt;（3） QRadioBu</summary>
      
    
    
    
    
    <category term="Qt" scheme="https://www.chenzhan.club/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>note58.9-Qt_Creator使用技巧</title>
    <link href="https://www.chenzhan.club/2021/07/20/note58-9-Qt-Creator%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://www.chenzhan.club/2021/07/20/note58-9-Qt-Creator%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2021-07-20T08:34:58.000Z</published>
    <updated>2021-07-22T06:04:52.511Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>运行快捷键：Ctrl + R</p><p>Ctrl + C 和 Ctrl + V 复制粘贴</p><p>常用快捷键：</p><p>一般快捷键：</p><table><thead><tr><th>新建文件或项目(N)</th><th>Ctrl + N</th></tr></thead><tbody><tr><td>关闭当前窗口/关闭当前文件</td><td>Ctrl + W</td></tr><tr><td>关闭所有文件</td><td>Ctrl + Shfit + W</td></tr><tr><td>关闭当前文件（windows）</td><td>Ctrl + F4</td></tr><tr><td>运行</td><td>Ctrl + R</td></tr><tr><td>返回上一级（返回），常用于跳转代码</td><td>Alt + ←（方向左键）</td></tr><tr><td>进入下一级（前进），常用于跳转代码</td><td>Alt + →（方向右键）</td></tr></tbody></table><p>常用编辑快捷键：</p><table><thead><tr><th>Qt 会自动排版对齐代码</th><th>Ctrl + I</th></tr></thead><tbody><tr><td>减小字体大小</td><td>Ctrl+- (Ctrl+鼠标滚轮向下)</td></tr><tr><td>增加字体大小</td><td>Ctrl++ (Ctrl+鼠标滚轮向上)</td></tr><tr><td>重置字体大小</td><td>Ctrl+0</td></tr><tr><td>折叠</td><td>Ctrl+&lt;</td></tr><tr><td>展开</td><td>Ctrl+&gt;</td></tr><tr><td>复制行</td><td>Ctrl+Ins</td></tr><tr><td>复制到行下</td><td>Ctrl+Alt+Down</td></tr><tr><td>复制到行上</td><td>Ctrl+Alt+Up</td></tr><tr><td>在当前行上方插入新行</td><td>Ctrl+Shift+Enter</td></tr><tr><td>在当前行下方插入新行</td><td>Ctrl+Enter</td></tr><tr><td>查看剪切板历史</td><td>Ctrl+Shift+V</td></tr><tr><td>剪切行</td><td>Shift+Del</td></tr><tr><td>追加行</td><td>Ctrl+J</td></tr><tr><td>向下移动当前行</td><td>Ctrl+Shift+Down</td></tr><tr><td>向上移动当前行</td><td>Ctrl+Shift+Up</td></tr><tr><td>切换函数声明/定义</td><td>Ctrl + 鼠标左键/Shift + F2</td></tr><tr><td>编辑信号和槽</td><td>F4</td></tr><tr><td>跳转至以}结尾的块</td><td>Ctrl+}</td></tr><tr><td>跳转至以{开始的块</td><td>Ctrl+{</td></tr><tr><td>打开类型层次窗口</td><td>Ctrl+Shift+T</td></tr></tbody></table><p> Qt Creator 里自定义快捷键或者修改原有的快捷键</p><p>在“环境”项下找到键盘，切换书签的快捷键，“Ctrl + M”显示红色，说明是与系统的快捷键冲突了按“Record”重新记录切换书签的快捷键。再点击“Apply”和“OK”即可。</p><p>安装 Qt 时，帮助文档已经安装在我们的“安装目录/Qt5.12.9/Docs/”下，使用的是 html 文本的方式，我们可以使用浏览器打开这种 html 文本。</p><hr><p>参考资料：正点原子嵌入式 Qt 开发指南</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;运行快捷键：Ctrl + R&lt;/p&gt;
&lt;p&gt;Ctrl + C 和 Ctrl + V 复制粘贴&lt;/p&gt;
&lt;p&gt;常用快捷键：&lt;/p&gt;
&lt;p&gt;一般快捷键：&lt;/p&gt;
&lt;table&gt;
&lt;the</summary>
      
    
    
    
    
    <category term="Qt" scheme="https://www.chenzhan.club/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>note57.6-信号:基础</title>
    <link href="https://www.chenzhan.club/2021/07/19/note57-6-%E4%BF%A1%E5%8F%B7-%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.chenzhan.club/2021/07/19/note57-6-%E4%BF%A1%E5%8F%B7-%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-19T08:46:22.000Z</published>
    <updated>2021-07-20T03:20:24.927Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在很多应用程序当中，都会存在处理异步事件这种需求，而信号提供了一种处理异步事件的方法</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h1><p>信号是事件发生时对进程的通知机制，也可以把它称为软件中断。信号与硬件中断的相似之处在于能够打断程序当前执行的正常流程，其实是在软件层次上对中断机制的一种模拟。大多数情况下，是无法预测信号达到的准确时间，所以，信号提供了一种处理异步事件的方法。</p><p><strong>信号的目的是用来通信的</strong></p><p>一个具有合适权限的进程能够向另一个进程发送信号，信号的这一用法可作为一种同步技术，甚至是进程间通信（IPC）的原始形式。</p><ul><li>硬件发生异常，即硬件检测到错误条件并通知内核，随即再由内核发送相应的信号给相关进程。硬件检测到异常的例子包括执行一条异常的机器语言指令，诸如，除数为 0、数组访问越界导致引用了无法访问的内存区域等，这些异常情况都会被硬件检测到，并通知内核、然后内核为该异常情况发生时正在运行的进程发送适当的信号以通知进程。</li><li>用于在终端下输入了能够产生信号的特殊字符。譬如在终端上按下 CTRL + C 组合按键可以产生中断信号（SIGINT），通过这个方法可以终止在前台运行的进程；按下 CTRL + Z 组合按键可以产生暂停信号（SIGCONT），通过这个方法可以暂停当前前台运行的进程。</li><li>进程调用 kill()系统调用可将任意信号发送给另一个进程或进程组。当然对此是有所限制的，接收信号的进程和发送信号的进程的所有者必须相同，亦或者发送信号的进程的所有者是 root 超级用户。</li><li>用户可以通过 kill 命令将信号发送给其它进程。kill 命令想必大家都会使用，通常我们会通过 kill命令来“杀死”（终止）一个进程，譬如在终端下执行”kill -9 xxx”来杀死 PID 为 xxx 的进程。kill命令其内部的实现原理便是通过 kill()系统调用来完成的。 </li><li>发生了软件事件，即当检测到某种软件条件已经发生。这里指的不是硬件产生的条件（如除数为 0、引用无法访问的内存区域等），而是软件的触发条件、触发了某种软件条件（进程所设置的定时器已经超时、进程执行的 CPU 时间超限、进程的某个子进程退出等等情况）。</li></ul><p>进程同样也可以向自身发送信号，然而发送给进程的诸多信号中，大多数都是来自于内核。</p><p>以上便是可以产生信号的多种不同的条件，总的来看，信号的目的都是用于通信的，当发生某种情况下，通过信号将情况“告知”相应的进程，从而达到同步、通信的目的。</p><p><strong>信号由谁处理、怎么处理</strong></p><p>信号通常是发送给对应的进程，当信号到达后，该进程需要做出相应的处理措施，通常进程会视具体信号执行以下操作之一：</p><ul><li>忽略信号。也就是说，当信号到达进程后，该进程并不会去理会它、直接忽略，就好像是没有出该信号，信号对该进程不会产生任何影响。事实上，大多数信号都可以使用这种方式进行处理，但有两种信号却决不能被忽略，它们是 SIGKILL 和 SIGSTOP，这两种信号不能被忽略的原因是：它们向内核和超级用户提供了使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号，则进程的运行行为是未定义的。</li><li>捕获信号。当信号到达进程后，执行预先绑定好的信号处理函数。为了做到这一点，要通知内核在某种信号发生时，执行用户自定义的处理函数，该处理函数中将会对该信号事件作出相应的处理，Linux 系统提供了 signal()系统调用可用于注册信号的处理函数。</li><li>执行系统默认操作。进程不对该信号事件作出处理，而是交由系统进行处理，每一种信号都会有其对应的系统默认的处理方式。需要注意的是，对大多数信号来说，系统默认的处理方式就是终止该进程。</li></ul><p><strong>信号是异步的</strong></p><p>信号是异步事件的经典实例，产生信号的事件对进程而言是随机出现的，进程无法预测该事件产生的准确时间，进程不能够通过简单地测试一个变量或使用系统调用来判断是否产生了一个信号，这就如同硬件中断事件，程序是无法得知中断事件产生的具体时间，只有当产生中断事件时，才会告知程序、然后打断当前程序的正常执行流程、跳转去执行中断服务函数，这就是异步处理方式。</p><p><strong>信号本质上是</strong> <strong>int</strong> <strong>类型数字编号</strong></p><p>信号本质上是 int 类型的数字编号，这就好比硬件中断所对应的中断号。内核针对每个信号，都给其定义了一个唯一的整数编号，从数字 1 开始顺序展开。并且每一个信号都有其对应的名字（其实就是一个宏），信号名字与信号编号乃是一一对应关系，但是由于每个信号的实际编号随着系统的不同可能会不一样，所以在程序当中一般都使用信号的符号名（也就是宏定义）。</p><p>这些信号在&lt;signum.h&gt;头文件中定义，每个信号都是以 SIGxxx 开头，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Signals. *&#x2F;</span><br><span class="line">#define SIGHUP 1 &#x2F;* Hangup (POSIX). *&#x2F;</span><br><span class="line">#define SIGINT 2 &#x2F;* Interrupt (ANSI). *&#x2F;</span><br><span class="line">#define SIGQUIT 3 &#x2F;* Quit (POSIX). *&#x2F;</span><br><span class="line">#define SIGILL 4 &#x2F;* Illegal instruction (ANSI). *&#x2F;</span><br><span class="line">#define SIGTRAP 5 &#x2F;* Trace trap (POSIX). *&#x2F;</span><br><span class="line">#define SIGABRT 6 &#x2F;* Abort (ANSI). *&#x2F;</span><br><span class="line">#define SIGIOT 6 &#x2F;* IOT trap (4.2 BSD). *&#x2F;</span><br><span class="line">#define SIGBUS 7 &#x2F;* BUS error (4.2 BSD). *&#x2F;</span><br><span class="line">#define SIGFPE 8 &#x2F;* Floating-point exception (ANSI). *&#x2F;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>不存在编号为 0 的信号，信号编号是从 1 开始的，事实上 kill()函数对信号编号 0 有着特殊的应用。</p><h1 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a><strong>信号的分类</strong></h1><p>从可靠性方面将信号分为可靠信号与不可靠信号；而从实时性方面将信号分为实时信号与非实时信号</p><p>Linux 支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用signal()。因此，Linux 下的不可靠信号问题主要指的是信号可能丢失。在 Linux 系统下，信号值小于 SIGRTMIN（34）的信号都是不可靠信号，这就是”不可靠信号”的来源</p><p>(SIGRTMIN~SIGRTMAX)，并在一开始就把它们定义为可靠信号，在 Linux 系统下使用**”kill -l”命令可查看到所有信号**</p><p>Tips：括号” ) “前面的数字对应该信号的编号，编号 1<del>31 所对应的是不可靠信号，编号 34</del>64 对应的是可靠信号，从图中可知，可靠信号并没有一个具体对应的名字，而是使用了 SIGRTMIN+N 或 SIGRTMAX- N 的方式来表示。</p><p>可靠信号支持排队，不会丢失，同时，信号的发送和绑定也出现了新版本，信号发送函数 sigqueue()及信号绑定函数 sigaction()。</p><p>如按键盘的 CTRL+C时，会产生 SIGINT 信号，对该信号的系统默认操作就是终止进程</p><p>实时信号与非实时信号其实是从时间关系上进行的分类，与可靠信号与不可靠信号是相互对应的，非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。实时信号保证了发送的多个信号都能被接收，实时信号是 POSIX 标准的一部分，可用于应用进程。</p><p>一般我们也把非实时信号（不可靠信号）称为标准信号</p><h1 id="常见信号与默认行为"><a href="#常见信号与默认行为" class="headerlink" title="常见信号与默认行为"></a><strong>常见信号与默认行为</strong></h1><p><strong>SIGINT</strong></p><p>当用户在终端按下中断字符（通常是 CTRL + C）时，内核将发送 SIGINT 信号给前台进程组中的每一个进程。该信号的系统默认操作是终止进程的运行。所以通常我们都会使用 CTRL + C 来终止一个占用前台的进程，原因在于大部分的进程会将该信号交给系统去处理，从而执行该信号的系统默认操作。</p><p><strong>SIGQUIT</strong></p><p>当用户在终端按下退出字符（通常是 CTRL + \）时，内核将发送 SIGQUIT 信号给前台进程组中的每一个进程。该信号的系统默认操作是终止进程的运行、并生成可用于调试的核心转储文件。进程如果陷入无限循环、或不再响应时，使用 SIGQUIT 信号就很合适。所以对于一个前台进程，既可以在终端按下中断字符CTRL + C、也可以按下退出字符 CTRL + \来终止，当然前提条件是，此进程会将 SIGINT 信号或 SIGQUIT信号交给系统处理（也就是没有将信号忽略或捕获），进入执行该信号所对应的系统默认操作。 </p><p><strong>SIGILL</strong></p><p>如果进程试图执行非法（即格式不正确）的机器语言指令，系统将向进程发送该信号。该信号的系统默认操作是终止进程的运行。</p><p><strong>SIGABRT</strong></p><p>当进程调用 abort()系统调用时（进程异常终止），系统会向该进程发送 SIGABRT 信号。该信号的系统默认操作是终止进程、并生成核心转储文件。</p><p>。。。。。。</p><table><thead><tr><th>信号名称</th><th>编号</th><th>描述</th><th>系统默认操作</th></tr></thead><tbody><tr><td>SIGINT</td><td>2</td><td>终端中断符</td><td>term</td></tr><tr><td>SIGQUIT</td><td>3</td><td>终端退出符</td><td>term+core</td></tr><tr><td>。。。</td><td>。。。</td><td>。。。</td><td>。。。</td></tr></tbody></table><p><del>参考资料：正点原子表8.3.1</del></p><p>Tips：上表中，term 表示终止进程；core 表示生成核心转储文件，核心转储文件可用于调试，这个便不再给介绍了；ignore 表示忽略信号；cont 表示继续运行进程；stop 表示停止进程（注意停止不等于终止，而是暂停）。</p><h1 id="进程对信号的处理"><a href="#进程对信号的处理" class="headerlink" title="进程对信号的处理"></a><strong>进程对信号的处理</strong></h1><p>当进程接收到内核或用户发送过来的信号之后，根据具体信号可以采取不同的处理方式：忽略信号、捕获信号或者执行系统默认操作。Linux 系统提供了系统调用 signal()和 sigaction()两个函数用于设置信号的处 理方式</p><p><strong>signal()函数</strong></p><p>signal()函数是 Linux 系统下设置信号处理方式最简单的接口，可将信号的处理方式设置为捕获信号、忽略信号以及系统默认操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">typedef void (*sig_t)(int);</span><br><span class="line">sig_t signal(int signum, sig_t handler);</span><br></pre></td></tr></table></figure><p>需要包含头文件&lt;signal.h&gt;</p><p><strong>signum：</strong>此参数指定需要进行设置的信号，可使用信号名（宏）或信号的数字编号，建议使用信号名。</p><p><strong>handler：</strong>sig_t 类型的函数指针，指向信号对应的信号处理函数，当进程接收到信号后会自动执行该处理函数；参数 handler 既可以设置为用户自定义的函数，也就是捕获信号时需要执行的处理函数，也可以设置为 SIG_IGN 或 SIG_DFL，SIG_IGN 表示此进程需要忽略该信号，SIG_DFL 则表示设置为系统默认操作。sig_t 函数指针的 int 类型参数指的是，当前触发该函数的信号，可将多个信号绑定到同一个信号处理函数上，此时就可通过此参数来判断当前触发的是哪个信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tips：SIG_IGN、SIG_DFL 分别取值如下：</span><br><span class="line">&#x2F;* Fake signal functions. *&#x2F;</span><br><span class="line">#define SIG_ERR ((sig_t) -1) &#x2F;* Error return. *&#x2F;</span><br><span class="line">#define SIG_DFL ((sig_t) 0) &#x2F;* Default action. *&#x2F;</span><br><span class="line">#define SIG_IGN ((sig_t) 1) &#x2F;* Ignore signal. *&#x2F;</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong>此函数的返回值也是一个 sig_t 类型的函数指针，成功情况下的返回值则是指向在此之前的信号处理函数；如果出错则返回 SIG_ERR，并会设置 errno。</p><p>由此可知，signal()函数可以根据第二个参数 handler 的不同设置情况，可对信号进行不同的处理。</p><p>使用 ps 命令找到该进程的 pid 号，再使用 kill 命令</p><p>Tips：普通用户只能杀死该用户自己的进程，无权限杀死其它用户的进程。</p><p>按下中断符时系统并不会给后台进程发送 SIGINT 信号。可以使用 kill 命令手动发送信号给我们的进程：</p><p><strong>两种不同状态下信号的处理方式</strong></p><p><strong>程序启动</strong></p><p>当一个应用程序刚启动的时候（或者程序中没有调用 signal()函数），通常情况下，进程对所有信号的处理方式都设置为系统默认操作。所以如果在我们的程序当中，没有调用 signal()为信号设置处理方式，则默认的处理方式便是系统默认操作。</p><p><strong>进程创建</strong></p><p>当一个进程调用 fork()创建子进程时，其子进程将会继承父进程的信号处理方式，因为子进程在开始时复制了父进程的内存映像，所以信号捕获函数的地址在子进程中是有意义的。</p><p><strong>sigaction()函数</strong></p><p>允许单独获取信号的处理函数而不是设置，并且还可以设置各种属性对调用信号处理函数时的行为施以更加精准的控制，其函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* struct sigaction 结构体 *&#x2F;</span><br><span class="line"></span><br><span class="line">struct sigaction &#123;</span><br><span class="line"> void (*sa_handler)(int);</span><br><span class="line"> void (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line"> sigset_t sa_mask;</span><br><span class="line"> int sa_flags;</span><br><span class="line"> void (*sa_restorer)(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* siginfo_t 结构体 *&#x2F;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>一般而言，将信号处理函数设计越简单越好，这就好比中断处理函数，越快越好，不要在处理函数中做大量消耗 CPU 时间的事情，这一个重要的原因在于，设计的越简单这将降低引发信号竞争条件的风险。</p><h1 id="向进程发送信号"><a href="#向进程发送信号" class="headerlink" title="向进程发送信号"></a><strong>向进程发送信号</strong></h1><p>一个进程可通过 kill()向另一个进程发送信号；除了 kill()系统调用之外，Linux 系统还提供了系统调用 killpg()以及库函数 raise()，也可用于实现发送信号的功能</p><p>kill()系统调用可将信号发送给指定的进程或进程组中的每一个进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int kill(pid_t pid, int sig);</span><br></pre></td></tr></table></figure><p>参数 pid 不同取值含义：</p><ul><li>如果 pid 为正，则信号 sig 将发送到 pid 指定的进程。 </li><li>如果 pid 等于 0，则将 sig 发送到当前进程的进程组中的每个进程。</li><li>如果 pid 等于-1，则将 sig 发送到当前进程有权发送信号的每个进程，但进程 1（init）除外。</li><li>如果 pid 小于-1，则将 sig 发送到 ID 为-pid 的进程组中的每个进程。</li></ul><p>有时进程需要向自身发送信号，raise()函数可用于实现这一要求</p><p>使用 alarm()函数可以设置一个定时器（闹钟），当定时器定时时间到时，内核会向进程发送SIGALRM信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br></pre></td></tr></table></figure><p>seconds：设置定时时间，以秒为单位；如果参数 seconds 等于 0，则表示取消之前设置的 alarm 闹钟</p><p>pause()系统调用可以使得进程暂停运行、进入休眠状态，直到进程捕获到一个信号为止，只有执行了信号处理函数并从其返回时，pause()才返回，在这种情况下，pause()返回-1，并且将 errno 设置为 EINTR</p><h1 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a><strong>信号集</strong></h1><p>通常我们需要有一个能表示多个信号（一组信号）的数据类型—信号集（signalset），很多系统调用都使用到了信号集这种数据类型来作为参数传递，譬如 sigaction()函数、sigprocmask()函数、sigpending()函数等</p><p>信号集其实就是 sigset_t 类型数据结构</p><p>使用这个结构体可以表示一组信号，将多个信号添加到该数据结构中，当然 Linux 系统了用于操作sigset_t 信号集的 API，譬如 sigemptyset()、sigfillset()、sigaddset()、sigdelset()、sigismember()</p><p><strong>初始化信号集</strong></p><p>sigemptyset()初始化信号集，使其不包含任何信号；而sigfillset()函数初始化信号集，使其包含所有信号（包括所有实时信号）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化为空信号集：</span><br><span class="line">sigset_t sig_set;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line">初始化信号集，使其包含所有信号：</span><br><span class="line">sigset_t sig_set;</span><br><span class="line">sigfillset(&amp;sig_set);</span><br></pre></td></tr></table></figure><p><strong>向信号集中添加/删除信号</strong></p><p>使用 sigaddset()和 sigdelset()函数向信号集中添加或移除一个信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sigset_t sig_set;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line">sigaddset(&amp;sig_set, SIGINT);</span><br><span class="line">从信号集中移除信号：</span><br><span class="line">sigset_t sig_set;</span><br><span class="line">sigfillset(&amp;sig_set);</span><br><span class="line">sigdelset(&amp;sig_set, SIGINT);</span><br></pre></td></tr></table></figure><p><strong>测试信号是否在信号集中</strong></p><p>使用 sigismember()函数可以测试某一个信号是否在指定的信号集中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">判断 SIGINT 信号是否在 sig_set 信号集中：</span><br><span class="line">sigset_t sig_set;</span><br><span class="line">......</span><br><span class="line">if (1 &#x3D;&#x3D; sigismember(&amp;sig_set, SIGINT))</span><br><span class="line">puts(&quot;信号集中包含 SIGINT 信号&quot;);</span><br><span class="line">else if (!sigismember(&amp;sig_set, SIGINT))</span><br><span class="line">puts(&quot;信号集中不包含 SIGINT 信号&quot;);</span><br></pre></td></tr></table></figure><p><strong>获取信号的描述信息</strong></p><p>每个信号都有一串与之相对应的字符串描述信息，用于对该信号进行相应的描述。这些字符串位于 sys_siglist 数组中，sys_siglist 数组是一个 char *类型的数组，数组中的每一个元素存放的是一个字符串指针，指向一个信号描述信息</p><p>Tips：使用 sys_siglist 数组需要包含&lt;signal.h&gt;头文件。</p><p>也可以使用 strsignal()函数获取描述信息</p><p>psignal()可以在标准错误（stderr）上输出信号描述信息</p><h1 id="信号掩码-阻塞信号传递"><a href="#信号掩码-阻塞信号传递" class="headerlink" title="信号掩码(阻塞信号传递)"></a><strong>信号掩码(阻塞信号传递)</strong></h1><p>内核为每一个进程维护了一个信号掩码（其实就是一个信号集），即一组信号。当进程接收到一个属于信号掩码中定义的信号时，该信号将会被阻塞、无法传递给进程进行处理，那么内核会将其阻塞，直到该信号从信号掩码中移除，内核才会把该信号传递给进程从而得到处理。</p><p>向信号掩码中添加一个信号，通常有如下几种方式：</p><ul><li>当应用程序调用 signal()或 sigaction()函数为某一个信号设置处理方式时，进程会自动将该信号添加到信号掩码中，这样保证了在处理一个给定的信号时，如果此信号再次发生，那么它将会被阻塞；当然对于 sigaction()而言，是否会如此，需要根据 sigaction()函数是否设置了 SA_NODEFER 标志而定；当信号处理函数结束返回后，会自动将该信号从信号掩码中移除。</li><li>使用 sigaction()函数为信号设置处理方式时，可以额外指定一组信号，当调用信号处理函数时将该组信号自动添加到信号掩码中，当信号处理函数结束返回后，再将这组信号从信号掩码中移除；通 过 sa_mask 参数进行设置，参考 8.4.2 小节内容。</li><li>除了以上两种方式之外，还可以使用 sigprocmask()系统调用，随时可以显式地向信号掩码中添加/移除信号。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">将信号 SIGINT 添加到进程的信号掩码中：</span><br><span class="line">int ret;</span><br><span class="line">&#x2F;* 定义信号集 *&#x2F;</span><br><span class="line">sigset_t sig_set;</span><br><span class="line">&#x2F;* 将信号集初始化为空 *&#x2F;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line">&#x2F;* 向信号集中添加 SIGINT 信号 *&#x2F;</span><br><span class="line">sigaddset(&amp;sig_set, SIGINT);</span><br><span class="line">&#x2F;* 向进程的信号掩码中添加信号 *&#x2F;</span><br><span class="line">ret &#x3D; sigprocmask(SIG_BLOCK, &amp;sig_set, NULL);</span><br><span class="line">if (-1 &#x3D;&#x3D; ret) &#123;</span><br><span class="line">perror(&quot;sigprocmask error&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">从信号掩码中移除 SIGINT 信号：</span><br><span class="line">int ret;</span><br><span class="line">&#x2F;* 定义信号集 *&#x2F;</span><br><span class="line">sigset_t sig_set;</span><br><span class="line">&#x2F;* 将信号集初始化为空 *&#x2F;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line">&#x2F;* 向信号集中添加 SIGINT 信号 *&#x2F;</span><br><span class="line">sigaddset(&amp;sig_set, SIGINT);</span><br><span class="line">&#x2F;* 从信号掩码中移除信号 *&#x2F;</span><br><span class="line">ret &#x3D; sigprocmask(SIG_UNBLOCK, &amp;sig_set, NULL);</span><br><span class="line">if (-1 &#x3D;&#x3D; ret) &#123;</span><br><span class="line">perror(&quot;sigprocmask error&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="阻塞等待信号-sigsuspend"><a href="#阻塞等待信号-sigsuspend" class="headerlink" title="阻塞等待信号 sigsuspend()"></a><strong>阻塞等待信号</strong> sigsuspend()</h1><p> 更改进程的信号掩码可以阻塞所选择的信号，或解除对它们的阻塞。使用这种技术可以保护不希望由信号中断的关键代码段。如果希望对一个信号解除阻塞后，然后调用 pause()以等待之前被阻塞的信号的传递</p><p>需要将恢复信号掩码和 pause()挂起进程这两个动作封装成一个原子操作，这正是 sigsuspend()系统调用</p><p>sigsuspend()函数会将参数 mask 所指向的信号集来替换进程的信号掩码，也就是将进程的信号掩码设置为参数 mask 所指向的信号集，然后挂起进程，直到捕获到信号被唤醒（如果捕获的信号是 mask 信号集中的成员，将不会唤醒、继续挂起）、并从信号处理函数返回，一旦从信号处理函数返回，sigsuspend()会将进程的信号掩码恢复成调用前的值。</p><h1 id="实时信号"><a href="#实时信号" class="headerlink" title="实时信号"></a><strong>实时信号</strong></h1><p>如果进程当前正在执行信号处理函数，在处理信号期间接收到了新的信号，如果该信号是信号掩码中的成员，那么内核会将其阻塞，将该信号添加到进程的等待信号集（等待被处理，处于等待状态的信号）中，为了确定进程中处于等待状态的是哪些信号，可以使用 sigpending()函数获取。</p><p><strong>sigpending()函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">判断 SIGINT 信号当前是否处于等待状态</span><br><span class="line">&#x2F;* 定义信号集 *&#x2F;</span><br><span class="line">sigset_t sig_set;</span><br><span class="line">&#x2F;* 将信号集初始化为空 *&#x2F;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line">&#x2F;* 获取当前处于等待状态的信号 *&#x2F;</span><br><span class="line">sigpending(&amp;sig_set);</span><br><span class="line">&#x2F;* 判断 SIGINT 信号是否处于等待状态 *&#x2F;</span><br><span class="line">if (1 &#x3D;&#x3D; sigismember(&amp;sig_set, SIGINT))</span><br><span class="line">puts(&quot;SIGINT 信号处于等待状态&quot;);</span><br><span class="line">else if (!sigismember(&amp;sig_set, SIGINT))</span><br><span class="line">puts(&quot;SIGINT 信号未处于等待状态&quot;);</span><br></pre></td></tr></table></figure><p><strong>发送实时信号</strong></p><p>实时信号较之于标准信号，其优势如下：</p><ul><li>实时信号的信号范围有所扩大，可应用于应用程序自定义的目的，而标准信号仅提供了两个信号可用于应用程序自定义使用：SIGUSR1 和 SIGUSR2。 </li><li>内核对于实时信号所采取的是队列化管理。如果将某一实时信号多次发送给另一个进程，那么将会多次传递此信号。相反，对于某一标准信号正在等待某一进程，而此时即使再次向该进程发送此信号，信号也只会传递一次。</li><li>当发送一个实时信号时，可为信号指定伴随数据（一整形数据或者指针值），供接收信号的进程在它的信号处理函数中获取。</li><li>不同实时信号的传递顺序得到保障。如果有多个不同的实时信号处于等待状态，那么将率先传递具有最小编号的信号。换言之，信号的编号越小，其优先级越高，如果是同一类型的多个信号在排队，那么信号（以及伴随数据）的传递顺序与信号发送来时的顺序保持一致。</li></ul><p>Linux 内核定义了 31 个不同的实时信号，信号编号范围为 34~64，使用 SIGRTMIN 表示编号最小的实时信号，使用 SIGRTMAX 表示编号最大的实时信号，其它信号编号可使用这两个宏加上一个整数或减去一个整数。</p><p>应用程序当中使用实时信号，需要有以下的两点要求：</p><ul><li>发送进程使用 sigqueue()系统调用向另一个进程发送实时信号以及伴随数据。</li><li>接收实时信号的进程要为该信号建立一个信号处理函数，使用sigaction函数为信号建立处理函数，并加入 SA_SIGINFO，这样信号处理函数才能够接收到实时信号以及伴随数据，也就是要使用sa_sigaction 指针指向的处理函数，而不是 sa_handler，当然允许应用程序使用 sa_handler，但这样就不能获取到实时信号的伴随数据了。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">(1)发送进程使用 sigqueue()系统调用向另一个进程发送实时信号</span><br><span class="line">示例代码 8.11.1 使用 sigqueue()函数发送信号</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> union sigval sig_val;</span><br><span class="line"> int pid;</span><br><span class="line"> int sig;</span><br><span class="line"> &#x2F;* 判断传参个数 *&#x2F;</span><br><span class="line"> if (3 &gt; argc)</span><br><span class="line"> exit(-1);</span><br><span class="line"> &#x2F;* 获取用户传递的参数 *&#x2F;</span><br><span class="line"> pid &#x3D; atoi(argv[1]);</span><br><span class="line"> sig &#x3D; atoi(argv[2]);</span><br><span class="line"> printf(&quot;pid: %d\nsignal: %d\n&quot;, pid, sig);</span><br><span class="line"> &#x2F;* 发送信号 *&#x2F;</span><br><span class="line"> sig_val.sival_int &#x3D; 10; &#x2F;&#x2F;伴随数据</span><br><span class="line"> if (-1 &#x3D;&#x3D; sigqueue(pid, sig, sig_val)) &#123;</span><br><span class="line"> perror(&quot;sigqueue error&quot;);</span><br><span class="line"> exit(-1);</span><br><span class="line"> &#125;</span><br><span class="line"> puts(&quot;信号发送成功!&quot;);</span><br><span class="line"> exit(0);</span><br><span class="line">&#125; (2)接收进程使用 sigaction()函数为信号绑定处理函数</span><br><span class="line">示例代码 8.11.2 使用 sigaction()函数为实时信号绑定处理函数</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">static void sig_handler(int sig, siginfo_t *info, void *context) &#123;</span><br><span class="line"> sigval_t sig_val &#x3D; info-&gt;si_value;</span><br><span class="line"> printf(&quot;接收到实时信号: %d\n&quot;, sig);</span><br><span class="line"> printf(&quot;伴随数据为: %d\n&quot;, sig_val.sival_int);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> struct sigaction sig &#x3D; &#123;0&#125;;</span><br><span class="line"> int num;</span><br><span class="line"> &#x2F;* 判断传参个数 *&#x2F;</span><br><span class="line"> if (2 &gt; argc)</span><br><span class="line"> exit(-1);</span><br><span class="line"> &#x2F;* 获取用户传递的参数 *&#x2F;</span><br><span class="line"> num &#x3D; atoi(argv[1]);</span><br><span class="line"> &#x2F;* 为实时信号绑定处理函数 *&#x2F;</span><br><span class="line"> sig.sa_sigaction &#x3D; sig_handler;</span><br><span class="line"> sig.sa_flags &#x3D; SA_SIGINFO;</span><br><span class="line"> if (-1 &#x3D;&#x3D; sigaction(num, &amp;sig, NULL)) &#123;</span><br><span class="line"> perror(&quot;sigaction error&quot;);</span><br><span class="line"> exit(-1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;* 死循环 *&#x2F;</span><br><span class="line"> for ( ; ; )</span><br><span class="line"> sleep(1);</span><br><span class="line"> exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常退出abort-函数"><a href="#异常退出abort-函数" class="headerlink" title="异常退出abort()函数"></a><strong>异常退出abort()函数</strong></h1><p>对于异常退出程序，则一般使用 abort()库函数，使用 abort()终止进程运行，会生成核心转储文件，可用于判断程序调用 abort()时的程序状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void abort(void);</span><br></pre></td></tr></table></figure><p>函数 abort()通常产生 SIGABRT 信号来终止调用该函数的进程，SIGABRT 信号的系统默认操作是终止进程运行、并生成核心转储文件；当调用 abort()函数之后，内核会向进程发送 SIGABRT 信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">static void sig_handler(int sig) &#123;</span><br><span class="line"> printf(&quot;接收到信号: %d\n&quot;, sig);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> struct sigaction sig &#x3D; &#123;0&#125;;</span><br><span class="line"> sig.sa_handler &#x3D; sig_handler;</span><br><span class="line"> sig.sa_flags &#x3D; 0;</span><br><span class="line"> if (-1 &#x3D;&#x3D; sigaction(SIGABRT, &amp;sig, NULL)) &#123;</span><br><span class="line"> perror(&quot;sigaction error&quot;);</span><br><span class="line"> exit(-1);</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(2);</span><br><span class="line"> abort(); &#x2F;&#x2F; 调用 abort</span><br><span class="line"> for ( ; ; )</span><br><span class="line"> sleep(1);</span><br><span class="line"> exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：正点原子嵌入式Linux C应用编程指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;在很多应用程序当中，都会存在处理异步事件这种需求，而信号提供了一种处理异步事件的方法&lt;/p&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note56.9-Qt_Qt信号与槽</title>
    <link href="https://www.chenzhan.club/2021/07/19/note56-9-Qt-Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"/>
    <id>https://www.chenzhan.club/2021/07/19/note56-9-Qt-Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/</id>
    <published>2021-07-19T06:10:04.000Z</published>
    <updated>2021-07-19T08:11:37.040Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>Qt</strong> <strong>信号与槽机制</strong></p><p>​    信号与槽（Signal &amp; Slot）是 Qt 编程的基础，也是 Qt 的一大创新。因为有了信号与槽的编程机制，在 Qt 中处理界面各个组件的交互操作时变得更加直观和简单。</p><p>​    信号（Signal）就是在特定情况下被发射的事件，例如 PushButton (按键)最常见的信号就是鼠标单击时发射的 clicked() 信号，一个 ComboBox (组合框)最常见的信号是选择的列表项变化时发CurrentIndexChanged() (更改索引)信号。</p><p>​    槽（Slot）就是对信号响应的函数。槽就是一个函数，与一般的 C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。</p><p>​    信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</span><br></pre></td></tr></table></figure><p>​    connect() 是 QObject 类的一个静态函数，而 <strong>QObject 是所有 Qt 类的基类</strong>，在实际调用时可以忽略前面的限定符，所以可以直接写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</span><br></pre></td></tr></table></figure><p>​    sender 是发射信号的对象的名称，signal() 是信号名称。信号可以看做是特殊的函数，需要带括号，有参数时还需要指明参数。receiver 是接收信号的对象名称，slot() 是槽函数的名称，需要带括号，有参数时还需要指明参数。</p><p>​    SIGNAL 和 SLOT 是 Qt 的宏，用于指明信号和槽，并将它们的参数转换为相应的字符串。</p><p>​    在  ui_mainwindow.h 这个文件里的setupUi() 函数中有如下的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(pushButton, SIGNAL(clicked()), MainWindow, SLOT(close()));</span><br></pre></td></tr></table></figure><p>​    其作用就是将 pushButton 按钮的 clicked() 信号与窗体（MainWindow）的槽函数 close() 相关联，这样，当单击 pushButton 按钮（就是界面上的“X”按钮）时，就会执行 MainWindow的 close() 槽函数。</p><p><strong>关于信号与槽的使用，有以下一些规则需要注意：</strong></p><p><strong>一个信号可以连接多个槽</strong>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect(pushButton, SIGNAL(clicked()), this, SLOT(hide());</span><br><span class="line">connect(pushButton, SIGNAL(clicked()), this, SLOT(close());</span><br></pre></td></tr></table></figure><p>​    这是当一个对象 pushButton 的被单击时，所在窗体有两个槽进行响应，一个 hide()用于隐藏主窗体，一个 close 用于关闭主窗体。这里只是举个例子，实际上当执行 close()后，hide()这个槽已经没有什么意义了，因为已经程序退出了，但是实际它有执行，因为它连接在 close()的前面。当一个信号与多个槽函数关联时，槽函数按照建立连接时的顺序依次执行。</p><p>​    当信号和槽函数带有参数时，在 connect()函数里，要写明参数的类型，但可以不写参数名称。</p><p><strong>多个信号可以连接同一个槽</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connect(pushButton,SIGNAL(clicked()),this,SLOT(close()));</span><br><span class="line">connect(pushButton_2,SIGNAL(clicked()),this,SLOT(close()));</span><br><span class="line">connect(pushButton_3,SIGNAL(clicked()),this,SLOT(close()));</span><br></pre></td></tr></table></figure><p>​    这样，当任何一个 pushButton 被单击时，都会执行 close()函数，进而关闭或者退出程序。</p><p><strong>一个信号可以连接另外一个信号</strong>（说明了 connect 万物皆可连）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(pushButton,SIGNAL(objectNameChanged(QString)),this,SIGNAL(windowTitelChanged(QString)));</span><br></pre></td></tr></table></figure><p>​    这样，当一个信号发射时，也会发射另外一个信号，实现某些特殊的功能。</p><p>​    严格的情况下，信号与槽的参数个数和类型需要一致，至少信号的参数不能少于槽的参数。如果不匹配，会出现编译错误或运行错误。</p><p>​    在使用信号与槽的类中，必须在类的定义中加入宏 Q_OBJECT（特别重要）。</p><p>​    当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码。</p><p>​    总结，发送者与发送的信号是在一起的，接收者与接收的信号/槽是在一起的。它们不能在connect()方法里写乱顺序！由发送者发送出信号到接收者用信号/槽接收。</p><p>​    断开连接的方法，使用 disconnect()。disconnect()，这个方法重载了好几个函数，解开格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool QObject::disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)</span><br></pre></td></tr></table></figure><ul><li>断开一切与 myObject 连接的信号或槽。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(myObject, 0, 0, 0);</span><br></pre></td></tr></table></figure><p>​    相当于非静态重载函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject-&gt;disconnect();</span><br></pre></td></tr></table></figure><ul><li>断开所有连接到特定信号的东西。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(myObject, SIGNAL(mySignal()), 0, 0);</span><br></pre></td></tr></table></figure><p>​    相当于非静态重载函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject-&gt;disconnect(SIGNAL(mySignal()));</span><br></pre></td></tr></table></figure><ul><li>与指定的接收者断开连接。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(myObject, 0, myReceiver, 0);</span><br></pre></td></tr></table></figure><p>​    相当于非静态重载函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject-&gt;disconnect(myReceiver);</span><br></pre></td></tr></table></figure><p>​    信号与槽机制是 Qt GUI 编程的基础，使用信号与槽机制可以比较容易地将信号与响应代码关联起来。</p><p>​    信号只需声明，无需定义。</p><p>​    可以看到信号无需public 等关键字修饰。</p><p>​    创建槽的方法也很简单，也是直接在 mianwindow.h 里直接声明槽，在 mianwindow.cpp 里实现槽的定义，<strong>声明槽必须写槽的定义(定义指函数体的实现)，否则编译器编译时将会报错</strong>。</p><p><strong>槽有以下特点：</strong></p><ol><li>槽可以是任何成员函数、普通全局函数、静态函数</li><li>槽函数和信号的参数和返回值要一致</li></ol><p>信号槽连接的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect(pushButton, SIGNAL(clicked()), this, SLOT(pushButtonClicked()));</span><br><span class="line">connect(this, SIGNAL(pushButtonTextChanged()), this,SLOT(changeButtonText()));</span><br></pre></td></tr></table></figure><p>​    按住 Ctrl 键，再点击 clicked()，进入 clicked()这个信号的定义处。</p><p>​    返回上一步按 Alt + 方向左键</p><hr><p>参考文档：正点原子嵌入式Qt开发指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;strong&gt;Qt&lt;/strong&gt; &lt;strong&gt;信号与槽机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    信号与槽（Signal &amp;amp; Slot）是 Qt 编程的基础，也</summary>
      
    
    
    
    
    <category term="Qt" scheme="https://www.chenzhan.club/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>note55.9-Qt_Designer</title>
    <link href="https://www.chenzhan.club/2021/07/17/note55-9-Qt-Designer/"/>
    <id>https://www.chenzhan.club/2021/07/17/note55-9-Qt-Designer/</id>
    <published>2021-07-17T10:51:32.000Z</published>
    <updated>2021-07-19T08:15:00.772Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>基类</p><ul><li>QMainWindow：主窗口类，主窗口具有主菜单栏、工具栏和状态栏。类似于一般的应用程序的主窗口。如果您想做个嵌套的窗口程序开发的软件，不妨选择这个 QMainWindow。</li><li>QWidget：是可视界面类的基类，也就是说QMainWindow类也是由QWidget继承封装而来。所以 QWidget 要比 QMainWindow 功能少一些。</li><li>QDialog：对话框类，建立一个对话框界面。比较少使用此项作为基类。一般以 QMainWindow</li><li>和 QWidget 作为基类的居多。<u><strong>注因为 QWidget 不带窗口标题栏等，嵌入式里最好 QWidget。</strong></u></li></ul><p>活动项目的项目根节点都是用粗体字体表示的。如果打开了多个项目，那么我们只需要观察哪个是加粗的项目名就表示当前活动项目。</p><p>项目内的文件简介：</p><ul><li>01_hello_world.pro 是项目管理文件，这个项目管理文件十分重要，当您加入了文件或者删除了文件，Qt Creator 会自动修改这个* .pro 文件。有时候需要打开这个*.pro 文件添加我们的设置项。</li><li>Header 分组，这个节点下存放的是项目内所有的头文件*.h。 </li><li>Source 分组，这个节点下存放的是项目内的所有 C++源码文件*.cpp。 </li><li>Forms 分组，这个节点下是存放项目内所有界面文件* .ui。*.ui 文件由 XML 语言描述组成，编译时会生成相应的 cpp 文件，这样交叉编译器就可以编译它了。</li></ul><p>*<em>项目文件****</em>.pro**</p><p>core 与 gui 库是 Qt 的默认设置</p><p>SOURCES 下的是源文件</p><p>HEADERS 下是头文件</p><p>FORMS 下是 ui 界面文件</p><p>如果需要修改生成目标的可执行程序名字，可赋值 TARGET = xxx。否则 TARGET 将默认</p><p>取值为项目的名字。</p><p>*<em>样式文件****</em>.ui**</p><p>mainwindow.ui 是一个 xml 类型的文件，它的 xml 内容如下。这个文件是生成的不能手动编辑。只能够通过图形界面修改其属性。</p><p>①是控件栏，有各种各样的控件，上方的 Filter 是过滤器，输入首写字母就可以快速定到我们想要找的控件。</p><p>②显示的是我们的窗口程序了，上面已经带有 MainWindow 对象及其几个子对象，默认MainWindow 就带有菜单栏和状态栏。</p><p>③是对象栏，②处用到的对象都在③处显示。</p><p>④是属性栏，点击③处对象栏的某个对象，就可以在④属性栏里编辑它的属性了。属性项有很多，包括位置，大小，文字，颜色，字体等等。</p><p>*<em>头文件****</em>.h**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace Ui &#123; class MainWindow; &#125;</span><br></pre></td></tr></table></figure><p>定义名称空间 Ui ，里面有一个类 MainWindow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MainWindow(QWidget *parent &#x3D; nullptr);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个 class MainWindow 和上面 的 namespace Ui { class MainWindow; } 不是同一个对象。实际上，这个文件里的 namespace Ui { class MainWindow; }类有一个成员*ui 就是指 Ui::MainWindow 的指针。这都是为了使用.ui 文件设计界面的。</p><p>MainWindow 的声明中第一行是 Q_OBJECT，这是一个宏，由 Qt 进行处理，这也是 Qt 针对 C++扩展的地方，所有用到信号的类都要加这个宏。</p><p>*<em>源文件****</em>.cpp**</p><p>mainwindow.cpp</p><p>ui_mainwindow.h 这个文件是 Qt 根据.ui 文件自动生成的，也就是说 ui_mainwindow.h 要点击编构建后才生成，我们才能看到这个文件。构建/编译后可以在 debug/release 的目录找到这个文件。</p><p>在 MainWindow 构造函数中用“**,**”隔开，new 一个 Ui 中的 MainWindow。这里是一种初始化成员的方法。</p><p>ui-&gt;setupUi(this);这句话是进行界面初始化，将 this（指的是 MainWindow 类的本身），作为参数传到 setupUi 里，ui 界面文件的对象会以 this 为父对象，所有子对象都将显示在MainWindow 里。我们要想使用 ui 里的对象，必须将代码写在 ui-&gt;setupUi(this)这句话之后，因为 ui-&gt;setupUi(this)会先初始化里面的对象，只有初始化里面的对象我们才能使用这个对象。</p><p><strong>小提示：</strong>this 在成员函数的开始执行前构造的，在成员的执行结束后清除。</p><p>main.cpp</p><p>在每一个使用 Qt 的应用程序中都必须使用一个QApplication 对象。QApplication 管理了各种各样的应用程序的广泛资源，比如默认的字体和光标。</p><p>几乎在使用 Qt 的所有情况下，main()只需要在把控制转交给 Qt 库之前执行一些初始化，然后 Qt 库通过事件来向程序告知用户的行为。argc 是命令行变量的数量，argv 是命令行变量的数组。</p><p>调用方法 show()。这样程序界面才能显示。</p><p><strong>使用</strong> <strong>UI</strong> <strong>设计器开发程序</strong></p><p>在 UI 设计器里有两种方法可以连接信号与槽</p><p>所谓信号即是一个对象发出的信号，槽即是当这个对象发出这个信号时，对应连接的槽就发被执行或者触发。</p><p>要想事件做出对应的动作就必须用到信号与槽。</p><p>方法一：</p><p>点击信号槽连接的按钮，进入信号槽连接模式，进入信号与槽的连接模式后，将鼠标选中我们的“关闭程序”按钮，按住按钮，然后用鼠标向外拖动，此时就会出现信号槽连接的符号。</p><p>左边的“关闭程序”pushButton 按钮的信号，可以看到一个对象的信号可以有多种。右边的 QMainWindow 的槽函数，如果有其他对象，右边不一定只有MainWidnow 的槽函数（槽），也有可能是其他对象的槽。我们选择按钮的 clicked()信号，将其连接 MainWindow 对象的 close()槽。这样就完成了信号与槽的连接。可以预知这个信号与槽的功能，当“关闭程序”pushButton 发出了 clicked()信号（也就是单击信号）。这个信号由“关闭程序”pushButton 被单击时发出。它就会触发 MainWindow 的 close()。进而使整个程序关闭。MainWindow 的 close()就是退出关闭程序，退出程序的意思。</p><p>方法二：</p><p>选中“关闭程序”pushButton 按钮，然后右键。选择“转到槽”。</p><p>点击“转到槽”后，弹出窗口，先让我们选择信号。发现这个 clicked()信号并不是 pushButton 的，而是 QAbstactButton 的。只是 pusbButton 继承了 QAbstracButton，同时把这个信号也继承了下来。</p><p>不用重写 pushButton 的 clicked()事件。pushButton 只需要继承父类的 clicked()事件即可！</p><p>点击 OK 后，就会跳转到槽函数里，这个代码由 Qt Creator 自动生成。</p><p>同时在 mainwindow.h 里声明了这个槽函数。</p><p>返回到 mainwindow.cpp 找到 on_pushButton_clicked 这个槽函数里。在这个槽数里写上this-&gt;close();调用 close()方法关闭整个程序。</p><hr><p>参考资料：正点原子嵌入式Qt开发指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;基类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QMainWindow：主窗口类，主窗口具有主菜单栏、工具栏和状态栏。类似于一般的应用程序的主窗口。如果您想做个嵌套的窗口程序开发的软件，不妨选择这个</summary>
      
    
    
    
    
    <category term="Qt" scheme="https://www.chenzhan.club/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>note54.6-系统信息与系统资源</title>
    <link href="https://www.chenzhan.club/2021/07/16/note54-6-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/"/>
    <id>https://www.chenzhan.club/2021/07/16/note54-6-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/</id>
    <published>2021-07-16T07:19:24.000Z</published>
    <updated>2021-07-19T08:16:37.467Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在应用程序当中，有时往往需要去获取到一些系统相关的信息，譬如时间、日期、以及其它一些系统相关信息，如何通过 Linux 系统调用或 C 库函数获取系统信息，譬如获取系统时间、日期以及设置系统时间、日期等；除此之外，还会向大家介绍 Linux 系统下的/proc 虚拟文件系统，包括/proc 文件系统是什么以及如何从/proc 文件系统中读取系统、进程有关信息，有关系统资源的使用，譬如系统内存资源的申请与使用等</p><h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a><strong>系统信息</strong></h1><h2 id="系统标识-uname"><a href="#系统标识-uname" class="headerlink" title="系统标识 uname"></a><strong>系统标识</strong> <strong>uname</strong></h2><p>系统调用 uname()用于获取有关当前操作系统内核的名称和信息</p><p>需要包含头文件&lt;sys/utsname.h&gt;</p><p>uname()函数用法非常简单，先定义一个 struct utsname 结构体变量，调用 uname()函数时传入变量的地址即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct utsname 结构体</span><br><span class="line">struct utsname &#123;</span><br><span class="line"> char sysname[]; &#x2F;* 当前操作系统的名称 *&#x2F;</span><br><span class="line"> char nodename[]; &#x2F;* 网络上的名称（主机名） *&#x2F;</span><br><span class="line"> char release[]; &#x2F;* 操作系统内核版本 *&#x2F;</span><br><span class="line"> char version[]; &#x2F;* 操作系统发行版本 *&#x2F;</span><br><span class="line"> char machine[]; &#x2F;* 硬件架构类型 *&#x2F;</span><br><span class="line"> #ifdef _GNU_SOURCE</span><br><span class="line"> char domainname[];&#x2F;* 当前域名 *&#x2F;</span><br><span class="line"> #endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，struct utsname 结构体中的所有成员变量都是字符数组，所以获取到的信息都是字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">测试结果如下：</span><br><span class="line">操作系统名称: Linux</span><br><span class="line">主机名: chenzhan-virtual-machine</span><br><span class="line">内核版本: 4.15.0-133-generic</span><br><span class="line">发行版本: #137~16.04.1-Ubuntu SMP Fri Jan 15 02:55:18 UTC 2021</span><br><span class="line">硬件架构: x86_64</span><br></pre></td></tr></table></figure><p>sysinfo 系统调用可用于获取一些系统统计信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct sysinfo &#123;</span><br><span class="line"> long uptime; &#x2F;* 自系统启动之后所经过的时间（以秒为单位） *&#x2F;</span><br><span class="line"> unsigned long loads[3]; &#x2F;* 1, 5, and 15 minute load averages *&#x2F;</span><br><span class="line"> unsigned long totalram; &#x2F;* 总的可用内存大小 *&#x2F;</span><br><span class="line"> unsigned long freeram; &#x2F;* 还未被使用的内存大小 *&#x2F;</span><br><span class="line"> unsigned long sharedram; &#x2F;* Amount of shared memory *&#x2F;</span><br><span class="line"> unsigned long bufferram; &#x2F;* Memory used by buffers *&#x2F;</span><br><span class="line"> unsigned long totalswap; &#x2F;* Total swap space size *&#x2F;</span><br><span class="line"> unsigned long freeswap; &#x2F;* swap space still available *&#x2F;</span><br><span class="line"> unsigned short procs; &#x2F;* 系统当前进程数量 *&#x2F;</span><br><span class="line"> unsigned long totalhigh; &#x2F;* Total high memory size *&#x2F;</span><br><span class="line"> unsigned long freehigh; &#x2F;* Available high memory size *&#x2F;</span><br><span class="line"> unsigned int mem_unit; &#x2F;* 内存单元大小（以字节为单位） *&#x2F;</span><br><span class="line"> char _f[20-2*sizeof(long)-sizeof(int)]; &#x2F;* Padding to 64 bytes *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>gethostname 函数可用于单独获取 Linux 系统主机名，与 struct utsname 数据结构体中的 nodename 变量一样</p><p>sysconf()函数是一个库函数，可在运行时获取系统的一些配置信息，譬如页大小（page size）、主机名的最大长度、进程可以打开的最大文件数、每个用户 ID 的最大并发进程数等</p><p>使用该函数需要包含头文件&lt;unistd.h&gt;</p><p>调用 sysconf()函数获取系统的配置信息，参数 name 指定了要获取哪个配置信息，参数 name 可取以下任何一个值（都是宏定义，可通过 man 手册查询）： </p><ul><li><strong>_SC_ARG_MAX**</strong>：<strong>exec 族函数的参数的最大长度，exec 族函数后面会介绍，这里先不管！</strong></li><li>_SC_CHILD_MAX：<strong>每个用户的最大并发进程数，也就是同一个用户可以同时运行的最大进程数。</strong></li><li>__SC_HOST_NAME_MAX：主机名的最大长度。</li><li>__SC_LOGIN_NAME_MAX：登录名的最大长度。</li><li>__SC_CLK_TCK：每秒时钟滴答数，也就是系统节拍率。</li><li>__SC_OPEN_MAX：一个进程可以打开的最大文件数。</li><li>__SC_PAGESIZE：系统页大小（page size）。</li><li>__SC_TTY_NAME_MAX：终端设备名称的最大长度。</li></ul><p>用的比较多的是SC_PAGESIZE 和_SC_CLK_TCK</p><p>若指定的参数 name 为无效值，则 sysconf()函数返回-1，并会将 errno 设置为 EINVAL。否则返回的值便是对应的配置值。注意，返回值是一个 long 类型的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">每个用户的最大并发进程数: 7638</span><br><span class="line">系统节拍率: 100</span><br><span class="line">系统页大小: 4096</span><br></pre></td></tr></table></figure><h1 id="时间、日期"><a href="#时间、日期" class="headerlink" title="时间、日期"></a><strong>时间、日期</strong></h1><p>GMT（Greenwich Mean Time）中文全称是格林威治标准时间</p><p>UTC（Coordinated Universal Time）指的是世界协调时间（又称世界标准时间、世界统一时间），是经过平均太阳时(以格林威治时间 GMT 为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此若以「世界标准时间」的角度来说，UTC 比 GMT 来得更加精准</p><p><strong>在 Ubuntu 系统下，可以使用”date -u”命令查看到当前的 UTC 时间</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021年 07月 16日 星期五 07:42:47 UTC</span><br></pre></td></tr></table></figure><p><strong>在 Ubuntu 系统下，可以使用 date 命令查看系统当前的本地时间</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021年 07月 16日 星期五 15:47:14 CST</span><br></pre></td></tr></table></figure><p>CST 在这里其实指的是 China Standard Time（中国标准时间）的缩写，表示当前查看到的时间是中国标准时间，也就是我国所使用的标准时间–北京时间</p><p>在 Ubuntu 系统下，时区信息通常以标准格式保存在一些文件当中，这些文件通常位于/usr/share/zoneinfo目录下，该目录下的每一个文件（包括子目录下的文件）都包含了一个特定国家或地区内时区制度的相关信息，且往往根据其所描述的城市或地区缩写来加以命名，譬如 EST（美国东部标准时间）、CET（欧洲中部时间）、UTC（世界标准时间）、Hongkong、Iran、Japan（日本标准时间）等，也把这些文件称为时区配置文件</p><p>系统的本地时间由时区配置文件/etc/localtime 定义，通常链接到/usr/share/zoneinfo 目录下的某一个文件（或其子目录下的某一个文件）</p><p>如果我们要修改 Ubuntu 系统本地时间的时区信息，可以直接将/etc/localtime 链接到/usr/share/zoneinfo目录下的任意一个时区配置文件，譬如 EST（美国东部标准时间），首先进入到/etc 目录下，执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf localtime #删除原有链接文件</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;EST localtime #重新建立链接文件</span><br></pre></td></tr></table></figure><h2 id="Linux-系统中的时间"><a href="#Linux-系统中的时间" class="headerlink" title="Linux 系统中的时间"></a><strong>Linux</strong> <strong>系统中的时间</strong></h2><p><strong>点时间和段时间</strong></p><p><strong>实时时钟</strong> <strong>RTC</strong></p><p>操作系统中一般会有两个时钟，一个系统时钟（system clock），一个实时时钟（Real time clock），也叫 RTC；系统时钟由系统启动之后由内核来维护，譬如使用 date 命令查看到的就是系统时钟，所以在系统关机情况下是不存在的；而实时时钟一般由 RTC 时钟芯片提供，RTC 芯片有相应的电池为其供电，以保证系统在关机情况下 RTC 能够继续工作、继续计时。</p><p><strong>Linux</strong> <strong>系统如何记录时间</strong></p><p>Linux 系统在开机启动之后首先会读取 RTC 硬件获取实时时钟作为系统时钟的初始值，之后内核便开始维护自己的系统时钟。所以由此可知，RTC 硬件只有在系统开机启动时会读取一次，目的是用于对系统时钟进行初始化操作，之后的运行过程中便不会再对其进行读取操作了。而在系统关机时，内核会将系统时钟写入到 RTC 硬件、已进行同步操作。</p><p><strong>jiffies</strong> <strong>的引入</strong></p><p>jiffies 是内核中定义的一个全局变量，内核使用 jiffies 来记录系统从启动以来的系统节拍数，所以这个变量用来记录以系统节拍时间为单位的时间长度，Linux 内核在编译配置时定义了一个节拍时间，使用节拍率（一秒钟多少个节拍数）来表示，譬如常用的节拍率为 100Hz（一秒钟 100 个节拍数，节拍时间为 1s / 100）、500Hz（一秒钟 500 个节拍，节拍时间为 1s / 500）等。可以发现配置的节拍率越低，每一个系统节拍的时间就越短，也就意味着 jiffies 记录的时间精度越高，高节拍率会导致系统中断的产生更加频繁，频繁的中断会加剧系统的负担，一般默认情况下都是采用 100Hz 作为系统节拍率。</p><p>内核其实通过 jiffies 来维护系统时钟，全局变量 jiffies 在系统开机启动时会设置一个初始值，上面也给大家提到过，RTC 实时时钟会在系统开机启动时读取一次，目的是用于对系统时钟进行初始化，这里说的初始化其实指的就是对内核的 jiffies 变量进行初始化操作，操作系统使用 jiffies 这个全局变量来记录当前时间，当我们需要获取到系统当前时间点时，就可以使用 jiffies 变量去计算，当然并不需要我们手动去计算，Linux 系统提供了相应的系统调用或 C库函数用于获取当前时间，譬如系统调用 time()、gettimeofday()，其实质上就是通过 jiffies 变量换算得到。</p><h3 id="获取时间-time-gettimeofday"><a href="#获取时间-time-gettimeofday" class="headerlink" title="获取时间 time/gettimeofday"></a><strong>获取时间</strong> <strong>time/gettimeofday</strong></h3><p>系统调用 time()用于获取当前时间，以秒为单位，返回得到的值是自 1970-01-01 00:00:00 +0000 (UTC)以来的秒数</p><p>使用该函数需要包含头文件&lt;time.h&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line">time_t time(time_t *tloc);</span><br></pre></td></tr></table></figure><p>time 函数获取得到的是一个时间段，也就是从 1970-01-01 00:00:00 +0000 (UTC)到现在这段时间所经过的秒数，所以你要计算现在这个时间点，只需要使用 time()得到的秒数加 1970-01-01 00:00:00，可以直接使用相关系统调用或 C 库函数来得到当前时间</p><p>自 1970-01-01 00:00:00 +0000 (UTC)以来经过的总秒数，我们把这个称之为日历时间或 time_t 时间</p><p>gettimeofday()函数提供微秒级时间精度</p><p>ctime()是一个 C 库函数，可以将日历时间转换为可打印输出的字符串形式</p><p>但 ctime()是一个不可重入函数，存在一些安全上面的隐患，ctime_r()是 ctime()的可重入版本，一般推荐大家使用可重入函数 ctime_r()，可重入函数 ctime_r()多了一个参数 buf，也就是缓冲区首地址，所以 ctime_r()函数需要调用者提供用于存放字符串的缓冲区</p><p>Tips：在 Linux 系统中，有一些系统调用或 C 库函数提供了可重入版本与不可重入版本的函数接口，可重入版本函数所对应的函数名一般都会有一个” _r “后缀来表明它是一个可重入函数。</p><p>ctime（或ctime_r）转换得到的时间是计算机所在地对应的本地时间（譬如在中国对应的便是北京时间），并不是 UTC 时间</p><p>localtime()函数可以把 time()或 gettimeofday()得到的秒数（time_t 时间或日历时间）变成一个 struct tm结构体所表示的时间，该时间对应的是本地时间</p><p>gmtime()函数也可以把 time_t 时间变成一个 struct tm 结构体所表示的时间，与 localtime()所不同的是，gmtime()函数所得到的是 UTC 国际标准时间，并不是计算机的本地时间</p><p>mktime()可以将使用 struct tm 结构体表示的分解时间转换为 time_t时间（日历时间）</p><p>asctime()数与 ctime()函数的作用一样，但是将 struct tm 表示的分解时间转换为固定格式的字符串</p><p> strftime()，此函数也可以将一个 struct tm 变量表示的分解时间转换为为格式化字符串，可以根据自己的喜好自定义时间的显示格式</p><p>使用 settimeofday()函数可以设置时间，也就是设置系统的本地时间</p><h4 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a><strong>进程时间</strong></h4><p>进程时间指的是进程从创建后（也就是程序运行后）到目前为止这段时间内使用 CPU 资源的时间总数，出于记录的目的，内核把 CPU 时间（进程时间）分为以下两个部分：</p><ul><li>用户 CPU 时间：进程在用户空间（用户态）下运行所花费的 CPU 时间。有时也成为虚拟时间（virtualtime）。</li><li>系统 CPU 时间：进程在内核空间（内核态）下运行所花费的 CPU 时间。这是内核执行系统调用或代表进程执行的其它任务（譬如，服务页错误）所花费的时间。</li></ul><p>一般来说，进程时间指的是用户 CPU 时间和系统 CPU 时间的总和，也就是总的 CPU 时间。</p><p>Tips：进程时间不等于程序的整个生命周期所消耗的时间，如果进程一直处于休眠状态（进程被挂起、不会得到系统调度），那么它并不会使用 CPU 资源，所以休眠的这段时间并不计算在进程时间中。</p><p>times()函数用于获取当前进程时间</p><p>使用该函数需要包含头文件&lt;sys/times.h&gt;</p><p>如果我们想查看程序运行到某一个位置时的进程时间，或者计算出程序中的某一段代码执行过程所花费的进程时间，都可以使用 times()函数来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">时间总和: 1.630000 秒</span><br><span class="line">用户 CPU 时间: 0.610000 秒</span><br><span class="line">系统 CPU 时间: 0.000000 秒</span><br></pre></td></tr></table></figure><p>库函数 clock()提供了一个更为简单的方式用于进程时间，它的返回值描述了进程使用的总的 CPU 时间（也就是进程时间，包括用户 CPU 时间和系统 CPU 时间）</p><h3 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a><strong>产生随机数</strong></h3><p><strong>随机数与伪随机数</strong></p><p>随机数是随机出现，没有任何规律的一组数列。在我们编程当中，是没有办法获得真正意义上的随机数列的，这是一种理想的情况，在我们的程序当中想要使用随机数列，只能通过算法得到一个伪随机数序列，那在编程当中说到的随机数，基本都是指伪随机数。</p><p>C 语言函数库中提供了很多函数用于产生伪随机数，其中最常用的是通过 rand()和 srand()产生随机数</p><p>rand()函数用于获取随机数，多次调用 rand()可得到一组随机数序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int rand(void);</span><br></pre></td></tr></table></figure><p>如果没有调用 srand()设置随机数种子的情况下，rand()会将 1 作为随机数种子，如果随机数种子相同，那么每一次启动应用程序所得到的随机数序列就是一样的，所以每次启动应用程序需要设置不同的随机数种子，这样就可以使得程序每次运行所得到随机数序列不同</p><p>使用 srand()函数为 rand()设置随机数种子</p><p>常用的用法 srand(time(NULL));</p><p>程序中将 rand()的随机数种子设置为 srand(time(NULL))，直接等于 time_t 时间值，意味着每次启动种子都不一样，所以能够产生不同的随机数数组</p><p>random()、srandom()、initstate()、setstate()也是可以产生随机数的 API 函数</p><p>使用 man 手册查看系统调用或 C 库函数帮助信息时，在帮助信息页面 SEE ALSO 栏会列举出与本函数有关联的一些命令、系统调用或 C 库函数等</p><h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a><strong>休眠</strong></h4><p>有时需要将进程暂停或休眠一段时间，进入休眠状态之后，程序将暂停运行，直到休眠结束。常用的系统调用和 C 库函数有 sleep()、usleep()以及 nanosleep()，这些函数在应用程序当中通常作为延时使用，譬如延时 1 秒钟</p><p><strong>秒级休眠: sleep</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int sleep(unsigned int seconds);</span><br></pre></td></tr></table></figure><p><strong>微秒级休眠: uslee</strong></p><p>#include &lt;unistd.h&gt;</p><p><strong>高精度休眠: nanosleep</strong></p><p>nanosleep()具有更高精度来设置休眠时间长度，支持纳秒级时长设置</p><p>使用该函数需要包含头文件&lt;time.h&gt;。</p><p>休眠状态下，该进程会失去 CPU使用权，退出系统调度队列，直到休眠结束</p><h3 id="申请堆内存"><a href="#申请堆内存" class="headerlink" title="申请堆内存"></a><strong>申请堆内存</strong></h3><p>在操作系统下，内存资源是由操作系统进行管理、分配的，当应用程序想要内存时（这里指的是堆内存），可以向操作系统申请内存，然后使用内存；当不再需要时，将申请的内存释放、归还给操作系统</p><p><strong>在堆上分配内存：**</strong>malloc** <strong>和</strong> <strong>free</strong></p><p>Linux C 程序当中一般使用 malloc()函数为程序分配一段堆内存，而使用 free()函数来释放这段内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void *malloc(size_t size);</span><br></pre></td></tr></table></figure><p><strong>函数参数和返回值含义如下：</strong></p><p><strong>size：</strong>需要分配的内存大小，以字节为单位。</p><p><strong>返回值：</strong>返回值为 void *类型，如果申请分配内存成功，将返回一个指向该段内存的指针，void *并不是说没有返回值或者返回空指针，而是返回的指针类型未知,所以在调用 malloc()时通常需要进行强制类型转换，将 void *指针类型转换成我们希望的类型；如果分配内存失败（譬如系统堆内存不足）将返回 NULL，如果参数 size 为 0，返回值也是 NULL。</p><p>malloc()在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的，所以通常需要程序员对 malloc()分配的堆内存进行初始化操作。</p><p>在堆上分配的内存，需要开发者自己手动释放掉，通常使用 free()函数释放堆内存，free()函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void free(void *ptr);</span><br></pre></td></tr></table></figure><p><strong>函数参数和返回值含义如下：</strong></p><p><strong>ptr**</strong>：**指向需要被释放的堆内存对应的指针。</p><p><strong>返回值：</strong>无返回值。</p><p>Linux 系统中，当一个进程终止时，内核会自动关闭它没有关闭的所有文件（该进程打开的文件，但是在进程终止时未调用 close()关闭它）。对于内存来说也是如此，当进程终止时，内核会将其占用的所有内存都返还给操作系统，这包括在堆内存中由 malloc()函数所分配的内存空间，但是如果持续占用，将会导致内存泄漏</p><p><strong>在堆上分配内存的其它方法</strong></p><p>calloc()函数用来动态地分配内存空间并初始化为 0</p><p><strong>分配对其内存</strong></p><p>posix_memalign()、aligned_alloc()、memalign()、valloc()、pvalloc()</p><p>使用posix_memalign()、aligned_alloc()、valloc()时需要包含头文件&lt;stdlib.h&gt;，使用memalign()、pvalloc()这两个函数时需要包含头文件&lt;malloc.h&gt;</p><p>malloc()、calloc()分配内存返回的地址其实也是对齐的，但是它俩的对齐都是固定的</p><p>posix_memalign()函数用于在堆上分配 size 个字节大小的对齐内存空间，将*memptr 指向分配的空间，分配的内存地址将是参数 alignment 的整数倍。参数 alignment 表示对齐字节数，alignment 必须是 2 的幂次方（譬如 2^4、2^5、2^8 等），同时也要是 sizeof(void *)的整数倍，对于 32 位系统来说，sizeof(void *)等于4，如果是 64 位系统 sizeof(void *)等于 8。</p><p>aligned_alloc()函数用于分配 size 个字节大小的内存空间，返回指向该空间的指针。</p><p>memalign()与 aligned_alloc()参数是一样的，它们之间的区别在于：对于参数 size 必须是参数 alignment的整数倍这个限制条件，memalign()并没有这个限制条件</p><p>Tips：memalign()函数已经过时了，并不提倡使用！</p><p>valloc()分配 size 个字节大小的内存空间，返回指向该内存空间的指针，内存空间的地址是页大小（pagesize）的倍数。</p><p>Tips：valloc()函数已经过时了，并不提倡使用！</p><h3 id="proc-文件系统"><a href="#proc-文件系统" class="headerlink" title="proc 文件系统"></a><strong>proc</strong> <strong>文件系统</strong></h3><p>proc 文件系统是一个虚拟文件系统，它以文件系统的方式为应用层访问系统内核数据提供了接口，用户和应用程序可以通过 proc 文件系统得到系统信息和进程相关信息，对 proc 文件系统的读写作为与内核进行通信的一种手段。但是与普通文件不同的是，proc 文件系统是动态创建的，文件本身并不存在于磁盘当中、只存在于内存当中,与 devfs 一样，都被称为虚拟文件系统。</p><p>最初构建 proc 文件系统是为了提供有关系统中进程相关的信息，但是由于这个文件系统非常有用，因此内核中的很多信息也开始使用它来报告，或启用动态运行时配置。内核构建 proc 虚拟文件系统，它会将内核运行时的一些关键数据信息以文件的方式呈现在 proc 文件系统下的一些特定文件中，这样相当于将一些不可见的内核中的数据结构以可视化的方式呈现给应用层。</p><p>proc 文件系统挂载在系统的/proc 目录下，对于内核开发者（譬如驱动开发工程师）来说，proc 文件系统给了开发者一种调试内核的方法：通过查看/proc/xxx 文件来获取到内核特定数据结构的值，在添加了新功能前后进行对比，就可以判断此功能所产生的影响是否合理。</p><p>可以看到/proc 目录下有很多以数字命名的文件夹，譬如 100038、2299、98560，这些数字对应的其实就是<strong>一个一个的进程 PID 号，每一个进程在内核中都会存在一个编号，通过此编号来区分不同的进程</strong>，这个编号就是 PID 号</p><p>/proc 目录下除了文件夹之外，还有很多的虚拟文件，譬如 buddyinfo、cgroups、cmdline、version 等等，</p><p>不同的文件记录了不同信息，关于这些文件记录的信息和意思如下：</p><ul><li>cmdline：内核启动参数； </li><li>cpuinfo：CPU 相关信息；</li><li>iomem：IO 设备的内存使用情况；</li><li>interrupts：显示被占用的中断号和占用者相关的信息；</li><li>ioports：IO 端口的使用情况；</li><li>kcore：系统物理内存映像，不可读取；</li><li>loadavg：系统平均负载；</li><li>meminfo：物理内存和交换分区使用情况；</li><li>modules：加载的模块列表；</li><li>mounts：挂载的文件系统列表；</li><li>partitions：系统识别的分区表；</li><li>swaps：交换分区的利用情况；</li><li>version：内核版本信息；</li><li>uptime：系统运行时间；</li></ul><p><strong>proc</strong> <strong>文件系统的使用</strong></p><p>proc 文件系统的使用就是去读取/proc 目录下的这些文件，获取文件中记录的信息，可以直接使用 cat 命令读取，也可以在应用程序中调用 open()打开、然后再使用 read()函数读取。</p><p><strong>使用</strong> <strong>cat</strong> <strong>命令读取</strong></p><p>在 Linux 系统下直接使用 cat 命令查看/proc 目录下的虚拟文件，譬如”cat /proc/version”查看内核版本相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux version 4.15.0-133-generic (buildd@lgw01-amd64-024) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12)) #137~16.04.1-Ubuntu SMP Fri Jan 15 02:55:18 UTC 2021</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>占位。。等原子个更新《- -》</p><hr><p>参考资料：正点原子嵌入式Linux C应用编程指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;在应用程序当中，有时往往需要去获取到一些系统相关的信息，譬如时间、日期、以及其它一些系统相关信息，如何通过 Linux 系统调用或 C 库函数获取系统信息，譬如获取系统时间、日期以及</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note53.6-字符串处理</title>
    <link href="https://www.chenzhan.club/2021/07/16/note53-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>https://www.chenzhan.club/2021/07/16/note53-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</id>
    <published>2021-07-16T06:11:11.000Z</published>
    <updated>2021-07-19T08:18:21.025Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>字符串输出</strong></p><p><strong>使用以下函数需要包含头文件&lt;stdio.h&gt;</strong></p><p>puts()函数用来向标准输出设备（屏幕、显示器）输出字符串并自行换行。把字符串输出到标准输出设备，将’ \0 ‘转换为换行符’ \n ‘。</p><p>putchar()函数可以把参数 c 指定的字符（一个无符号字符）输出到标准输出设备，其输出可以是一个字符，可以是介于 0~127 之间的一个十进制整型数（包含 0 和 127，输出其对应的 ASCII 码字符），也可以是用 char 类型定义好的一个字符型变量</p><p>fputc()与 putchar()类似，也用于输出参数 c 指定的字符（一个无符号字符），与 putchar()区别在于，putchar()只能输出到标准输出设备，而 fputc()可把字符输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件</p><p>fputs()与 puts()类似，也用于输出一条字符串，与 puts()区别在于，puts()只能输出到标准输出设备，而 fputs()可把字符串输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件</p><p>gets()函数用于从标准输入设备（譬如键盘）中获取用户输入的字符串</p><p>用户从键盘输入的字符串数据首先会存放在一个输入缓冲区中，gets()函数会从输入缓冲区中读取字符</p><p>串存储到字符指针变量 s 所指向的内存空间，当从输入缓冲区中读走字符后，相应的字符<strong>便不存在</strong>缓冲区了。</p><p>输入的字符串中就算是有空格也可以直接输入，字符串输入完成之后按回车即可，gets()函数不检查缓冲区溢出。</p><p>程序中使用 gets()函数是<strong>非常不安全</strong>的</p><p><strong>gets()与scanf()的区别</strong></p><ul><li>gets()函数允许输入的字符串带有空格、制表符，输入的空格和制表符也是字符串的一部分，仅以回车换行符作为字符串的分割符；而对于 scanf 以%s 格式输入的时候，空格、换行符、TAB 制表符等都是作为字符串分割符存在，即分隔符前后是两个字符串，读取字符串时并不会将分隔符读取出来作为字符串的组成部分，一个%s 只能读取一个字符串，若要多去多个字符串，则需要使用多个%s、并且需要使用多个字符数组存储。</li><li>gets()会将回车换行符从输入缓冲区中取出来，然后将其丢弃，所以使用 gets()读走缓冲区中的字符串数据之后，缓冲区中将不会遗留下回车换行符；而对于 scanf()来说，使用 scanf()读走缓冲区中的字符串数据时，并不会将分隔符（空格、TAB 制表符、回车换行符等）读走将其丢弃，所以使用 scanf()读走缓冲区中的字符串数据之后，缓冲区中依然还存在用户输入的分隔符。</li></ul><p>scanf()%s不读取缓冲区中的分割符和换行符</p><p>对于%c 读入时，空格、换行符、TAB 这些都是正常字符</p><p>gets()会将换行符读取出来并将其丢弃，剩下一个空字符串</p><p>getchar()函数也是从输入缓冲区读取字符数据，但只读取一个字符，包括空格、TAB 制表符、换行回车符等</p><p>fgets()与 gets()的区别主要是三点：</p><ul><li>gets()只能从标准输入设备中获取输入字符串，而 fgets()既可以从标准输入设备获取字符串、也可以从一个普通文件中获取输入字符串。</li><li>fgets()可以设置获取字符串的最大字符数。</li><li>gets()会将缓冲区中的换行符’\n’读取出来、将其丢弃、将’\n’替换为字符串结束符’\0’；fgets()也会将缓冲区中的换行符读取出来，但并不丢弃，而是作为字符串组成字符存在，读取完成之后自动在最后添加字符串结束字符’\0’。</li></ul><p>fgetc()与 getchar()一样，用于读取一个输入字符，fgetc()与 getchar()的区别在于，fgetc 可以指定输入字符的文件，既可以从标准输入设备输入字符，也可以从一个普通文件中输入字符，其它方面与 getchar 函数相同</p><p><strong>字符串长度</strong></p><p>使用该函数需要包含头文件&lt;string.h&gt;。</p><p>C 语言函数库中提供了一个用于计算字符串长度的函数 strlen()</p><p><strong>sizeof</strong> <strong>和</strong> <strong>strlen</strong> <strong>的区别</strong></p><p>在程序当中，我们通常也会使用 sizeof 来计算长度，那 strlen 和 sizeof 有什么区别呢？</p><ul><li>sizeof 是 C 语言内置的操作符关键字，而 strlen 是 C 语言库函数；</li><li>sizeof 仅用于计算数据类型的大小或者变量的大小，而 strlen 只能以结尾为’ \0 ‘的字符串作为参数；</li><li>编译器在编译时就计算出了 sizeof 的结果，而 strlen 必须在运行时才能计算出来；</li><li>sizeof 计算数据类型或变量会占用内存的大小，strlen 计算字符串实际长度。</li></ul><p><strong>字符串拼接</strong></p><p>C 语言函数库中提供了 strcat()函数或 strncat()函数用于将两个字符串连接（拼接）起来</p><p>strcat()函数会把 src 所指向的字符串追加到 dest 所指向的字符串末尾，所以必须要保证 dest 有足够的存储空间来容纳两个字符串，否则会导致溢出错误；dest 末尾的’ \0 ‘结束字符会被覆盖，src 末尾的结束字符’ \0 ‘会一起被复制过去，最终的字符串只有一个’ \0 ‘</p><p>strncat()与 strcat()的区别在于，strncat 可以指定源字符串追加到目标字符串的字符数量</p><p>如果源字符串 src 包含 n 个或更多个字符，则 strncat()将 n+1 个字节追加到 dest 目标字符串（src 中的 n个字符加上结束字符’ \0 ‘）</p><p><strong>字符串拷贝</strong></p><p>C 语言函数库中提供了 strcpy()函数和 strncpy()函数用于实现字符串拷贝</p><p>strcpy()会把 src（必须包含结束字符’ \0 ‘）指向的字符串复制（包括字符串结束字符’ \0 ‘）到 dest，所以必须保证 dest 指向的内存空间足够大，能够容纳下 src 字符串，否则会导致溢出错误</p><p>strncpy()与 strcpy()的区别在于，strncpy()可以指定从源字符串 src 复制到目标字符串 dest 的字符数量</p><p>除了 strcpy()和 strncpy()之外，其实还可以使用 memcpy()、memmove()以及 bcopy()这些库函数实现拷贝操作</p><p><strong>内存填充</strong></p><p>在编程中，经常需要将某一块内存中的数据全部设置为指定的值，譬如在定义数组、结构体这种类型变量时，通常需要对其进行初始化操作，而初始化操作一般都是将其占用的内存空间全部填充为 0</p><p>memset()函数用于将某一块内存的数据全部设置为指定的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void *memset(void *s, int c, size_t n);</span><br></pre></td></tr></table></figure><p>使用该函数需要包含头文件&lt;string.h&gt;。</p><p><strong>函数参数和返回值含义如下：</strong></p><p><strong>s：</strong>需要进行数据填充的内存空间起始地址。</p><p><strong>c：</strong>要被设置的值，该值以 int 类型传递。</p><p><strong>n：</strong>填充的字节数。</p><p><strong>返回值：</strong>返回指向内存空间 s 的指针。</p><p>参数 c 虽然是以 int 类型传递，但 memset()函数在填充内存块时是使用该值的无符号字符形式，也就是函数内部会将该值转换为 unsigned char 类型的数据，以字节为单位进行数据填充。</p><p>bzero()函数用于将一段内存空间中的数据全部设置为 0</p><p>可以对数组 str 进行初始化操作，将其存储的数据全部设置为 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzero(str, sizeof(str));</span><br></pre></td></tr></table></figure><p><strong>字符串比较</strong></p><p>C 语言函数库提供了用于字符串比较的函数 strcmp()和 strncmp()，strcmp()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int strcmp(const char *s1, const char *s2);</span><br></pre></td></tr></table></figure><p><strong>函数参数和返回值含义如下：</strong></p><p><strong>s1**</strong>：**进行比较的字符串 1。</p><p><strong>s2**</strong>：**进行比较的字符串 2。</p><p><strong>返回值：</strong></p><ul><li>如果返回值小于 0，则表示 str1 小于 str2 </li><li>如果返回值大于 0，则表示 str1 大于 str2 </li><li>如果返回值等于 0，则表示字符串 str1 等于字符串 str2 </li></ul><p>strcmp 进行字符串比较，主要是通过比较字符串中的字符对应的 ASCII 码值，strcmp 会根据 ASCII 编码依次比较 str1 和 str2 的每一个字符，直到出现了不同的字符，或者某一字符串已经到达末尾（遇见了字符串结束字符’ \0 ‘）</p><p>strncmp()与 strcmp()函数一样，也用于对字符串进行比较操作，但最多比较前 n 个字符</p><p><strong>字符串查找</strong></p><p>字符串查找在平时的编程当中也是一种很常见的操作，譬如从一个给定的字符串当中查找某一个字符</p><p>或者一个字符串，并获取它的位置。C 语言函数库中也提供了一些用于字符串查找的函数，包括 strchr()、strrchr()、strstr()、strpbrk()、index()以及 rindex()等</p><p>使用 strchr()函数可以查找到给定字符串当中的某一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char *strchr(const char *s, int c);</span><br></pre></td></tr></table></figure><p><strong>函数参数和返回值含义如下：</strong></p><p><strong>s：</strong>给定的目标字符串。</p><p><strong>c：</strong>需要查找的字符。</p><p><strong>返回值：</strong>返回字符 c 第一次在字符串 s 中出现的位置，如果未找到字符 c，则返回 NULL。</p><p>字符串结束字符’ \0 ‘也将作为字符串的一部分，因此，如果将参数 c 指定为’ \0 ‘，则函数将返回指向结束字符的指针。strchr 函数在字符串 s 中从前到后（或者称为从左到右）查找字符 c，找到字符 c 第一次出现的位置就返回，返回值指向这个位置，如果找不到字符 c 就返回 NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char *ptr &#x3D; NULL;</span><br><span class="line">char str[] &#x3D; &quot;Hello World!&quot;;</span><br><span class="line">ptr &#x3D; strchr(str, &#39;W&#39;);</span><br><span class="line">if (NULL !&#x3D; ptr) &#123;</span><br><span class="line">printf(&quot;Character: %c\n&quot;, *ptr);</span><br><span class="line">printf(&quot;Offset: %ld\n&quot;, ptr - str);&#x2F;&#x2F;打印目标的数组下标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strrchr()与 strchr()函数一样，它同样表示在字符串中查找某一个字符，返回字符第一次在字符串中出现的位置，如果没找到该字符，则返回值 NULL，但两者唯一不同的是，strrchr()函数在字符串中是从后到前（或者称为从右向左）查找字符，找到字符第一次出现的位置就返回，返回值指向这个位置</p><p>strstr()可在给定的字符串 haystack 中查找第一次出现子字符串 needle 的位置，不包含结束字符’ \0 ‘</p><p>C 函数库中还提供其它的字符串（或字符）查找函数，譬如 strpbrk()、index()以及 rindex()等</p><p><strong>字符串与数字互转</strong></p><p><strong>字符串转整形数据</strong></p><p>atoi()、atol()、atoll()三个函数可用于将字符串分别转换为 int、long int 以及 long long 类型的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int atoi(const char *nptr);</span><br><span class="line">long atol(const char *nptr);</span><br><span class="line">long long atoll(const char *nptr);</span><br></pre></td></tr></table></figure><p>使用这些函数需要包含头文件&lt;stdlib.h&gt;。</p><p>strtol()、strtoll()两个函数可分别将字符串转为 long int 类型数据和 long long ing 类型数据，与 atol()、atoll()之间的区别在于，strtol()、strtoll()可以实现将多种不同进制数（譬如二进制表示的数字字符串、八进制表示的数字字符串、十六进制表示的数数字符串）表示的字符串转换为整形数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">long int strtol(const char *nptr, char **endptr, int base);</span><br><span class="line">long long int strtoll(const char *nptr, char **endptr, int base);</span><br></pre></td></tr></table></figure><p>需要进行转换的目标字符串可以以任意数量的空格或者 0 开头，转换时跳过前面的空格字符，直到遇上数字字符或正负符号（’ + ‘或’ - ‘）才开始做转换，而再遇到非数字或字符串结束时(‘ /0 ‘)才结束转换，并将结果返回</p><p>在 base=0 （数字基数，合法范围，比如base = 2，合法数值为0，1）的情况下，如果字符串包含一个了“0x”前缀，表示该数字将以 16 为基数；如果包含的是“0”前缀，表示该数字将以 8 为基数。 当 base=16 时，字符串可以使用“0x”前缀。</p><p>strtoul()返回值类型是 unsignedlong int，strtoull()返回值类型是 unsigned long long int</p><p><strong>字符串转浮点型数据</strong></p><p>atof()用于将字符串转换为一个 double 类型的浮点数据</p><p>strtof()、strtod()以及 strtold()三个库函数可分别将字符串转换为 float 类型数据、double 类型数据、longdouble 类型数据</p><p><strong>数字转字符串</strong></p><p>数字转换为字符串推荐大家使用前面介绍的格式化 IO 相关库函数，譬如使用 printf()将数字转字符串、并将其输出到标准输出设备或者使用 sprintf()或 snprintf()将数字转换为字符串并存储在缓冲区中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(void) &#123;</span><br><span class="line"> char str[20] &#x3D; &#123;0&#125;;</span><br><span class="line"> sprintf(str, &quot;%d&quot;, 500);</span><br><span class="line"> puts(str);</span><br><span class="line"> memset(str, 0x0, sizeof(str));</span><br><span class="line"> sprintf(str, &quot;%f&quot;, 500.111);</span><br><span class="line"> puts(str);</span><br><span class="line"> memset(str, 0x0, sizeof(str));</span><br><span class="line"> sprintf(str, &quot;%u&quot;, 500);</span><br><span class="line"> puts(str);</span><br><span class="line"> exit(0);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>给应用程序传参</strong></p><p>如果在执行应用程序时，需要向应用程序传递参数，则写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line"> &#x2F;* 代码 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;* 代码 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递进来的参数以字符串的形式存在，字符串的起始地址存储在 argv 数组中，参数 argc 表示传递进来的参数个数，包括应用程序自身路径名，多个不同的参数之间使用空格分隔开来，如果参数本身带有空格、则可以使用双引号” “或者单引号’ ‘的形式来表示</p><p><strong>正则表达式</strong></p><p>在许多的应用程序当中，通常会有这样的需要：给定一个字符串，检查该字符串是否符合某种条件或规则、或者从给定的字符串中找出符合某种条件或规则的子字符串，将匹配到的字符串提取出来</p><p>正则表达式，又称为规则表达式（英语: Regular Expression），<strong>正则表达式通常被用来检索、替换那些符合某个模式（规则）的字符串，正则表达式描述了一种字符串的匹配模式（pattern），可以用来检查一个给定的字符串中是否含有某种子字符串、将匹配的字符串替换或者从某个字符串中取出符合某个条件的子字符串</strong>。</p><p>在 Linux 系统下运行命令的时候，相信大家都使用过?或 * 通配符来查找硬盘上的文件或者文本中的某个字符串，?通配符匹配 0 个或 1 个字符，而*通配符匹配 0 个或多个字符正则表达式其实也是一个字符串，该字符串由普通字符（譬如，数字 0~9、大小写字母以及其它字符）和特殊字符（称为“元字符”）所组成，由这些字符组成一个“规则字符串”，这个“规则字符串”用来表达对给定字符串的一种查找、匹配逻辑</p><p>占位！后续待正点原子更新&lt;=-=&gt;</p><hr><p>参考资料：正点原子嵌入式Linux C应用编程指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;strong&gt;字符串输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用以下函数需要包含头文件&amp;lt;stdio.h&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;puts()函数</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note52.6-文件属性与目录</title>
    <link href="https://www.chenzhan.club/2021/07/15/note52-6-%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%AE%E5%BD%95/"/>
    <id>https://www.chenzhan.club/2021/07/15/note52-6-%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%AE%E5%BD%95/</id>
    <published>2021-07-15T07:49:19.000Z</published>
    <updated>2021-07-19T08:20:30.951Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>可以通过 stat 命令或者 ls -l 命令来查看文件类型</p><ul><li>‘ - ‘：普通文件</li><li>‘ d ‘：目录文件</li><li>‘ c ‘：字符设备文件</li><li>‘ b ‘：块设备文件</li><li>‘ l ‘：符号链接文件</li><li>‘ s ‘：套接字文件</li><li>‘ p ‘：管道文件</li></ul><p><strong>目录文件</strong></p><p><strong>字符设备文件和块设备文件</strong></p><p>字符设备文件（character）、块设备文件（block）</p><p>字符设备文件一般存放在 Linux 系统/dev/目录下，所以/dev 也称为虚拟文件系统 devfs</p><p>设备文件对应于硬件设备</p><p><strong>符号链接文件</strong>（link）类似于 Windows 系统中的快捷方式文件，是一种特殊文件，它的内容指向的是另一个文件路径，当对符号链接文件进行操作时，系统根据情况会对这个操作转移到它指向的文件上去，而不是对它本身进行操作，譬如，读取一个符号链接文件内容时，实际上读到的是它指向的文件的内容</p><p><strong>管道文件</strong>（pipe）主要用于进程间通信</p><p><strong>套接字文件</strong>（socket）也是一种进程间通信的方式，与管道文件不同的是，它们可以在不同主机上的进程间通信，实际上就是网络通信</p><p>Linux 下可以使用 stat 命令查看文件的属性，其实这个命令内部就是通过调用 stat()函数来获取文件属性的，stat 函数是 Linux 中的系统调用，用于获取文件相关的信息</p><p>structstat 是内核定义的一个结构体，在&lt;sys/stat.h&gt;头文件中申明，所以可以在应用层使用，这个结构体中的所有元素加起来构成了文件的属性信息</p><p>st_mode 是 structstat 结构体中的一个成员变量，是一个 32 位无符号整形数据，该变量记录了文件的类型、文件的权限这些信息</p><p>struct timespec 结构体该结构体定义在&lt;time.h&gt;头文件中，是 Linux 系统中时间相关的结构体，应用程序中包含了&lt;time.h&gt;头文件</p><p>在 Linux 系统中，time_t 时间指的是一个时间段，从某一个时间点到某一个时间点所经过的秒数，譬如对于文件的三个时间属性来说，指的是从过去的某一个时间点（这个时间点是一个起始基准时间点）到文件最后被访问、文件内容最后被修改、文件状态最后被改变的这个时间点所经过的秒数</p><p>可以通过 localtime()/localtime_r()或者 strftime()来得到更利于我们查看的时间表达方式“2020-10-10 18:30:30”</p><p>fstat 与 stat 区别在于，stat 是从文件名出发得到文件属性信息，不需要先打开文件；而 fstat 函数则是从文件描述符出发得到文件属性信息，所以使用 fstat 函数之前需要先打开文件得到文件描述符</p><p>lstat()与 stat、fstat 的区别在于，对于符号链接文件，stat、fstat 查阅的是符号链接文件所指向的文件对应的文件属性信息，而 lstat 查阅的是符号链接文件本身的属性信息</p><p>Linux 是一个多用户操作系统，系统中一般存在着好几个不同的用户，而 Linux 系统中的每一个文件都有一个与之相关联的用户和用户组，通过这个信息可以判断文件的所有者和所属组</p><p>文件所属组则表示该文件属于哪一个用户组。在 Linux 中，系统并不是通过用户名或用户组名来识别不同的用户和用户组，而是通过 ID。ID 就是一个编号，Linux 系统会为每一个用户或用户组分配一个 ID，将用户名或用户组名与对应的 ID 关联起来，所以系统通过用户 ID（UID）或组 ID（GID）就可以识别出不同的用户和用户组</p><p>Tips：用户 ID 简称 UID、用户组 ID 简称 GID。</p><p>文件的用户 ID 和组 ID 分别由 struct stat 结构体中的 st_uid 和 st_gid 所指定</p><ul><li>实际用户 ID 和实际组 ID 标识我们究竟是谁，也就是执行该进程的用户是谁、以及该用户对应的所属组；实际用户 ID 和实际组 ID 确定了进程所属的用户和组。</li><li>进程的有效用户 ID、有效组 ID 以及附属组 ID 用于文件访问权限检查。</li></ul><p>对于有效用户 ID 和有效组 ID 来说，这是进程所持有的概念，对于文件来说，并无此属性！有效用户 ID 和有效组 ID 是站在操作系统的角度，用于给操作系统判断当前执行该进程的用户在当前环境下对某个文件是否拥有相应的权限</p><p><strong>chown 是一个系统调用，该系统调用可用于改变文件的所有者（用户 ID）和所属组（组 ID）</strong></p><p>将 testApp.c</p><p>文件的所有者和所属组修改为 root：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown root:root testApp.c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int chown(const char *pathname, uid_t owner, gid_t group);</span><br></pre></td></tr></table></figure><ul><li>只有超级用户进程能更改文件的用户 ID；</li><li>普通用户进程可以将文件的组 ID 修改为其所从属的任意附属组 ID，前提条件是该进程的有效用户 ID 等于文件的用户 ID；而超级用户进程可以将文件的组 ID 修改为任意值。</li></ul><p>在 Linux 系统下，可以使用 getuid 和 getgid 两个系统调用分别用于获取当前进程的用户 ID 和用户组ID，这里说的进程的用户 ID 和用户组 ID 指的就是进程的实际用户 ID 和实际组 ID</p><p><strong>0 指的就是 root用户和 root 用户组</strong></p><p>struct stat 结构体中的 st_mode 字段记录了文件的访问权限位</p><p>文件的权限可以分为两个大类，分别是普通权限和特殊权限（也可称为附加权限）。普通权限包括对文件的读、写以及执行，而特殊权限则包括一些对文件的附加权限，譬如Set-User-ID、Set-Group-ID以及Sticky</p><p><strong>普通权限</strong></p><p>每个文件都有 9 个普通的访问权限位，可将它们分为 3 类</p><table><thead><tr><th>st_mode 权限表示宏</th><th>含义</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>文件所有者读权限</td></tr><tr><td>S_IWUSR</td><td>文件所有者写权限</td></tr><tr><td>S_IXUSR</td><td>文件所有者执行权限</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>一串字符串就描述了该文件的 9 个访问权限以及文件类型，譬如”- （文件类型）| rwx（所有者权限） | rwx（同组用户权限） | rx（其他用户权限）”： </p><p>“ - “表示该文件是一个普通文件。</p><p><strong>r</strong> 表示具有读权限；</p><p><strong>w</strong> 表示具有写权限；</p><p><strong>x</strong> 表示具有执行权限； </p><p>**-**表示无此权限</p><ul><li>如果进程的有效用户 ID 等于文件所有者 ID（st_uid），意味着该进程以文件所有者的角色存在；</li><li>如果进程的有效用户 ID 并不等于文件所有者 ID，意味着该进程并不是文件所有者身份；但是进程的有效用户组 ID 或进程的附属组 ID 之一等于文件的组 ID（st_gid），那么意味着该进程以文件所属组成员的角色存在，也就是文件所属组的同组用户成员。 </li><li>如果进程的有效用户 ID 不等于文件所有者 ID、并且进程的有效用户组 ID 或进程的所有附属组 ID均不等于文件的组 ID（st_gid），那么意味着该进程以其它用户的角色存在。</li><li>如果进程的有效用户 ID 等于 0（root 用户），则无需进行权限检查，直接对该文件拥有最高权限。</li></ul><p>st_mode 字段中除了记录文件的 9 个普通权限之外，还记录了文件的 3 个特殊权限，也就是 S 字段权限位，S 字段三个 bit 位中，从高位到低位依次表示文件的 set-user-ID 位权限、set-groupID 位权限以及 sticky 位权限</p><ul><li>当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-user-ID 位权限被设置，内核会将进程的有效 ID 设置为该文件的用户 ID（文件所有者 ID），意味着该进程直接获取了文件所有者的权限、以文件所有者的身份操作该文件。</li><li>当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-group-ID 位权限被设置，内核会将进程的有效用户组 ID 设置为该文件的用户组 ID（文件所属组 ID），意味着该进程直接获取了文件所属组成员的权限、以文件所属组成员的身份操作该文件。</li></ul><p>Linux 系统下绝大部分的文件都没有设置 set-user-ID 位权限和 set-group-ID 位权限，所以通常情况下，进程的有效用户等于实际用户（有效用户 ID 等于实际用户 ID），有效组等于实际组（有效组 ID 等于实际组 ID）</p><p><strong>普通文件权限方案（S/U/G/O）</strong></p><ul><li>目录的读权限：可列出（譬如：通过 ls 命令）目录之下的内容（即目录下有哪些文件）。</li><li>目录的写权限：可以在目录下创建文件、删除文件。</li><li>目录的执行权限：可访问目录下的文件，譬如对目录下的文件进行读、写、执行等操作。</li></ul><p>为了确保使用的是 ls 命令本身，执行时需要给出路径的完整路径/bin/ls</p><p>要想访问目录下的文件，譬如查看文件的 inode 节点、大小、权限等信息，还需要对目录拥有执行权限</p><p>反之，若拥有对目录的执行权限、而无读权限，只要知道目录内文件的名称，仍可对其进行访问，但不能列出目录下的内容（即目录下包含的其它文件的名称）。</p><p>要想在目录下创建文件或删除原有文件，需要同时拥有对该目录的执行和写权限。</p><p>所以由此可知，如果需要对文件进行读、写或执行等操作，不光是需要拥有该文件本身的读、写或执行权限，还需要拥有文件所在目录的执行权限。</p><p><strong>检查文件权限</strong> <strong>access</strong></p><p>使用该函数需要包含头文件&lt;unistd.h&gt;</p><p><strong>修改文件权限</strong> <strong>chmod</strong>/<strong>fchmod</strong> </p><p>使用该函数需要包含头文件&lt;sys/stat.h&gt;。</p><p>rwxrwxrwx（0777）</p><p>rw-r–r–（0644）</p><p>umask命令用于查看/设置权限掩码，权限掩码主要用于对新建文件的权限进行屏蔽</p><p>调用 open 函数新建文件时，文件实际的权限并不等于 mode 参数所描述的权限，而是通过如下关系得到实际权限：mode &amp; ~umask</p><p>譬如调用 open 函数新建文件时，mode 参数指定为 0777，假设 umask 为 0002，那么实际权限为：0777 &amp; (~0002) = 0775</p><p>umask 权限掩码是进程的一种属性，用于指明该进程新建文件或目录时，应屏蔽哪些权限位。进程的umask 通常继承至其父进程</p><p>umask 函数用于设置进程的权限掩码，该函数是一个系统调用（可通过”man 2 umask”命令查看）</p><p>使用该命令需要包含头文件&lt;sys/types.h&gt;和&lt;sys/stat.h&gt;</p><p><strong>文件的时间属性</strong></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>st_atim</td><td>文件最后被访问的时间</td></tr><tr><td>st_mtim</td><td>文件内容最后被修改的时间</td></tr><tr><td>st_ctim</td><td>文件状态最后被改变的时间</td></tr></tbody></table><ul><li>文件最后被访问的时间：访问指的是读取文件内容，文件内容最后一次被读取的时间，譬如使用read()函数读取文件内容便会改变该时间属性；</li><li>文件内容最后被修改的时间：文件内容发生改变，譬如使用 write()函数写入数据到文件中便会改变该时间属性；</li><li>文件状态最后被改变的时间：状态更改指的是该文件的 inode 节点最后一次被修改的时间，譬如更改文件的访问权限、更改文件的用户 ID、用户组 ID、更改链接数等</li></ul><p><strong>utime()、utimes()修改时间属性</strong></p><p>time()是 Linux 系统调用，用于获取当前时间（也可以直接将 times 参数设置为 NULL，这样就不需要使用 time 函数来获取当前时间了），单位为秒</p><p>可以使用 date 命令查看当前系统时间</p><p>用于显式修改文件时间戳，它们是 <strong>futimens()和 utimensat()</strong></p><ul><li>可按纳秒级精度设置时间戳。相对于提供微秒级精度的 utimes()，这是重大改进！</li><li>可单独设置某一时间戳。譬如，只设置访问时间、而修改时间保持不变，如果要使用 utime()或 utimes()来实现此功能，则需要首先使用 stat()获取另一个时间戳的值，然后再将获取值与打算变更的时间戳一同指定。</li><li>可独立将任一时间戳设置为当前时间。使用 utime()或 utimes()函数虽然也可以通过将 times 参数设置为 NULL 来达到将时间戳设置为当前时间的效果，但是不能单独指定某一个时间戳，必须全部设置为当前时间（不考虑使用额外函数获取当前时间的方式，譬如 time()）。</li></ul><p><strong>符号链接（软链接）与硬链接</strong></p><p>Tips：使用 ln 命令可以为一个文件创建软链接文件或硬链接文件，用法如下：</p><p>硬链接：ln 源文件 链接文件</p><p>软链接：ln -s 源文件 链接文件</p><p>使用 ln 命令创建的两个硬链接文件与源文件 test_file 都拥有相同的 inode 号，既然inode 相同，也就意味着它们指向了物理硬盘的同一个区块，仅仅只是文件名字不同而已，创建出来的硬链接文件与源文件对文件系统来说是完全平等的关系inode 数据结结构中会记录文件的链接数，这个链接数指的就是硬链接数，struct stat 结构体中的st_nlink 成员变量就记录了文件的链接数</p><p>当为文件每创建一个硬链接，inode 节点上的链接数就会加一，每删除一个硬链接，inode 节点上的链接数就会减一，直到为 0，inode 节点和对应的数据块才会被文件系统所回收，也就意味着文件已经从文件系统中被删除了</p><p>当源文件被删除之后，软链接文件依然存在，但此时它指向的是一个无效的文件路径，这种链接文件被称为悬空链接</p><p><strong>创建硬链接</strong> **link()**需要包含头文件&lt;unistd.h&gt;。</p><p><strong>创建软链接</strong> **symlink()**需要包含头文件&lt;unistd.h&gt;</p><p>使用系统调用 readlink<strong>读取软链接文件</strong>中存储的路径信息</p><p>目录（文件夹）在 Linux 系统也是一种文件，是一种特殊文件，同样可以使用前面给大家介绍 open、read 等这些系统调用以及 C 库函数对其进行操作，但是目录作为一种特殊文件，并不适合使用前面介绍的文件 I/O 方式进行读写等操作。在 Linux 系统下，会有一些专门的系统调用或 C 库函数用于对文件夹进行操作，譬如：打开、创建文件夹、删除文件夹、读取文件夹以及遍历文件夹中的文件等</p><ul><li>普通文件由 inode 节点和数据块构成</li><li>目录由 inode 节点和目录块构成</li></ul><p>在 Linux 系统下，提供了专门用于创建目录 mkdir()以及删除目录 rmdir 相关的系统调用</p><p>可以使用 opendir()、readdir()和 closedir()来打开、读取以及关闭目录</p><p>Tips：“流”是从自然界中抽象出来的一种概念，有点类似于自然界当中的水流，在文件操作中，文件内容数据类似池塘中存储的水，N 个字节数据被读取出来或将 N 个字节数据写入到文件中，这些数据就构成了字节流。</p><p>“流”这个概念是动态的，而不是静态的。编程当中提到这个概念，一般都是与 I/O 相关，所以也经常叫做 I/O 流；但对于目录这种特殊文件来说，这里将目录块中存储的数据称为目录流，存储了一个一个的目录项（目录条目）。</p><p>rewinddir()是 C 库函数，可将目录流重置为目录起点，以便对 readdir()的下一次调用将从目录列表中的第一个文件开始</p><p>Linux 下的每一个进程都有自己的当前工作目录（current working directory），当前工作目录是该进程解析、搜索相对路径名的起点（不是以” / “斜杆开头的绝对路径）</p><p>一般情况下，运行一个进程时、其父进程的当前工作目录将被该进程所继承，成为该进程的当前工作目录。可通过 getcwd 函数来获取进程的当前工作目录</p><p>系统调用 chdir()和 fchdir()可以用于更改进程的当前工作目录</p><p>unlink()用于删除一个文件（不包括目录）</p><p>remove()是一个 C 库函数，用于移除一个文件或空目录</p><p>借助于 rename()既可以对文件进行重命名，又可以将文件移至同一文件系统中的另一个目录下</p><p>根据 oldpath、newpath 的不同，有以下不同的情况需要进行说明：</p><ul><li>若 newpath 参数指定的文件或目录已经存在，则将其覆盖；</li><li>若 newpath 和 oldpath 指向同一个文件，则不发生变化（且调用成功）。</li><li>rename()系统调用对其两个参数中的软链接均不进行解引用。如果 oldpath 是一个软链接，那么将重命名该软链接；如果 newpath 是一个软链接，则会将其移除、被覆盖。 </li><li>如果 oldpath 指代文件，而非目录，那么就不能将 newpath 指定为一个目录的路径名。要想重命名一个文件到某一个目录下，newpath 必须包含新的文件名。</li><li>如果 oldpath 指代为一个目录，在这种情况下，newpath 要么不存在，要么必须指定为一个空目录。</li><li>oldpath 和 newpath 所指代的文件必须位于同一文件系统。由前面的介绍，可以得出此结论！不能对.（当前目录）和..（上一级目录）进行重命名。</li></ul><hr><p>参考资料：正点原子嵌入式Linux C应用编程指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;可以通过 stat 命令或者 ls -l 命令来查看文件类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘ - ‘：普通文件&lt;/li&gt;
&lt;li&gt;‘ d ‘：目录文件&lt;/li&gt;
&lt;li&gt;‘ c ‘：字</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note51.6-标准IO库</title>
    <link href="https://www.chenzhan.club/2021/07/15/note51-6-%E6%A0%87%E5%87%86IO%E5%BA%93/"/>
    <id>https://www.chenzhan.club/2021/07/15/note51-6-%E6%A0%87%E5%87%86IO%E5%BA%93/</id>
    <published>2021-07-15T07:15:44.000Z</published>
    <updated>2021-07-19T08:23:36.166Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>标准</strong> <strong>I/O</strong> <strong>库</strong></p><p><strong>FILE</strong> <strong>指针</strong></p><p>进程将从标准输入（stdin）文件中得到输入数据，将正常输出数据（譬如程序中 printf 打印输出的字符串）输出到标准输出（stdout）文件，而将错误信息（譬如函数调用报错打印的信息）输出到标准错误（stderr）文件</p><p>在标准 I/O 中，可以使用 stdin、stdout、stderr 来表示标准输入、标准输出和标准错误</p><p><strong>打开文件</strong> <strong>fopen()</strong></p><p><strong>读文件和写文件</strong>fread()和 fwrite()</p><p><strong>fseek</strong> <strong>定位</strong></p><p>库函数 ftell()可用于获取文件当前的读写位置偏移量</p><p>库函数 feof()用于测试参数 stream 所指文件的 end-of-file 标志，如果 end-of-file 标志被设置了，则调用feof()函数将返回一个非零值，如果 end-of-file 标志没有被设置，则返回 0</p><p>当文件的读写位置移动到了文件末尾时，end-of-file 标志将会被设置</p><p>库函数 ferror()用于测试参数 stream 所指文件的错误标志，如果错误标志被设置了，则调用 ferror()函数将返回一个非零值，如果错误标志没有被设置，则返回 0</p><p>当对文件的 I/O 操作发生错误时，错误标志将会被设置</p><p>库函数 clearerr()用于清除 end-of-file 标志和错误标志</p><p>格式化输出还包括：printf()、fprintf()、dprintf()、sprintf()、snprintf()这 4 个库函数</p><p>格式化输入包括：scanf()、fscanf()、sscanf()</p><p>C 库函数提供了 3 个格式化输入函数，包括：scanf()、fscanf()、sscanf()</p><table><thead><tr><th>mode</th><th>说明</th><th>对应于 open()函数的 flags 参数取值</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件</td><td>O_RDONLY</td></tr><tr><td>r+</td><td>以可读、可写方式打开文件</td><td>O_RDWR</td></tr><tr><td>……</td><td>…..</td><td>……</td></tr></tbody></table><p><strong>I/O</strong> <strong>缓冲</strong></p><p><strong>文件</strong> <strong>I/O</strong> <strong>的内核缓冲</strong></p><p><strong>刷新文件</strong> <strong>I/O</strong> <strong>的内核缓冲区</strong></p><p>Linux 中提供了一些系统调用可用于控制文件 I/O 内核缓冲，包括系统调用 sync()、syncfs()、fsync()以 及 fdatasync()</p><p><strong>控制文件</strong> <strong>I/O</strong> <strong>内核缓冲的标志</strong></p><p>在调用 open()函数时，指定 O_DSYNC 标志，其效果类似于在每个 write()调用之后调用 fdatasync()函数进行数据同步</p><p>在调用 open()函数时，指定 O_SYNC 标志，使得每个 write()调用都会自动将文件内容数据和元数据刷新到磁盘设备中，其效果类似于在每个 write()调用之后调用 fsync()函数进行数据同步</p><p>在程序中频繁调用 fsync()、fdatasync()、sync()（或者调用 open 时指定 O_DSYNC 或 O_SYNC 标志）对性能的影响极大，大部分的应用程序是没有这种需求的，所以在大部分应用程序当中基本不会使用到</p><p><strong>直接</strong> <strong>I/O**</strong>：绕过内核缓冲**</p><p>Linux 允许应用程序在执行文件 I/O 操作时绕过内核缓冲区，从用户空间直接将数据传递到文件或磁盘设备，把这种操作也称为直接 I/O（direct I/O）或裸 I/O（raw I/O）</p><p>执行直接 I/O 时，必须要遵守以下三个对齐限制要 求：</p><ul><li>应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐； </li><li>写文件时，文件的位置偏移量必须是块大小的整数倍；</li><li>写入到文件的数据大小必须是块大小的整数倍。</li></ul><p>如果不满足以上任何一个要求，调用 write()均为以错误返回 Invalid argument</p><p>可以使用 tune2fs 命令进行查看磁盘分区的块大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -l &#x2F;dev&#x2F;sda1 | grep &quot;Block size&quot;</span><br></pre></td></tr></table></figure><p>-l 后面指定了需要查看的磁盘分区，可以使用 df -h 命令查看 Ubuntu 系统的根文件系统所挂载的磁盘分区</p><p>使用 tune2fs 命令查看该分区的块大小</p><p>Tips：_GNU_SOURCE 宏可用于开启/禁用 Linux 系统调用和 glibc 库函数的一些功能、特性，要打开这些特性，需要在应用程序中定义该宏，定义该宏之后意味着用户应用程序打开了所有的特性；默认情况下，_GNU_SOURCE 宏并没有被定义，所以当使用到它控制的一些特性时，应用程序编译将会报错！定义该宏的方式有两种：</p><ul><li>直接在源文件中定义：#define _GNU_SOURCE_</li><li>_gcc 编译时使用-D 选项定义_GNU_SOURCE 宏：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -D_GNU_SOURCE -o testApp testApp.c</span><br></pre></td></tr></table></figure><p>gcc 的-D 选项可用于定义一个宏，并且该宏定义在整个源码工程中都是生效的，是一个全局宏定义</p><p>C 语言提供了一些库函数可用于对标准 I/O 的 stdio 缓冲区进行相关的一些设置，包括 setbuf()、setbuffer()以及 setvbuf()</p><p><strong>标准输出</strong> <strong>printf()**</strong>的行缓冲模式**</p><p><strong>刷新</strong> <strong>stdio</strong> <strong>缓冲区</strong></p><p><strong>㈠、关闭文件时刷新</strong> <strong>stdio</strong> <strong>缓冲区</strong></p><p><strong>㈡、程序退出时刷新</strong> <strong>stdio</strong> <strong>缓冲区</strong></p><p>关于刷新 stdio 缓冲区相关内容，最后进行一个总结：</p><ul><li>调用 fflush()库函数可强制刷新指定文件的 stdio 缓冲区；</li><li>调用 fclose()关闭文件时会自动刷新文件的 stdio 缓冲区；</li><li>程序退出时会自动刷新 stdio 缓冲区（注意区分不同的情况）。</li></ul><p>首先应用程序调用标准 I/O 库函数将用户数据写入到 stdio 缓冲区中，stdio 缓冲区是由 stdio 库所维护的用户空间缓冲区。针对不同的缓冲模式，当满足条件时，stdio 库会调用文件 I/O（系统调用 I/O）将 stdio 缓冲区中缓存的数据写入到内核缓冲区中，内核缓冲区位于内核空间。最终由内核向磁盘设备发起读写操作，将内核缓冲区中的数据写入到磁盘（或者从磁盘设备读取数据到内核缓冲区）。</p><p>应用程序调用库函数可以对 stdio 缓冲区进行相应的设置，设置缓冲区缓冲模式、缓冲区大小以及由调用者指定一块空间作为 stdio 缓冲区，并且可以强制调用 fflush()函数刷新缓冲区；而对于内核缓冲区来说，应用程序可以调用相关系统调用对内核缓冲区进行控制，譬如调用 fsync()、fdatasync()或 sync()来刷新内核缓冲区（或通过 open 指定 O_SYNC 或 O_DSYNC 标志），或者使用直接 I/O 绕过内核缓冲区（open 函数指定 O_DIRECT 标志）</p><p><strong>库函数 fileno()可以将标准 I/O 中使用的 FILE 指针转换为文件 I/O 中所使用的文件描述符，而 fdopen()则进行着相反的操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fileno(FILE *stream);</span><br><span class="line">FILE *fdopen(int fd, const char *mode);</span><br></pre></td></tr></table></figure><hr><p>参考资料：正点原子嵌入式Linux C应用编程指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;strong&gt;标准&lt;/strong&gt; &lt;strong&gt;I/O&lt;/strong&gt; &lt;strong&gt;库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FILE&lt;/strong&gt; &lt;s</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note50.10-《UNIX网络编程卷1》第一章习题</title>
    <link href="https://www.chenzhan.club/2021/07/14/note50-10-%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98/"/>
    <id>https://www.chenzhan.club/2021/07/14/note50-10-%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98/</id>
    <published>2021-07-14T13:59:14.000Z</published>
    <updated>2021-07-19T08:24:20.108Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>1.1 找出自己的网络拓扑的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">chenzhan@chenzhan-virtual-machine:&#x2F;$ netstat -ni</span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line"></span><br><span class="line">ens33      1500 0       229      0      0 0           279      0      0      0 BMRU</span><br><span class="line"></span><br><span class="line">lo        65536 0       244      0      0 0           244      0      0      0 LRU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chenzhan@chenzhan-virtual-machine:&#x2F;$ netstat -nr</span><br><span class="line">内核 IP 路由表</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG        0 0          0 ens33</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 ens33</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 ens33</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chenzhan@chenzhan-virtual-machine:&#x2F;$ ifconfig ens33</span><br><span class="line">ens33     Link encap:以太网  硬件地址 00:0c:29:f7:fa:d7  </span><br><span class="line">          inet 地址:192.168.1.242  广播:192.168.1.255  掩码:255.255.255.0</span><br><span class="line">          inet6 地址: 2409:8955:6d8:de9:297e:a328:e294:7db2&#x2F;64 Scope:Global</span><br><span class="line">          inet6 地址: fe80::5d6a:3ff1:9168:b741&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  跃点数:1</span><br><span class="line">          接收数据包:235 错误:0 丢弃:0 过载:0 帧数:0</span><br><span class="line">          发送数据包:284 错误:0 丢弃:0 过载:0 载波:0</span><br><span class="line">          碰撞:0 发送队列长度:1000 </span><br><span class="line">          接收字节:30015 (30.0 KB)  发送字节:26084 (26.0 KB)</span><br><span class="line"></span><br><span class="line">chenzhan@chenzhan-virtual-machine:&#x2F;$ ping -b 192.168.1.255</span><br><span class="line">WARNING: pinging broadcast address</span><br><span class="line">PING 192.168.1.255 (192.168.1.255) 56(84) bytes of data.</span><br></pre></td></tr></table></figure><p>1.2 测试TCP时间获取客户程序，以不同IP地址作为命令行参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ .&#x2F;ONE 127.0.0.1</span><br><span class="line">14 JUL 2021 22:05:17 CST</span><br><span class="line"></span><br><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ .&#x2F;ONE 192.168.1.54</span><br><span class="line">connect error: No route to host</span><br><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ .&#x2F;ONE 127.5.5.5</span><br><span class="line">14 JUL 2021 22:06:32 CST</span><br></pre></td></tr></table></figure><p>1.3 改socket的第一参数为9999，结果？找出所输出出错的errno值。如何找到更多？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ vi daytimetcpcli.c </span><br><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ gcc daytimetcpcli.c -o ONE -lunp</span><br><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ .&#x2F;ONE  127.0.0.1</span><br><span class="line">socket error: Address family not supported by protocol</span><br><span class="line"></span><br><span class="line">应该是Socket包裹函数，err_sys</span><br><span class="line"></span><br><span class="line">man socket&#x2F;error</span><br><span class="line">或者</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">    if ( (sockfd &#x3D; socket(9999, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">perror(“socket error”);</span><br><span class="line"></span><br><span class="line">socket error: Address family not supported by protocol</span><br><span class="line">connect error: Bad file descriptor</span><br></pre></td></tr></table></figure><p>1.4 加一个计数器，返回read大于零的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0;</span><br><span class="line">while(...)&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">printf(&quot;%d\n&quot;,sum);</span><br><span class="line">exit(0);</span><br><span class="line"></span><br><span class="line">16 JUL 2021 09:43:22 CST</span><br><span class="line">1</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;1.1 找出自己的网络拓扑的信息&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="网络编程" scheme="https://www.chenzhan.club/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>note49.6-深入探究文件I/O</title>
    <link href="https://www.chenzhan.club/2021/07/13/note49-6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6%E6%96%87%E4%BB%B6I-O/"/>
    <id>https://www.chenzhan.club/2021/07/13/note49-6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6%E6%96%87%E4%BB%B6I-O/</id>
    <published>2021-07-13T09:02:53.000Z</published>
    <updated>2021-07-19T08:26:20.979Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>硬盘的最小存储单位叫做“扇区”（Sector），每个扇区储存 512 字节（相当于 0.5KB）</p><p>由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是 4KB，即连续八个 sector 组成一个 block</p><p>磁盘在进行分区、格式化的时候会将其分为两个区域，一个是数据区，用于存储文件中的数据；另一个是 inode 区，用于存放 inode table（inode 表），inode table 中存放的是一个一个的 inode（也成为 inode节点），不同的 inode 就可以表示不同的文件，每一个文件都必须对应一个 inode，inode 实质上是一个结构体，这个结构体中有很多的元素，不同的元素记录了文件了不同信息，譬如文件字节大小、文件所有者、文件对应的读/写/执行权限、文件时间戳（创建时间、更新时间等）、文件类型、文件数据存储的 block（块）位置等等信息</p><p><strong>通过”ls -i”命令查看文件的 inode 编号</strong>（还可以使用 stat 命令查看）</p><p>打开一个文件，系统内部会将这个过程分为三步：</p><ol><li><p>系统找到这个文件名所对应的 inode 编号；</p></li><li><p>通过 inode 编号从 inode table 中找到对应的 inode 结构体；</p></li><li><p>根据 inode 结构体中记录的信息，确定文件数据所在的 block，并读出数据。</p></li></ol><p>调用 open 函数去打开文件的时候，内核会申请一段内存（一段缓冲区），并且将静态文件的数据内容从磁盘这些存储设备中读取到内存中进行管理、缓存（也把内存中的这份文件数据叫做动态文件、内核缓冲区）。打开文件后，以后对这个文件的读写操作，都是针对内存中这一份动态文件进行相关的操作，而并不是针对磁盘中存放的静态文件</p><p>当对动态文件进行读写操作后，此时内存中的动态文件和磁盘设备中的静态文件就不同步了，数据的同步工作由内核完成，内核会在之后将内存这份动态文件更新（同步）到磁盘设备中</p><p>在 Linux 系统中，内核会为每个进程设置一个专门的数据结构用于管理该进程，譬如用于记录进程的状态信息、运行特征等，我们把这个称为进程控制块（Process control block，缩写PCB）</p><p>PCB 数据结构体中有一个指针指向了文件描述符表（File descriptors），文件描述符表中的每一个元素索引到对应的文件表（File table），文件表也是一个数据结构体，其中记录了很多文件相关的信息，譬如文件状态标志、引用计数、当前文件的读写偏移量以及 i-node 指针（指向该文件对应的 inode）等，进程打开的所有文件对应的文件描述符都记录在文件描述符表中，每一个文件描述符都会指向一个对应的文件表</p><p>Linux 系统下对常见的错误做了一个编号，每一个编号都代表着每一种不同的错误类型，当函数执行发生错误的时候，操作系统会将这个错误所对应的编号赋值给 errno 变量，每一个进程（程序）都维护了自己的 errno 变量，它是程序中的全局变量，该变量用于存储就近发生的函数执行错误编号，也就意味着下一次的错误码会覆盖上一次的错误码</p><p>通过 man 手册便可以查到一个函数出错时系统是否会设置 errno</p><p>只需要在我们程序当中包含**&lt;errno.h&gt;**头文件即可获取系统所维护的这个errno变量</p><p>**strerror()**，该函数可以将对应的 errno 转换成适合我们查看的字符串信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char *strerror(int errnum);</span><br></pre></td></tr></table></figure><p>可以使用 <strong>perror</strong> 函数来查看错误信息，一般用的最多的还是这个函数，调用此函数不需要传入 errno，函数内部会自己去获取 errno 变量的值，调用此函数会直接将错误提示字符串打印出来，而不是返回字符串，除此之外还可以在输出的错误提示字符串之前加入自己的打印信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void perror(const char *s);</span><br></pre></td></tr></table></figure><p>在 Linux 系统下，进程（程序）退出可以分为正常退出和异常退出</p><p>在 Linux 系统下，进程正常退出除了可以使用 return 之外，还可以使用 exit()、_exit()以及_Exit()</p><p>main 函数中使用 return 后返回，return 执行后把控制权交给调用函数，结束该进程。调用_exit()函数会清除其使用的内存空间，并销毁其在内核中的各种数据结构，关闭进程的所有文件描述符，并结束进程、将控制权交给操作系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure><p>调用函数需要传入 status 状态标志，0 表示正常结束、若为其它值则表示程序执行过程中检测到有错误发生，_exit()和_Exit()两者等价，用法作用是一样的</p><p>exit()函数_exit()函数都是用来终止进程的，exit()是一个标准 C 库函数，而_exit()和_Exit()是系统调用。</p><p>执行 exit()会执行一些清理工作，最后调用_exit()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure><p><strong>空洞文件</strong>对多线程共同操作文件是及其有用的</p><p><strong>一个进程内多次</strong> <strong>open</strong> <strong>打开同一个文件，那么会得到多个不同的文件描述符 fd，同理在关闭文件的时候也需要调用 close 依次关闭各个文件描述符。</strong></p><p>子进程会继承父进程的文件描述符</p><p><strong>一个进程内多次</strong> <strong>open</strong> <strong>打开同一个文件，在内存中并不会存在多份动态文件</strong></p><p>当调用 open 函数的时候，会将文件数据（文件内容）从磁盘等块设备读取到内存中，将文件数据在内存中进行维护，内存中的这份文件数据我们就把它称为动态文件</p><p><strong>一个进程内多次</strong> <strong>open</strong> <strong>打开同一个文件，不同文件描述符所对应的读写位置偏移量是相互独立的</strong></p><p>Tips：多个不同的进程中调用 open()打开磁盘中的同一个文件，同样在内存中也只是维护了一份动态文件，多个进程间共享，它们有各自独立的文件读写位置偏移量。动态文件何时被关闭呢？当文件的引用计数为 0 时，系统会自动将其关闭，同一个文件被打开多次，文件表中会记录该文件的引用计数</p><p>在 Linux 系统中，open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新的文件描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，复制得到的文件描述符和旧的文件描述符拥有相同的权限，<strong>可以使用 dup 或 dup2 这两个系统调用对文件描述符进行复制</strong>，在使用完毕之后也需要使用 close 来关闭文件描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd);</span><br></pre></td></tr></table></figure><p>dup 系统调用分配的文件描述符是由系统分配的，遵循文件描述符分配原则，并不能自己指定一个文件描述符，这是 dup 系统调用的一个缺陷；而 dup2 系统调用修复了这个缺陷，可以手动指定文件描述符，而不需要遵循文件描述符分配原则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup2(int oldfd, int newfd);</span><br></pre></td></tr></table></figure><p>可以对同一个文件描述符 fd 调用 dup 或 dup2 函数复制多次，得到多个不同的文件描述符文件共享指的是同一个文件（譬如磁盘上的同一个文件，对应同一个 inode）被多个独立的读写体同时进行 IO 操作。多个独立的读写体大家可以将其简单地理解为对应于同一个文件的多个不同的文件描述符</p><p><strong>常见的三种文件共享的实现方式</strong></p><p><strong>同一个进程中多次调用</strong> <strong>open</strong> <strong>函数打开同一个文件</strong></p><p>多次调用 open 函数打开同一个文件会得到多个不同的文件描述符，并且多个文件描述符对应多个不同的文件表，所有的文件表都索引到了同一个 inode 节点，也就是磁盘上的同一个文件</p><p><strong>不同进程中分别使用</strong> <strong>open</strong> <strong>函数打开同一个文件</strong></p><p>进程 1 和进程 2 分别是运行在 Linux 系统上两个独立的进程（理解为两个独立的程序），在他们各自的程序中分别调用 open 函数打开同一个文件，进程 1 对应的文件描述符为 fd1，进程 2 对应的文件描述符为fd2，fd1 指向了进程 1 的文件表 1，fd2 指向了进程 2 的文件表 2；各自的文件表都索引到了同一个 inode 节 点，从而实现共享文件</p><p><strong>同一个进程中通过 dup（dup2）函数对文件描述符进行复制</strong></p><p><strong>竞争冒险</strong></p><p><strong>O_APPEND</strong> <strong>实现原子操作</strong></p><p><strong>pread()**</strong>和** <strong>pwrite()</strong></p><p>调用 pread 相当于调用 lseek 后再调用 read</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t pread(int fd, void *buf, size_t count, off_t offset);</span><br><span class="line">ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);</span><br></pre></td></tr></table></figure><p>：O_EXCL 可以用于测试一个文件是否存在，如果不存在则创建此文件，如果存在则返回错误，这使得测试和创建两者成为一个原子操作</p><p>fcntl()函数可以对一个已经打开的文件描述符执行一系列控制操作，譬如复制一个文件描述符（与 dup、dup2 作用相同）、获取/设置文件描述符标志、获取/设置文件状态标志等，类似于一个多功能文件描述符管理工具箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int fcntl(int fd, int cmd, ... &#x2F;* arg *&#x2F; )</span><br></pre></td></tr></table></figure><p>ioctl()可以认为是一个文件 IO 操作的杂物箱，可以处理的事情非常杂、不统一，一般用于操作特殊文件或硬件外设</p><p>使用系统调用 truncate()或 ftruncate()可将普通文件截断为指定字节长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">int truncate(const char *path, off_t length);</span><br><span class="line">int ftruncate(int fd, off_t length);</span><br></pre></td></tr></table></figure><p>ftruncate()使用文件描述符 fd 来指定目标文件，而 truncate()则直接使用文件路径 path 来指定目标文件</p><p>将文件截断为参数 length 指定的字节长度，如果文件目前的大小大于参数 length 所指定的大小，则多余的数据将被丢失，类似于多余的部分被“砍”掉了；如果文件目前的大小小于参数 length 所指定的大小，则将其进行扩展，对扩展部分进行读取将得到空字节”\0”</p><p>使用 ftruncate()函数进行文件截断操作之前，必须调用 open()函数打开该文件得到文件描述符，并且必须要具有可写权限，也就是调用 open()打开文件时需要指定 O_WRONLY 或 O_RDWR</p><p>调用这两个函数并不会导致文件读写位置偏移量发生改变，所以截断之后一般需要重新设置文件当前的读写位置偏移量，以免由于之前所指向的位置已经不存在而发生错误</p><p>调用成功返回 0，失败将返回-1，并设置 errno 以指示错误原因</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;硬盘的最小存储单位叫做“扇区”（Sector），每个扇区储存 512 字节（相当于 0.5KB）&lt;/p&gt;
&lt;p&gt;由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note48.6-文件IO</title>
    <link href="https://www.chenzhan.club/2021/07/13/note48-6-%E6%96%87%E4%BB%B6IO/"/>
    <id>https://www.chenzhan.club/2021/07/13/note48-6-%E6%96%87%E4%BB%B6IO/</id>
    <published>2021-07-13T01:21:58.000Z</published>
    <updated>2021-08-05T02:59:55.338Z</updated>
    
    <content type="html"><![CDATA[<pre><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code></pre><blockquote><p>hexdump -C 以16进制的方式查看文件</p><p>^@ 表示 0</p><p>Linux 下的 off_t类型用于指示文件的偏移量</p><p>time  ./xxx 能看出执行时间 real(实际时间) = user(用户时间) + sys(系统时间)</p><p>标准IO 执行时间少于系统IO， 因为缓冲区优化，减少系统调用的次数，降低在用户态和内核态之间切换的频率，（写一个字调用一百万次和写十万个数在调用10次的区别）</p><p>setbuf 关闭和打开缓冲区</p><p>dup 复制文件描述符 </p><p>两次open 有两个独立的文件表项，读写位置独立，open再dup共享一个文件表项，文件读写位置一个</p><p>fcntl() 文件控制 </p></blockquote><p>​        C 语言库是应用层使用的一套函数库，在 Linux 下，通常以动态（.so）库文件的形式提供，存放在根文件系统/lib 目录下，C 语言库函数构建于系统调用之上，也就是说库函数其实是由系统调用封装而来的，是以动态库文件的形式提供的，通常存放在/lib 目录，它的命名方式通常是libc.so.6，不过这个是一个软链接文件，它会链接到真正的库文件</p><p>​        在 Linux 系 统 下 ， 使 用 的 C 语 言 库 为 GNU C 语 言 函 数 库 （ 也 叫 作 glibc ）</p><h3 id="open-打开文件"><a href="#open-打开文件" class="headerlink" title="open 打开文件"></a><strong>open</strong> <strong>打开文件</strong></h3><p><strong>文件描述符</strong></p><p>​        调用 open 函数会有一个返回值，在 open函数执行成功的情况下，会返回一个非负整数，该返回值就是一个文件描述符（file descriptor），这说明文件描述符是一个非负整数；对于 Linux 内核而言，所有打开的文件都会通过文件描述符进行索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 打开目标文件 dest_file(只写方式) *&#x2F;</span><br><span class="line">fd2 &#x3D; open(&quot;.&#x2F;dest_file&quot;, O_WRONLY);</span><br><span class="line">if (-1 &#x3D;&#x3D; fd2) &#123;</span><br><span class="line">ret &#x3D; fd2;</span><br><span class="line">goto out1;</span><br><span class="line">&#125;</span><br><span class="line">out1:</span><br><span class="line">&#x2F;* 关闭源文件 *&#x2F;</span><br><span class="line">close(fd1);</span><br><span class="line">return ret; &#125;</span><br></pre></td></tr></table></figure><p>​        当调用 open 函数打开一个现有文件或创建一个新文件时，内核会向进程返回一个文件描述符，<strong>用于指代被打开的文件</strong>，所有执行 IO 操作的系统调用都是通过文件描述符来索引到对应的文件</p><p>​        一个进程可以打开多个文件，但是在 Linux 系统中，一个进程可以打开的文件数是有限制，文件越大、打开的文件越多那占用的内存就越多，必然会对整个系统造成很大的影响，如果超过进程可打开的最大文件数限制，内核将会发送警告信号给对应的进程，然后结束进程；在 Linux 系统下，我们可以通过 ulimit 命令来查看进程可打开的最大文件数</p><p>​        所以对于一个进程来说，文件描述符是一种有限资源，文件描述符是从 0 开始分配的，每一个被打开的文件在同一个进程中都有一个唯一的文件描述符，不会重复，如果文件被关闭后，它对应的文件描述符将会被<strong>释放</strong>，那么这个文件描述符将可以再次分配给其它打开的文件、与对应的文件绑定起来</p><p>​        每次给打开的文件分配文件描述符都是从最小的没有被使用的文件描述符（如果Ulimit -n 查看得到的数值是1024 ，则是文件描述符共有 0~1023）开始</p><p>​        调用 open 函数打开文件的时候，分配的文件描述符一般都是<strong>从 3 开始</strong>，但是 0、1、2 这三个文件描述符已经默认被系统占用了，分别分配给了系统标注输入（0）、标注输出（1）以及标准错误（2）</p><p>​        标准输入一般对应的是键盘，可以理解为 0 便是打开键盘对应的设备文件时所得到的文件描述符；标准输出一般指的是 LCD 显示器，可以理解为 1 便是打开 LCD 设备对应的设备文件时所得到的文件描述符</p><p>​        在 Linux 系统下，可以通过 man 命令（也叫 man 手册）来查看某一个 Linux 系统调用的帮助信息，man命令可以将该系统调用的详细信息显示出来，譬如函数功能介绍、函数原型、参数、返回值以及使用该函数所需包含的头文件等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man 2 open #查看 open 函数的帮助信息</span><br><span class="line"></span><br><span class="line">man man #查看 man 函数的帮助信息</span><br></pre></td></tr></table></figure><p>​        Tips：man 命令后面跟着两个参数，数字 2 表示系统调用，man 命令除了可以查看系统调用的帮助信息外，还可以查看 Linux 命令（对应数字 1）以及标准 C 库函数（对应数字 3）所对应的帮助信息；最后一个参数 open 表示需要查看的系统调用函数名。</p><p>​        在应用程序中使用 open 函数时，需要包含 3 个头文件“#include &lt;sys/types.h&gt;”、“#include &lt;sys/stat.h&gt;”、“#include &lt;fcntl.h&gt;”</p><p><strong>函数参数和返回值含义如下：</strong></p><p>​        <strong>pathname：</strong>字符串类型，用于标识需要打开或创建的文件，可以包含路径（绝对路径或相对路径）信息，譬如：”./src_file”（当前目录下的 src_file 文件）、”/home/dengtao/hello.c”等；如果 pathname 是一个符号链接，会对其进行解引用。</p><p>​        <strong>flags：</strong>调用 open 函数时需要提供的标志，包括文件访问模式标志以及其它文件相关标志，这些标志使用宏定义进行描述，都是常量，open 函数提供了非常多的标志，我们传入 flags 参数时既可以单独使用某一个标志，也可以通过位或运算（|）将多个标志进行组合。</p><p>​        open 函数 flags 参数值介绍</p><table><thead><tr><th>标志</th><th>用途</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>以只读方式打开文件</td></tr><tr><td>O_WRONLY</td><td>以只写方式打开文件</td></tr><tr><td>O_RDWR</td><td>以可读可写方式打开文件</td></tr></tbody></table><p>​        这三个是文件访问权限标志，传入的flags 参数中必须要包含其中一种标志，而且只能包含一种，打开的文件只能按照这种权限来操作，譬如使用了 O_RDONLY 标志，就只能对文件进行读取操作，不能写操作。</p><table><thead><tr><th>O_CREAT</th><th>如果 pathname 参数指向的文件不存在则创建</th></tr></thead></table><p>​        使用此标志时，调用 open 函数需要传入第 3 个参数 mode，参数 mode 用 于指定新建文件的访问权限，稍后将对此进行说明。<strong>open 函数的第 3 个参数只有在使用了 O_CREAT 或 O_TMPFILE标志时才有效。</strong></p><table><thead><tr><th>O_DIRECTORY</th><th>O_EXCL</th><th>O_NOFOLLOW</th></tr></thead></table><p>​        Tips：不同内核版本所支持的 flags 标志是存在差别的，man 手册中对一些标志支持有简单地说明flags 参数时既可以单独使用某一个标志，也可以通过位或运算（|）将多个标志进行组合，譬如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;.&#x2F;src_file&quot;, O_RDONLY) &#x2F;&#x2F;单独使用某一个标志</span><br><span class="line">open(&quot;.&#x2F;src_file&quot;, O_RDONLY | O_NOFOLLOW) &#x2F;&#x2F;多个标志组合</span><br></pre></td></tr></table></figure><p>​        <strong>mode**</strong>：**此参数用于指定新建文件的访问权限，只有当 flags 参数中包含 O_CREAT 或 O_TMPFILE 标志时才有效（O_TMPFILE 标志用于创建一个临时文件）。权限对于文件来说是一个很重要的属性，那么在 Linux系统中，我们可以通过 touch 命令新建一个文件，此时文件会有一个默认的权限，如果需要修改文件权限，可通过 chmod 命令对文件权限进行修改，譬如在 Linux 系统下我们可以使用”ls -l”命令来查看到文件所对应的权限。</p><p>​        当我们调用 open 函数去新建一个文件时，也需要指定该文件的权限，而 mode 参数便用于指定此文件的权限，接下来看看我们该如何通过 mode 参数来表示文件的权限，首先 mode 参数的类型是 mode_t，这是一个 u32 无符号整形数据，权限表示方法如下所示：</p><blockquote><p>0000        000(S)        000(U)        000(G)        000(O)</p></blockquote><p>O—这 3 个 bit 位用于表示其他用户的权限；</p><p>G—这 3 个 bit 位用于表示同组用户（group）的权限，即与文件所有者有相同组 ID 的所有用户；</p><p>U—这 3 个 bit 位用于表示文件所属用户的权限，即文件或目录的所属者； </p><p>S—这 3 个 bit 位用于表示文件的特殊权限，文件特殊权限一般用的比较少。</p><p>​        3 个 bit 位中，按照 rwx 顺序来分配权限位（特殊权限除外），最高位（权值为 4）表示读权限，为 1 时表示具有读权限，为 0 时没有读权限；中间位（权值为 2）表示写权限，为 1 时表示具有写权限，为 0 时没有写权限；最低位（权值为 1）表示执行权限，为 1 时表示具有可执行权限，为 0 时没有执行权限</p><blockquote><p>最高权限表示方法：111111111（二进制表示）、777（八进制表示）、511（十进制表示）；</p><p>最高权限这里意味着所有用户对此文件都具有读权限、写权限以及执行权限。</p><p>111000000（二进制表示）：表示文件所属者具有读、写、执行权限，而同组用户和其他用户不具有任何权限；</p><p>100100100（二进制表示）：表示文件所属者、同组用户以及其他用户都具有读权限，但都没有写、执行权限。</p></blockquote><p>​        Tips：只有用户对该文件具有相应权限时，才可以使用对应的标志去打开文件，否则会打开失败！</p><p>​        在实际编程中，我们可以直接使用 Linux 中已经定义好的宏，不同的宏定义表示不同的权限，如下所示：</p><table><thead><tr><th>宏定义</th><th>说明</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>允许文件所属者读文件</td></tr><tr><td>S_IWUSR</td><td>允许文件所属者写文件</td></tr><tr><td>S_IXUSR</td><td>允许文件所属者执行文件</td></tr><tr><td>S_IRWXU</td><td>允许文件所属者读、写、执行文件</td></tr><tr><td>S_IRGRP</td><td>允许同组用户读文件</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>​        这些宏既可以单独使用，也可以通过位或运算将多个宏组合在一起，譬如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_IRUSR | S_IWUSR | S_IROTH</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong>成功将返回文件描述符，文件描述符是一个非负整数；失败将返回-1。</p><p><strong>open</strong> <strong>函数使用示例</strong></p><p>​        (1)使用 open 函数打开一个已经存在的文件（例如当前目录下的 app.c 文件），使用只读方式打开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fd &#x3D; open(&quot;.&#x2F;app.c&quot;, O_RDONLY)</span><br><span class="line">if (-1 &#x3D;&#x3D; fd)</span><br><span class="line">return fd;</span><br></pre></td></tr></table></figure><p>​        (2)使用 open 函数打开一个已经存在的文件（例如当前目录下的 app.c 文件），使用可读可写方式打开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fd &#x3D; open(&quot;.&#x2F;app.c&quot;, O_RDWR)</span><br><span class="line">if (-1 &#x3D;&#x3D; fd)</span><br><span class="line">return fd;</span><br></pre></td></tr></table></figure><p>​        (3)使用 open 函数打开一个指定的文件（譬如/home/dengtao/hello），使用可读可写方式,如果该文件是一个符号链接文件，则不对其进行解引用，直接返回错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fd &#x3D; open(&quot;&#x2F;home&#x2F;dengtao&#x2F;hello&quot;, O_RDWR | O_NOFOLLOW);</span><br><span class="line">if (-1 &#x3D;&#x3D; fd)</span><br><span class="line">return fd;</span><br></pre></td></tr></table></figure><p>​        (4)使用 open 函数打开一个指定的文件（譬如/home/dengtao/hello），如果该文件不存在则创建该文件，创建该文件时，将文件权限设置如下：</p><p>文件所属者拥有读、写、执行权限；同组用户与其他用户只有读权限。使用可读可写方式打开： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fd &#x3D; open(&quot;&#x2F;home&#x2F;dengtao&#x2F;hello&quot;, O_RDWR | O_CREAT, S_IRWXU | S_IRGRP | S_IROTH);</span><br><span class="line">if (-1 &#x3D;&#x3D; fd)</span><br><span class="line">return fd;</span><br></pre></td></tr></table></figure><h3 id="其它文件IO"><a href="#其它文件IO" class="headerlink" title="其它文件IO"></a>其它文件IO</h3><p><strong>write</strong> <strong>写文件</strong></p><p>​        调用 write 函数可向打开的文件写入数据，其函数原型如下所示（可通过”man 2 write”查看）：        首先使用 write 函数需要先包含 unistd.h 头文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br></pre></td></tr></table></figure><p><strong>read</strong> <strong>读文件</strong></p><p>​        调用 read 函数可从打开的文件中读取数据，其函数原型如下所示（可通过”man 2 read”查看）：</p><p>​        首先使用 read 函数需要先包含 unistd.h 头文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br></pre></td></tr></table></figure><p><strong>close</strong> <strong>关闭文件</strong></p><p>​        可调用 close 函数关闭一个已经打开的文件，其函数原型如下所示（可通过”man 2 close”查看）：</p><p>​        首先使用 close 函数需要先包含 unistd.h 头文件，当我们对文件进行 IO 操作完成之后，后续不再对文件进行操作时，需要将文件关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure><p><strong>lseek</strong></p><p>​        对于每个打开的文件，系统都会记录它的读写位置偏移量，我们也把这个读写位置偏移量称为读写偏移量，记录了文件当前的读写位置，当调用 read()或 write()函数对文件进行读写操作时，就会从当前读写位置偏移量开始进行数据读写。</p><p>​        读写偏移量用于指示 read()或 write()函数操作时文件的起始位置，会以相对于文件头部的位置偏移量来表示，文件第一个字节数据的位置偏移量为 0。</p><p>​        当打开文件时，会将读写偏移量设置为指向文件开始位置处，以后每次调用 read()、write()将自动对其进行调整，以指向已读或已写数据后的下一字节，因此，连续的调用 read()和 write()函数将使得读写按顺序递增，对文件进行操作。我们先来看看 lseek 函数的原型，如下所示（可通过”man 2 lseek”查看）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br></pre></td></tr></table></figure><hr><p>参考资料：正点原子《【正点原子】I.MX6U嵌入式Linux C应用编程指南V1.0》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;referrer&amp;quot; content=&amp;quot;no-referrer&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;hexdump -C 以16进制的方式查看文件&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note47.8-STL初识</title>
    <link href="https://www.chenzhan.club/2021/07/11/note47-8-STL%E5%88%9D%E8%AF%86/"/>
    <id>https://www.chenzhan.club/2021/07/11/note47-8-STL%E5%88%9D%E8%AF%86/</id>
    <published>2021-07-11T15:47:00.000Z</published>
    <updated>2021-07-19T08:26:50.351Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h2><h3 id="STL的诞生"><a href="#STL的诞生" class="headerlink" title="STL的诞生"></a>STL的诞生</h3><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="STL中容器、算法、迭代器"><a href="#STL中容器、算法、迭代器" class="headerlink" title="STL中容器、算法、迭代器"></a>STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​    <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​    <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p><strong>算法：</strong>问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.begin();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pBegin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.begin(), v.end(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>vector中存放自定义数据类型，并打印输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">mName = name;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> mName;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(&amp;p1);</span><br><span class="line">v.push_back(&amp;p2);</span><br><span class="line">v.push_back(&amp;p3);</span><br><span class="line">v.push_back(&amp;p4);</span><br><span class="line">v.push_back(&amp;p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">Person * p = (*it);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">    </span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vector容器嵌套容器"><a href="#Vector容器嵌套容器" class="headerlink" title="Vector容器嵌套容器"></a>Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">v2.push_back(i + <span class="number">2</span>);</span><br><span class="line">v3.push_back(i + <span class="number">3</span>);</span><br><span class="line">v4.push_back(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line">v.push_back(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>资料来源：黑马程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h2 id=&quot;STL初识&quot;&gt;&lt;a href=&quot;#STL初识&quot; class=&quot;headerlink&quot; title=&quot;STL初识&quot;&gt;&lt;/a&gt;STL初识&lt;/h2&gt;&lt;h3 id=&quot;STL的诞生&quot;</summary>
      
    
    
    
    
    <category term="C++" scheme="https://www.chenzhan.club/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>note46.8-类和对象-多态</title>
    <link href="https://www.chenzhan.club/2021/07/11/note46-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/"/>
    <id>https://www.chenzhan.club/2021/07/11/note46-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</id>
    <published>2021-07-11T15:46:14.000Z</published>
    <updated>2021-07-19T08:27:26.084Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">DoSpeak(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line">DoSpeak(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;func();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Animal()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~Animal() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat(<span class="built_in">string</span> name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> Cat(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;Speak();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​    3. 拥有纯虚析构函数的类也属于抽象类</p><hr><p>资料：黑马程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h3&gt;&lt;h4 id=&quot;多态的基本概念&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="C++" scheme="https://www.chenzhan.club/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>note45.8-类和对象-继承</title>
    <link href="https://www.chenzhan.club/2021/07/11/note45-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.chenzhan.club/2021/07/11/note45-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/</id>
    <published>2021-07-11T15:42:15.000Z</published>
    <updated>2021-07-19T08:28:15.133Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Java ja;</span><br><span class="line">ja.header();</span><br><span class="line">ja.footer();</span><br><span class="line">ja.left();</span><br><span class="line">ja.content();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Python py;</span><br><span class="line">py.header();</span><br><span class="line">py.footer();</span><br><span class="line">py.left();</span><br><span class="line">py.content();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.header();</span><br><span class="line">cp.footer();</span><br><span class="line">cp.left();</span><br><span class="line">cp.content();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Java ja;</span><br><span class="line">ja.header();</span><br><span class="line">ja.footer();</span><br><span class="line">ja.left();</span><br><span class="line">ja.content();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Python py;</span><br><span class="line">py.header();</span><br><span class="line">py.footer();</span><br><span class="line">py.left();</span><br><span class="line">py.content();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.header();</span><br><span class="line">cp.footer();</span><br><span class="line">cp.left();</span><br><span class="line">cp.content();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B; </p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p>![img](D:/C++学习资料/匠心精作C++从0到1入门编程-学习编程不再难资料/第3阶段-C++核心编程 资料/讲义/assets/clip_image002.png)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>:</span><span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>:</span><span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandSon3</span> :</span><span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Son) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><p>![1545881904150](D:/C++学习资料/匠心精作C++从0到1入门编程-学习编程不再难资料/第3阶段-C++核心编程 资料/讲义/assets/1545881904150.png)</p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p>![1545882158050](D:/C++学习资料/匠心精作C++从0到1入门编程-学习编程不再难资料/第3阶段-C++核心编程 资料/讲义/assets/1545882158050.png)</p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s.func();</span><br><span class="line">s.Base::func();</span><br><span class="line">s.Base::func(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Son s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Son s;</span><br><span class="line">s.func();</span><br><span class="line">s.Base::func();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Son::func();</span><br><span class="line">Son::Base::func();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::func(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base1()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base2()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line"><span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.Base1::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.Base2::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​    两个派生类继承同一个基类</p><p>​    又有某个类同时继承者两个派生类</p><p>​    这种继承被称为菱形继承，或者钻石继承</p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span>   :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><hr><p>资料来源：黑马程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;继承是面向对象三大特性之一&lt;/s</summary>
      
    
    
    
    
    <category term="C++" scheme="https://www.chenzhan.club/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>note44.8-类和对象-友元和运算符重载</title>
    <link href="https://www.chenzhan.club/2021/07/11/note44-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%8F%8B%E5%85%83%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>https://www.chenzhan.club/2021/07/11/note44-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%8F%8B%E5%85%83%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2021-07-10T16:25:20.000Z</published>
    <updated>2021-07-19T08:28:58.632Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span><br><span class="line">friend void goodGay(Building * building);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Building()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">string m_BedRoom; &#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void goodGay(Building * building)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Building b;</span><br><span class="line">goodGay(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">goodGay();</span><br><span class="line">void visit();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">friend class goodGay;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Building();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line">private:</span><br><span class="line">string m_BedRoom;&#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay()</span><br><span class="line">&#123;</span><br><span class="line">building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.visit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">goodGay();</span><br><span class="line">void visit(); &#x2F;&#x2F;只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br><span class="line">void visit2(); </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span><br><span class="line">friend void goodGay::visit();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Building();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line">private:</span><br><span class="line">string m_BedRoom;&#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay()</span><br><span class="line">&#123;</span><br><span class="line">building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">goodGay  gg;</span><br><span class="line">gg.visit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;&#125;;</span><br><span class="line">Person(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_A &#x3D; a;</span><br><span class="line">this-&gt;m_B &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;成员函数实现 + 号运算符重载</span><br><span class="line">Person operator+(const Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A &#x3D; this-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B &#x3D; this-&gt;m_B + p.m_B;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">int m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局函数实现 + 号运算符重载</span><br><span class="line">&#x2F;&#x2F;Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span><br><span class="line">&#x2F;&#x2F;Person temp(0, 0);</span><br><span class="line">&#x2F;&#x2F;temp.m_A &#x3D; p1.m_A + p2.m_A;</span><br><span class="line">&#x2F;&#x2F;temp.m_B &#x3D; p1.m_B + p2.m_B;</span><br><span class="line">&#x2F;&#x2F;return temp;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运算符重载 可以发生函数重载 </span><br><span class="line">Person operator+(const Person&amp; p2, int val)  </span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A &#x3D; p2.m_A + val;</span><br><span class="line">temp.m_B &#x3D; p2.m_B + val;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">Person p1(10, 10);</span><br><span class="line">Person p2(20, 20);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数方式</span><br><span class="line">Person p3 &#x3D; p2 + p1;  &#x2F;&#x2F;相当于 p2.operaor+(p1)</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person p4 &#x3D; p3 + 10; &#x2F;&#x2F;相当于 operator+(p3,10)</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote></blockquote><h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Person(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_A &#x3D; a;</span><br><span class="line">this-&gt;m_B &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span><br><span class="line">&#x2F;&#x2F;void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int m_A;</span><br><span class="line">int m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局函数实现左移重载</span><br><span class="line">&#x2F;&#x2F;ostream对象只能有一个</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;</span><br><span class="line">return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">Person p1(10, 20);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#x2F;&#x2F;链式编程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyInteger() &#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="comment">//先++</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="comment">//再返回</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line"><span class="comment">//先返回</span></span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">out &lt;&lt; myint.m_Num;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myInt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ++myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyInteger myInt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myInt++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="keyword">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int a = 0;</span></span><br><span class="line"><span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a != b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; text &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">MyPrint myFunc;</span><br><span class="line">myFunc(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line"><span class="keyword">int</span> ret = add(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; MyAdd()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>资料来源：黑马程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h4 id=&quot;友元&quot;&gt;&lt;a href=&quot;#友元&quot; class=&quot;headerlink&quot; title=&quot;友元&quot;&gt;&lt;/a&gt;友元&lt;/h4&gt;&lt;p&gt;友元的关键字为  ==friend==&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="C++" scheme="https://www.chenzhan.club/tags/C/"/>
    
  </entry>
  
</feed>
