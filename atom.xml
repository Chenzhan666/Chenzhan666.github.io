<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHENZHAN</title>
  
  <subtitle>CHENZHAN</subtitle>
  <link href="https://www.chenzhan.club/atom.xml" rel="self"/>
  
  <link href="https://www.chenzhan.club/"/>
  <updated>2021-07-19T08:11:37.040Z</updated>
  <id>https://www.chenzhan.club/</id>
  
  <author>
    <name>Chenzhan666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>note56.9-Qt_Qt信号与槽</title>
    <link href="https://www.chenzhan.club/2021/07/19/note56-9-Qt-Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"/>
    <id>https://www.chenzhan.club/2021/07/19/note56-9-Qt-Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/</id>
    <published>2021-07-19T06:10:04.000Z</published>
    <updated>2021-07-19T08:11:37.040Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>Qt</strong> <strong>信号与槽机制</strong></p><p>​    信号与槽（Signal &amp; Slot）是 Qt 编程的基础，也是 Qt 的一大创新。因为有了信号与槽的编程机制，在 Qt 中处理界面各个组件的交互操作时变得更加直观和简单。</p><p>​    信号（Signal）就是在特定情况下被发射的事件，例如 PushButton (按键)最常见的信号就是鼠标单击时发射的 clicked() 信号，一个 ComboBox (组合框)最常见的信号是选择的列表项变化时发CurrentIndexChanged() (更改索引)信号。</p><p>​    槽（Slot）就是对信号响应的函数。槽就是一个函数，与一般的 C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。</p><p>​    信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</span><br></pre></td></tr></table></figure><p>​    connect() 是 QObject 类的一个静态函数，而 <strong>QObject 是所有 Qt 类的基类</strong>，在实际调用时可以忽略前面的限定符，所以可以直接写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</span><br></pre></td></tr></table></figure><p>​    sender 是发射信号的对象的名称，signal() 是信号名称。信号可以看做是特殊的函数，需要带括号，有参数时还需要指明参数。receiver 是接收信号的对象名称，slot() 是槽函数的名称，需要带括号，有参数时还需要指明参数。</p><p>​    SIGNAL 和 SLOT 是 Qt 的宏，用于指明信号和槽，并将它们的参数转换为相应的字符串。</p><p>​    在  ui_mainwindow.h 这个文件里的setupUi() 函数中有如下的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(pushButton, SIGNAL(clicked()), MainWindow, SLOT(close()));</span><br></pre></td></tr></table></figure><p>​    其作用就是将 pushButton 按钮的 clicked() 信号与窗体（MainWindow）的槽函数 close() 相关联，这样，当单击 pushButton 按钮（就是界面上的“X”按钮）时，就会执行 MainWindow的 close() 槽函数。</p><p><strong>关于信号与槽的使用，有以下一些规则需要注意：</strong></p><p><strong>一个信号可以连接多个槽</strong>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect(pushButton, SIGNAL(clicked()), this, SLOT(hide());</span><br><span class="line">connect(pushButton, SIGNAL(clicked()), this, SLOT(close());</span><br></pre></td></tr></table></figure><p>​    这是当一个对象 pushButton 的被单击时，所在窗体有两个槽进行响应，一个 hide()用于隐藏主窗体，一个 close 用于关闭主窗体。这里只是举个例子，实际上当执行 close()后，hide()这个槽已经没有什么意义了，因为已经程序退出了，但是实际它有执行，因为它连接在 close()的前面。当一个信号与多个槽函数关联时，槽函数按照建立连接时的顺序依次执行。</p><p>​    当信号和槽函数带有参数时，在 connect()函数里，要写明参数的类型，但可以不写参数名称。</p><p><strong>多个信号可以连接同一个槽</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connect(pushButton,SIGNAL(clicked()),this,SLOT(close()));</span><br><span class="line">connect(pushButton_2,SIGNAL(clicked()),this,SLOT(close()));</span><br><span class="line">connect(pushButton_3,SIGNAL(clicked()),this,SLOT(close()));</span><br></pre></td></tr></table></figure><p>​    这样，当任何一个 pushButton 被单击时，都会执行 close()函数，进而关闭或者退出程序。</p><p><strong>一个信号可以连接另外一个信号</strong>（说明了 connect 万物皆可连）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(pushButton,SIGNAL(objectNameChanged(QString)),this,SIGNAL(windowTitelChanged(QString)));</span><br></pre></td></tr></table></figure><p>​    这样，当一个信号发射时，也会发射另外一个信号，实现某些特殊的功能。</p><p>​    严格的情况下，信号与槽的参数个数和类型需要一致，至少信号的参数不能少于槽的参数。如果不匹配，会出现编译错误或运行错误。</p><p>​    在使用信号与槽的类中，必须在类的定义中加入宏 Q_OBJECT（特别重要）。</p><p>​    当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码。</p><p>​    总结，发送者与发送的信号是在一起的，接收者与接收的信号/槽是在一起的。它们不能在connect()方法里写乱顺序！由发送者发送出信号到接收者用信号/槽接收。</p><p>​    断开连接的方法，使用 disconnect()。disconnect()，这个方法重载了好几个函数，解开格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool QObject::disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)</span><br></pre></td></tr></table></figure><ul><li>断开一切与 myObject 连接的信号或槽。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(myObject, 0, 0, 0);</span><br></pre></td></tr></table></figure><p>​    相当于非静态重载函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject-&gt;disconnect();</span><br></pre></td></tr></table></figure><ul><li>断开所有连接到特定信号的东西。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(myObject, SIGNAL(mySignal()), 0, 0);</span><br></pre></td></tr></table></figure><p>​    相当于非静态重载函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject-&gt;disconnect(SIGNAL(mySignal()));</span><br></pre></td></tr></table></figure><ul><li>与指定的接收者断开连接。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(myObject, 0, myReceiver, 0);</span><br></pre></td></tr></table></figure><p>​    相当于非静态重载函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject-&gt;disconnect(myReceiver);</span><br></pre></td></tr></table></figure><p>​    信号与槽机制是 Qt GUI 编程的基础，使用信号与槽机制可以比较容易地将信号与响应代码关联起来。</p><p>​    信号只需声明，无需定义。</p><p>​    可以看到信号无需public 等关键字修饰。</p><p>​    创建槽的方法也很简单，也是直接在 mianwindow.h 里直接声明槽，在 mianwindow.cpp 里实现槽的定义，<strong>声明槽必须写槽的定义(定义指函数体的实现)，否则编译器编译时将会报错</strong>。</p><p><strong>槽有以下特点：</strong></p><ol><li>槽可以是任何成员函数、普通全局函数、静态函数</li><li>槽函数和信号的参数和返回值要一致</li></ol><p>信号槽连接的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect(pushButton, SIGNAL(clicked()), this, SLOT(pushButtonClicked()));</span><br><span class="line">connect(this, SIGNAL(pushButtonTextChanged()), this,SLOT(changeButtonText()));</span><br></pre></td></tr></table></figure><p>​    按住 Ctrl 键，再点击 clicked()，进入 clicked()这个信号的定义处。</p><p>​    返回上一步按 Alt + 方向左键</p><hr><p>参考文档：正点原子嵌入式Qt开发指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;strong&gt;Qt&lt;/strong&gt; &lt;strong&gt;信号与槽机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    信号与槽（Signal &amp;amp; Slot）是 Qt 编程的基础，也</summary>
      
    
    
    
    
    <category term="Qt" scheme="https://www.chenzhan.club/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>note55.9-Qt_Designer</title>
    <link href="https://www.chenzhan.club/2021/07/17/note55-9-Qt-Designer/"/>
    <id>https://www.chenzhan.club/2021/07/17/note55-9-Qt-Designer/</id>
    <published>2021-07-17T10:51:32.000Z</published>
    <updated>2021-07-19T08:15:00.772Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>基类</p><ul><li>QMainWindow：主窗口类，主窗口具有主菜单栏、工具栏和状态栏。类似于一般的应用程序的主窗口。如果您想做个嵌套的窗口程序开发的软件，不妨选择这个 QMainWindow。</li><li>QWidget：是可视界面类的基类，也就是说QMainWindow类也是由QWidget继承封装而来。所以 QWidget 要比 QMainWindow 功能少一些。</li><li>QDialog：对话框类，建立一个对话框界面。比较少使用此项作为基类。一般以 QMainWindow</li><li>和 QWidget 作为基类的居多。<u><strong>注因为 QWidget 不带窗口标题栏等，嵌入式里最好 QWidget。</strong></u></li></ul><p>活动项目的项目根节点都是用粗体字体表示的。如果打开了多个项目，那么我们只需要观察哪个是加粗的项目名就表示当前活动项目。</p><p>项目内的文件简介：</p><ul><li>01_hello_world.pro 是项目管理文件，这个项目管理文件十分重要，当您加入了文件或者删除了文件，Qt Creator 会自动修改这个* .pro 文件。有时候需要打开这个*.pro 文件添加我们的设置项。</li><li>Header 分组，这个节点下存放的是项目内所有的头文件*.h。 </li><li>Source 分组，这个节点下存放的是项目内的所有 C++源码文件*.cpp。 </li><li>Forms 分组，这个节点下是存放项目内所有界面文件* .ui。*.ui 文件由 XML 语言描述组成，编译时会生成相应的 cpp 文件，这样交叉编译器就可以编译它了。</li></ul><p>*<em>项目文件****</em>.pro**</p><p>core 与 gui 库是 Qt 的默认设置</p><p>SOURCES 下的是源文件</p><p>HEADERS 下是头文件</p><p>FORMS 下是 ui 界面文件</p><p>如果需要修改生成目标的可执行程序名字，可赋值 TARGET = xxx。否则 TARGET 将默认</p><p>取值为项目的名字。</p><p>*<em>样式文件****</em>.ui**</p><p>mainwindow.ui 是一个 xml 类型的文件，它的 xml 内容如下。这个文件是生成的不能手动编辑。只能够通过图形界面修改其属性。</p><p>①是控件栏，有各种各样的控件，上方的 Filter 是过滤器，输入首写字母就可以快速定到我们想要找的控件。</p><p>②显示的是我们的窗口程序了，上面已经带有 MainWindow 对象及其几个子对象，默认MainWindow 就带有菜单栏和状态栏。</p><p>③是对象栏，②处用到的对象都在③处显示。</p><p>④是属性栏，点击③处对象栏的某个对象，就可以在④属性栏里编辑它的属性了。属性项有很多，包括位置，大小，文字，颜色，字体等等。</p><p>*<em>头文件****</em>.h**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace Ui &#123; class MainWindow; &#125;</span><br></pre></td></tr></table></figure><p>定义名称空间 Ui ，里面有一个类 MainWindow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MainWindow(QWidget *parent &#x3D; nullptr);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个 class MainWindow 和上面 的 namespace Ui { class MainWindow; } 不是同一个对象。实际上，这个文件里的 namespace Ui { class MainWindow; }类有一个成员*ui 就是指 Ui::MainWindow 的指针。这都是为了使用.ui 文件设计界面的。</p><p>MainWindow 的声明中第一行是 Q_OBJECT，这是一个宏，由 Qt 进行处理，这也是 Qt 针对 C++扩展的地方，所有用到信号的类都要加这个宏。</p><p>*<em>源文件****</em>.cpp**</p><p>mainwindow.cpp</p><p>ui_mainwindow.h 这个文件是 Qt 根据.ui 文件自动生成的，也就是说 ui_mainwindow.h 要点击编构建后才生成，我们才能看到这个文件。构建/编译后可以在 debug/release 的目录找到这个文件。</p><p>在 MainWindow 构造函数中用“**,**”隔开，new 一个 Ui 中的 MainWindow。这里是一种初始化成员的方法。</p><p>ui-&gt;setupUi(this);这句话是进行界面初始化，将 this（指的是 MainWindow 类的本身），作为参数传到 setupUi 里，ui 界面文件的对象会以 this 为父对象，所有子对象都将显示在MainWindow 里。我们要想使用 ui 里的对象，必须将代码写在 ui-&gt;setupUi(this)这句话之后，因为 ui-&gt;setupUi(this)会先初始化里面的对象，只有初始化里面的对象我们才能使用这个对象。</p><p><strong>小提示：</strong>this 在成员函数的开始执行前构造的，在成员的执行结束后清除。</p><p>main.cpp</p><p>在每一个使用 Qt 的应用程序中都必须使用一个QApplication 对象。QApplication 管理了各种各样的应用程序的广泛资源，比如默认的字体和光标。</p><p>几乎在使用 Qt 的所有情况下，main()只需要在把控制转交给 Qt 库之前执行一些初始化，然后 Qt 库通过事件来向程序告知用户的行为。argc 是命令行变量的数量，argv 是命令行变量的数组。</p><p>调用方法 show()。这样程序界面才能显示。</p><p><strong>使用</strong> <strong>UI</strong> <strong>设计器开发程序</strong></p><p>在 UI 设计器里有两种方法可以连接信号与槽</p><p>所谓信号即是一个对象发出的信号，槽即是当这个对象发出这个信号时，对应连接的槽就发被执行或者触发。</p><p>要想事件做出对应的动作就必须用到信号与槽。</p><p>方法一：</p><p>点击信号槽连接的按钮，进入信号槽连接模式，进入信号与槽的连接模式后，将鼠标选中我们的“关闭程序”按钮，按住按钮，然后用鼠标向外拖动，此时就会出现信号槽连接的符号。</p><p>左边的“关闭程序”pushButton 按钮的信号，可以看到一个对象的信号可以有多种。右边的 QMainWindow 的槽函数，如果有其他对象，右边不一定只有MainWidnow 的槽函数（槽），也有可能是其他对象的槽。我们选择按钮的 clicked()信号，将其连接 MainWindow 对象的 close()槽。这样就完成了信号与槽的连接。可以预知这个信号与槽的功能，当“关闭程序”pushButton 发出了 clicked()信号（也就是单击信号）。这个信号由“关闭程序”pushButton 被单击时发出。它就会触发 MainWindow 的 close()。进而使整个程序关闭。MainWindow 的 close()就是退出关闭程序，退出程序的意思。</p><p>方法二：</p><p>选中“关闭程序”pushButton 按钮，然后右键。选择“转到槽”。</p><p>点击“转到槽”后，弹出窗口，先让我们选择信号。发现这个 clicked()信号并不是 pushButton 的，而是 QAbstactButton 的。只是 pusbButton 继承了 QAbstracButton，同时把这个信号也继承了下来。</p><p>不用重写 pushButton 的 clicked()事件。pushButton 只需要继承父类的 clicked()事件即可！</p><p>点击 OK 后，就会跳转到槽函数里，这个代码由 Qt Creator 自动生成。</p><p>同时在 mainwindow.h 里声明了这个槽函数。</p><p>返回到 mainwindow.cpp 找到 on_pushButton_clicked 这个槽函数里。在这个槽数里写上this-&gt;close();调用 close()方法关闭整个程序。</p><hr><p>参考资料：正点原子嵌入式Qt开发指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;基类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QMainWindow：主窗口类，主窗口具有主菜单栏、工具栏和状态栏。类似于一般的应用程序的主窗口。如果您想做个嵌套的窗口程序开发的软件，不妨选择这个</summary>
      
    
    
    
    
    <category term="Qt" scheme="https://www.chenzhan.club/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>note54.6-系统信息与系统资源</title>
    <link href="https://www.chenzhan.club/2021/07/16/note54-6-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/"/>
    <id>https://www.chenzhan.club/2021/07/16/note54-6-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/</id>
    <published>2021-07-16T07:19:24.000Z</published>
    <updated>2021-07-19T08:16:37.467Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在应用程序当中，有时往往需要去获取到一些系统相关的信息，譬如时间、日期、以及其它一些系统相关信息，如何通过 Linux 系统调用或 C 库函数获取系统信息，譬如获取系统时间、日期以及设置系统时间、日期等；除此之外，还会向大家介绍 Linux 系统下的/proc 虚拟文件系统，包括/proc 文件系统是什么以及如何从/proc 文件系统中读取系统、进程有关信息，有关系统资源的使用，譬如系统内存资源的申请与使用等</p><h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a><strong>系统信息</strong></h1><h2 id="系统标识-uname"><a href="#系统标识-uname" class="headerlink" title="系统标识 uname"></a><strong>系统标识</strong> <strong>uname</strong></h2><p>系统调用 uname()用于获取有关当前操作系统内核的名称和信息</p><p>需要包含头文件&lt;sys/utsname.h&gt;</p><p>uname()函数用法非常简单，先定义一个 struct utsname 结构体变量，调用 uname()函数时传入变量的地址即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct utsname 结构体</span><br><span class="line">struct utsname &#123;</span><br><span class="line"> char sysname[]; &#x2F;* 当前操作系统的名称 *&#x2F;</span><br><span class="line"> char nodename[]; &#x2F;* 网络上的名称（主机名） *&#x2F;</span><br><span class="line"> char release[]; &#x2F;* 操作系统内核版本 *&#x2F;</span><br><span class="line"> char version[]; &#x2F;* 操作系统发行版本 *&#x2F;</span><br><span class="line"> char machine[]; &#x2F;* 硬件架构类型 *&#x2F;</span><br><span class="line"> #ifdef _GNU_SOURCE</span><br><span class="line"> char domainname[];&#x2F;* 当前域名 *&#x2F;</span><br><span class="line"> #endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，struct utsname 结构体中的所有成员变量都是字符数组，所以获取到的信息都是字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">测试结果如下：</span><br><span class="line">操作系统名称: Linux</span><br><span class="line">主机名: chenzhan-virtual-machine</span><br><span class="line">内核版本: 4.15.0-133-generic</span><br><span class="line">发行版本: #137~16.04.1-Ubuntu SMP Fri Jan 15 02:55:18 UTC 2021</span><br><span class="line">硬件架构: x86_64</span><br></pre></td></tr></table></figure><p>sysinfo 系统调用可用于获取一些系统统计信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct sysinfo &#123;</span><br><span class="line"> long uptime; &#x2F;* 自系统启动之后所经过的时间（以秒为单位） *&#x2F;</span><br><span class="line"> unsigned long loads[3]; &#x2F;* 1, 5, and 15 minute load averages *&#x2F;</span><br><span class="line"> unsigned long totalram; &#x2F;* 总的可用内存大小 *&#x2F;</span><br><span class="line"> unsigned long freeram; &#x2F;* 还未被使用的内存大小 *&#x2F;</span><br><span class="line"> unsigned long sharedram; &#x2F;* Amount of shared memory *&#x2F;</span><br><span class="line"> unsigned long bufferram; &#x2F;* Memory used by buffers *&#x2F;</span><br><span class="line"> unsigned long totalswap; &#x2F;* Total swap space size *&#x2F;</span><br><span class="line"> unsigned long freeswap; &#x2F;* swap space still available *&#x2F;</span><br><span class="line"> unsigned short procs; &#x2F;* 系统当前进程数量 *&#x2F;</span><br><span class="line"> unsigned long totalhigh; &#x2F;* Total high memory size *&#x2F;</span><br><span class="line"> unsigned long freehigh; &#x2F;* Available high memory size *&#x2F;</span><br><span class="line"> unsigned int mem_unit; &#x2F;* 内存单元大小（以字节为单位） *&#x2F;</span><br><span class="line"> char _f[20-2*sizeof(long)-sizeof(int)]; &#x2F;* Padding to 64 bytes *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>gethostname 函数可用于单独获取 Linux 系统主机名，与 struct utsname 数据结构体中的 nodename 变量一样</p><p>sysconf()函数是一个库函数，可在运行时获取系统的一些配置信息，譬如页大小（page size）、主机名的最大长度、进程可以打开的最大文件数、每个用户 ID 的最大并发进程数等</p><p>使用该函数需要包含头文件&lt;unistd.h&gt;</p><p>调用 sysconf()函数获取系统的配置信息，参数 name 指定了要获取哪个配置信息，参数 name 可取以下任何一个值（都是宏定义，可通过 man 手册查询）： </p><ul><li><strong>_SC_ARG_MAX**</strong>：<strong>exec 族函数的参数的最大长度，exec 族函数后面会介绍，这里先不管！</strong></li><li>_SC_CHILD_MAX：<strong>每个用户的最大并发进程数，也就是同一个用户可以同时运行的最大进程数。</strong></li><li>__SC_HOST_NAME_MAX：主机名的最大长度。</li><li>__SC_LOGIN_NAME_MAX：登录名的最大长度。</li><li>__SC_CLK_TCK：每秒时钟滴答数，也就是系统节拍率。</li><li>__SC_OPEN_MAX：一个进程可以打开的最大文件数。</li><li>__SC_PAGESIZE：系统页大小（page size）。</li><li>__SC_TTY_NAME_MAX：终端设备名称的最大长度。</li></ul><p>用的比较多的是SC_PAGESIZE 和_SC_CLK_TCK</p><p>若指定的参数 name 为无效值，则 sysconf()函数返回-1，并会将 errno 设置为 EINVAL。否则返回的值便是对应的配置值。注意，返回值是一个 long 类型的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">每个用户的最大并发进程数: 7638</span><br><span class="line">系统节拍率: 100</span><br><span class="line">系统页大小: 4096</span><br></pre></td></tr></table></figure><h1 id="时间、日期"><a href="#时间、日期" class="headerlink" title="时间、日期"></a><strong>时间、日期</strong></h1><p>GMT（Greenwich Mean Time）中文全称是格林威治标准时间</p><p>UTC（Coordinated Universal Time）指的是世界协调时间（又称世界标准时间、世界统一时间），是经过平均太阳时(以格林威治时间 GMT 为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此若以「世界标准时间」的角度来说，UTC 比 GMT 来得更加精准</p><p><strong>在 Ubuntu 系统下，可以使用”date -u”命令查看到当前的 UTC 时间</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021年 07月 16日 星期五 07:42:47 UTC</span><br></pre></td></tr></table></figure><p><strong>在 Ubuntu 系统下，可以使用 date 命令查看系统当前的本地时间</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021年 07月 16日 星期五 15:47:14 CST</span><br></pre></td></tr></table></figure><p>CST 在这里其实指的是 China Standard Time（中国标准时间）的缩写，表示当前查看到的时间是中国标准时间，也就是我国所使用的标准时间–北京时间</p><p>在 Ubuntu 系统下，时区信息通常以标准格式保存在一些文件当中，这些文件通常位于/usr/share/zoneinfo目录下，该目录下的每一个文件（包括子目录下的文件）都包含了一个特定国家或地区内时区制度的相关信息，且往往根据其所描述的城市或地区缩写来加以命名，譬如 EST（美国东部标准时间）、CET（欧洲中部时间）、UTC（世界标准时间）、Hongkong、Iran、Japan（日本标准时间）等，也把这些文件称为时区配置文件</p><p>系统的本地时间由时区配置文件/etc/localtime 定义，通常链接到/usr/share/zoneinfo 目录下的某一个文件（或其子目录下的某一个文件）</p><p>如果我们要修改 Ubuntu 系统本地时间的时区信息，可以直接将/etc/localtime 链接到/usr/share/zoneinfo目录下的任意一个时区配置文件，譬如 EST（美国东部标准时间），首先进入到/etc 目录下，执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf localtime #删除原有链接文件</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;EST localtime #重新建立链接文件</span><br></pre></td></tr></table></figure><h2 id="Linux-系统中的时间"><a href="#Linux-系统中的时间" class="headerlink" title="Linux 系统中的时间"></a><strong>Linux</strong> <strong>系统中的时间</strong></h2><p><strong>点时间和段时间</strong></p><p><strong>实时时钟</strong> <strong>RTC</strong></p><p>操作系统中一般会有两个时钟，一个系统时钟（system clock），一个实时时钟（Real time clock），也叫 RTC；系统时钟由系统启动之后由内核来维护，譬如使用 date 命令查看到的就是系统时钟，所以在系统关机情况下是不存在的；而实时时钟一般由 RTC 时钟芯片提供，RTC 芯片有相应的电池为其供电，以保证系统在关机情况下 RTC 能够继续工作、继续计时。</p><p><strong>Linux</strong> <strong>系统如何记录时间</strong></p><p>Linux 系统在开机启动之后首先会读取 RTC 硬件获取实时时钟作为系统时钟的初始值，之后内核便开始维护自己的系统时钟。所以由此可知，RTC 硬件只有在系统开机启动时会读取一次，目的是用于对系统时钟进行初始化操作，之后的运行过程中便不会再对其进行读取操作了。而在系统关机时，内核会将系统时钟写入到 RTC 硬件、已进行同步操作。</p><p><strong>jiffies</strong> <strong>的引入</strong></p><p>jiffies 是内核中定义的一个全局变量，内核使用 jiffies 来记录系统从启动以来的系统节拍数，所以这个变量用来记录以系统节拍时间为单位的时间长度，Linux 内核在编译配置时定义了一个节拍时间，使用节拍率（一秒钟多少个节拍数）来表示，譬如常用的节拍率为 100Hz（一秒钟 100 个节拍数，节拍时间为 1s / 100）、500Hz（一秒钟 500 个节拍，节拍时间为 1s / 500）等。可以发现配置的节拍率越低，每一个系统节拍的时间就越短，也就意味着 jiffies 记录的时间精度越高，高节拍率会导致系统中断的产生更加频繁，频繁的中断会加剧系统的负担，一般默认情况下都是采用 100Hz 作为系统节拍率。</p><p>内核其实通过 jiffies 来维护系统时钟，全局变量 jiffies 在系统开机启动时会设置一个初始值，上面也给大家提到过，RTC 实时时钟会在系统开机启动时读取一次，目的是用于对系统时钟进行初始化，这里说的初始化其实指的就是对内核的 jiffies 变量进行初始化操作，操作系统使用 jiffies 这个全局变量来记录当前时间，当我们需要获取到系统当前时间点时，就可以使用 jiffies 变量去计算，当然并不需要我们手动去计算，Linux 系统提供了相应的系统调用或 C库函数用于获取当前时间，譬如系统调用 time()、gettimeofday()，其实质上就是通过 jiffies 变量换算得到。</p><h3 id="获取时间-time-gettimeofday"><a href="#获取时间-time-gettimeofday" class="headerlink" title="获取时间 time/gettimeofday"></a><strong>获取时间</strong> <strong>time/gettimeofday</strong></h3><p>系统调用 time()用于获取当前时间，以秒为单位，返回得到的值是自 1970-01-01 00:00:00 +0000 (UTC)以来的秒数</p><p>使用该函数需要包含头文件&lt;time.h&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line">time_t time(time_t *tloc);</span><br></pre></td></tr></table></figure><p>time 函数获取得到的是一个时间段，也就是从 1970-01-01 00:00:00 +0000 (UTC)到现在这段时间所经过的秒数，所以你要计算现在这个时间点，只需要使用 time()得到的秒数加 1970-01-01 00:00:00，可以直接使用相关系统调用或 C 库函数来得到当前时间</p><p>自 1970-01-01 00:00:00 +0000 (UTC)以来经过的总秒数，我们把这个称之为日历时间或 time_t 时间</p><p>gettimeofday()函数提供微秒级时间精度</p><p>ctime()是一个 C 库函数，可以将日历时间转换为可打印输出的字符串形式</p><p>但 ctime()是一个不可重入函数，存在一些安全上面的隐患，ctime_r()是 ctime()的可重入版本，一般推荐大家使用可重入函数 ctime_r()，可重入函数 ctime_r()多了一个参数 buf，也就是缓冲区首地址，所以 ctime_r()函数需要调用者提供用于存放字符串的缓冲区</p><p>Tips：在 Linux 系统中，有一些系统调用或 C 库函数提供了可重入版本与不可重入版本的函数接口，可重入版本函数所对应的函数名一般都会有一个” _r “后缀来表明它是一个可重入函数。</p><p>ctime（或ctime_r）转换得到的时间是计算机所在地对应的本地时间（譬如在中国对应的便是北京时间），并不是 UTC 时间</p><p>localtime()函数可以把 time()或 gettimeofday()得到的秒数（time_t 时间或日历时间）变成一个 struct tm结构体所表示的时间，该时间对应的是本地时间</p><p>gmtime()函数也可以把 time_t 时间变成一个 struct tm 结构体所表示的时间，与 localtime()所不同的是，gmtime()函数所得到的是 UTC 国际标准时间，并不是计算机的本地时间</p><p>mktime()可以将使用 struct tm 结构体表示的分解时间转换为 time_t时间（日历时间）</p><p>asctime()数与 ctime()函数的作用一样，但是将 struct tm 表示的分解时间转换为固定格式的字符串</p><p> strftime()，此函数也可以将一个 struct tm 变量表示的分解时间转换为为格式化字符串，可以根据自己的喜好自定义时间的显示格式</p><p>使用 settimeofday()函数可以设置时间，也就是设置系统的本地时间</p><h4 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a><strong>进程时间</strong></h4><p>进程时间指的是进程从创建后（也就是程序运行后）到目前为止这段时间内使用 CPU 资源的时间总数，出于记录的目的，内核把 CPU 时间（进程时间）分为以下两个部分：</p><ul><li>用户 CPU 时间：进程在用户空间（用户态）下运行所花费的 CPU 时间。有时也成为虚拟时间（virtualtime）。</li><li>系统 CPU 时间：进程在内核空间（内核态）下运行所花费的 CPU 时间。这是内核执行系统调用或代表进程执行的其它任务（譬如，服务页错误）所花费的时间。</li></ul><p>一般来说，进程时间指的是用户 CPU 时间和系统 CPU 时间的总和，也就是总的 CPU 时间。</p><p>Tips：进程时间不等于程序的整个生命周期所消耗的时间，如果进程一直处于休眠状态（进程被挂起、不会得到系统调度），那么它并不会使用 CPU 资源，所以休眠的这段时间并不计算在进程时间中。</p><p>times()函数用于获取当前进程时间</p><p>使用该函数需要包含头文件&lt;sys/times.h&gt;</p><p>如果我们想查看程序运行到某一个位置时的进程时间，或者计算出程序中的某一段代码执行过程所花费的进程时间，都可以使用 times()函数来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">时间总和: 1.630000 秒</span><br><span class="line">用户 CPU 时间: 0.610000 秒</span><br><span class="line">系统 CPU 时间: 0.000000 秒</span><br></pre></td></tr></table></figure><p>库函数 clock()提供了一个更为简单的方式用于进程时间，它的返回值描述了进程使用的总的 CPU 时间（也就是进程时间，包括用户 CPU 时间和系统 CPU 时间）</p><h3 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a><strong>产生随机数</strong></h3><p><strong>随机数与伪随机数</strong></p><p>随机数是随机出现，没有任何规律的一组数列。在我们编程当中，是没有办法获得真正意义上的随机数列的，这是一种理想的情况，在我们的程序当中想要使用随机数列，只能通过算法得到一个伪随机数序列，那在编程当中说到的随机数，基本都是指伪随机数。</p><p>C 语言函数库中提供了很多函数用于产生伪随机数，其中最常用的是通过 rand()和 srand()产生随机数</p><p>rand()函数用于获取随机数，多次调用 rand()可得到一组随机数序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int rand(void);</span><br></pre></td></tr></table></figure><p>如果没有调用 srand()设置随机数种子的情况下，rand()会将 1 作为随机数种子，如果随机数种子相同，那么每一次启动应用程序所得到的随机数序列就是一样的，所以每次启动应用程序需要设置不同的随机数种子，这样就可以使得程序每次运行所得到随机数序列不同</p><p>使用 srand()函数为 rand()设置随机数种子</p><p>常用的用法 srand(time(NULL));</p><p>程序中将 rand()的随机数种子设置为 srand(time(NULL))，直接等于 time_t 时间值，意味着每次启动种子都不一样，所以能够产生不同的随机数数组</p><p>random()、srandom()、initstate()、setstate()也是可以产生随机数的 API 函数</p><p>使用 man 手册查看系统调用或 C 库函数帮助信息时，在帮助信息页面 SEE ALSO 栏会列举出与本函数有关联的一些命令、系统调用或 C 库函数等</p><h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a><strong>休眠</strong></h4><p>有时需要将进程暂停或休眠一段时间，进入休眠状态之后，程序将暂停运行，直到休眠结束。常用的系统调用和 C 库函数有 sleep()、usleep()以及 nanosleep()，这些函数在应用程序当中通常作为延时使用，譬如延时 1 秒钟</p><p><strong>秒级休眠: sleep</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int sleep(unsigned int seconds);</span><br></pre></td></tr></table></figure><p><strong>微秒级休眠: uslee</strong></p><p>#include &lt;unistd.h&gt;</p><p><strong>高精度休眠: nanosleep</strong></p><p>nanosleep()具有更高精度来设置休眠时间长度，支持纳秒级时长设置</p><p>使用该函数需要包含头文件&lt;time.h&gt;。</p><p>休眠状态下，该进程会失去 CPU使用权，退出系统调度队列，直到休眠结束</p><h3 id="申请堆内存"><a href="#申请堆内存" class="headerlink" title="申请堆内存"></a><strong>申请堆内存</strong></h3><p>在操作系统下，内存资源是由操作系统进行管理、分配的，当应用程序想要内存时（这里指的是堆内存），可以向操作系统申请内存，然后使用内存；当不再需要时，将申请的内存释放、归还给操作系统</p><p><strong>在堆上分配内存：**</strong>malloc** <strong>和</strong> <strong>free</strong></p><p>Linux C 程序当中一般使用 malloc()函数为程序分配一段堆内存，而使用 free()函数来释放这段内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void *malloc(size_t size);</span><br></pre></td></tr></table></figure><p><strong>函数参数和返回值含义如下：</strong></p><p><strong>size：</strong>需要分配的内存大小，以字节为单位。</p><p><strong>返回值：</strong>返回值为 void *类型，如果申请分配内存成功，将返回一个指向该段内存的指针，void *并不是说没有返回值或者返回空指针，而是返回的指针类型未知,所以在调用 malloc()时通常需要进行强制类型转换，将 void *指针类型转换成我们希望的类型；如果分配内存失败（譬如系统堆内存不足）将返回 NULL，如果参数 size 为 0，返回值也是 NULL。</p><p>malloc()在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的，所以通常需要程序员对 malloc()分配的堆内存进行初始化操作。</p><p>在堆上分配的内存，需要开发者自己手动释放掉，通常使用 free()函数释放堆内存，free()函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void free(void *ptr);</span><br></pre></td></tr></table></figure><p><strong>函数参数和返回值含义如下：</strong></p><p><strong>ptr**</strong>：**指向需要被释放的堆内存对应的指针。</p><p><strong>返回值：</strong>无返回值。</p><p>Linux 系统中，当一个进程终止时，内核会自动关闭它没有关闭的所有文件（该进程打开的文件，但是在进程终止时未调用 close()关闭它）。对于内存来说也是如此，当进程终止时，内核会将其占用的所有内存都返还给操作系统，这包括在堆内存中由 malloc()函数所分配的内存空间，但是如果持续占用，将会导致内存泄漏</p><p><strong>在堆上分配内存的其它方法</strong></p><p>calloc()函数用来动态地分配内存空间并初始化为 0</p><p><strong>分配对其内存</strong></p><p>posix_memalign()、aligned_alloc()、memalign()、valloc()、pvalloc()</p><p>使用posix_memalign()、aligned_alloc()、valloc()时需要包含头文件&lt;stdlib.h&gt;，使用memalign()、pvalloc()这两个函数时需要包含头文件&lt;malloc.h&gt;</p><p>malloc()、calloc()分配内存返回的地址其实也是对齐的，但是它俩的对齐都是固定的</p><p>posix_memalign()函数用于在堆上分配 size 个字节大小的对齐内存空间，将*memptr 指向分配的空间，分配的内存地址将是参数 alignment 的整数倍。参数 alignment 表示对齐字节数，alignment 必须是 2 的幂次方（譬如 2^4、2^5、2^8 等），同时也要是 sizeof(void *)的整数倍，对于 32 位系统来说，sizeof(void *)等于4，如果是 64 位系统 sizeof(void *)等于 8。</p><p>aligned_alloc()函数用于分配 size 个字节大小的内存空间，返回指向该空间的指针。</p><p>memalign()与 aligned_alloc()参数是一样的，它们之间的区别在于：对于参数 size 必须是参数 alignment的整数倍这个限制条件，memalign()并没有这个限制条件</p><p>Tips：memalign()函数已经过时了，并不提倡使用！</p><p>valloc()分配 size 个字节大小的内存空间，返回指向该内存空间的指针，内存空间的地址是页大小（pagesize）的倍数。</p><p>Tips：valloc()函数已经过时了，并不提倡使用！</p><h3 id="proc-文件系统"><a href="#proc-文件系统" class="headerlink" title="proc 文件系统"></a><strong>proc</strong> <strong>文件系统</strong></h3><p>proc 文件系统是一个虚拟文件系统，它以文件系统的方式为应用层访问系统内核数据提供了接口，用户和应用程序可以通过 proc 文件系统得到系统信息和进程相关信息，对 proc 文件系统的读写作为与内核进行通信的一种手段。但是与普通文件不同的是，proc 文件系统是动态创建的，文件本身并不存在于磁盘当中、只存在于内存当中,与 devfs 一样，都被称为虚拟文件系统。</p><p>最初构建 proc 文件系统是为了提供有关系统中进程相关的信息，但是由于这个文件系统非常有用，因此内核中的很多信息也开始使用它来报告，或启用动态运行时配置。内核构建 proc 虚拟文件系统，它会将内核运行时的一些关键数据信息以文件的方式呈现在 proc 文件系统下的一些特定文件中，这样相当于将一些不可见的内核中的数据结构以可视化的方式呈现给应用层。</p><p>proc 文件系统挂载在系统的/proc 目录下，对于内核开发者（譬如驱动开发工程师）来说，proc 文件系统给了开发者一种调试内核的方法：通过查看/proc/xxx 文件来获取到内核特定数据结构的值，在添加了新功能前后进行对比，就可以判断此功能所产生的影响是否合理。</p><p>可以看到/proc 目录下有很多以数字命名的文件夹，譬如 100038、2299、98560，这些数字对应的其实就是<strong>一个一个的进程 PID 号，每一个进程在内核中都会存在一个编号，通过此编号来区分不同的进程</strong>，这个编号就是 PID 号</p><p>/proc 目录下除了文件夹之外，还有很多的虚拟文件，譬如 buddyinfo、cgroups、cmdline、version 等等，</p><p>不同的文件记录了不同信息，关于这些文件记录的信息和意思如下：</p><ul><li>cmdline：内核启动参数； </li><li>cpuinfo：CPU 相关信息；</li><li>iomem：IO 设备的内存使用情况；</li><li>interrupts：显示被占用的中断号和占用者相关的信息；</li><li>ioports：IO 端口的使用情况；</li><li>kcore：系统物理内存映像，不可读取；</li><li>loadavg：系统平均负载；</li><li>meminfo：物理内存和交换分区使用情况；</li><li>modules：加载的模块列表；</li><li>mounts：挂载的文件系统列表；</li><li>partitions：系统识别的分区表；</li><li>swaps：交换分区的利用情况；</li><li>version：内核版本信息；</li><li>uptime：系统运行时间；</li></ul><p><strong>proc</strong> <strong>文件系统的使用</strong></p><p>proc 文件系统的使用就是去读取/proc 目录下的这些文件，获取文件中记录的信息，可以直接使用 cat 命令读取，也可以在应用程序中调用 open()打开、然后再使用 read()函数读取。</p><p><strong>使用</strong> <strong>cat</strong> <strong>命令读取</strong></p><p>在 Linux 系统下直接使用 cat 命令查看/proc 目录下的虚拟文件，譬如”cat /proc/version”查看内核版本相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux version 4.15.0-133-generic (buildd@lgw01-amd64-024) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12)) #137~16.04.1-Ubuntu SMP Fri Jan 15 02:55:18 UTC 2021</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>占位。。等原子个更新《- -》</p><hr><p>参考资料：正点原子嵌入式Linux C应用编程指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;在应用程序当中，有时往往需要去获取到一些系统相关的信息，譬如时间、日期、以及其它一些系统相关信息，如何通过 Linux 系统调用或 C 库函数获取系统信息，譬如获取系统时间、日期以及</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note53.6-字符串处理</title>
    <link href="https://www.chenzhan.club/2021/07/16/note53-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>https://www.chenzhan.club/2021/07/16/note53-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</id>
    <published>2021-07-16T06:11:11.000Z</published>
    <updated>2021-07-19T08:18:21.025Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>字符串输出</strong></p><p><strong>使用以下函数需要包含头文件&lt;stdio.h&gt;</strong></p><p>puts()函数用来向标准输出设备（屏幕、显示器）输出字符串并自行换行。把字符串输出到标准输出设备，将’ \0 ‘转换为换行符’ \n ‘。</p><p>putchar()函数可以把参数 c 指定的字符（一个无符号字符）输出到标准输出设备，其输出可以是一个字符，可以是介于 0~127 之间的一个十进制整型数（包含 0 和 127，输出其对应的 ASCII 码字符），也可以是用 char 类型定义好的一个字符型变量</p><p>fputc()与 putchar()类似，也用于输出参数 c 指定的字符（一个无符号字符），与 putchar()区别在于，putchar()只能输出到标准输出设备，而 fputc()可把字符输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件</p><p>fputs()与 puts()类似，也用于输出一条字符串，与 puts()区别在于，puts()只能输出到标准输出设备，而 fputs()可把字符串输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件</p><p>gets()函数用于从标准输入设备（譬如键盘）中获取用户输入的字符串</p><p>用户从键盘输入的字符串数据首先会存放在一个输入缓冲区中，gets()函数会从输入缓冲区中读取字符</p><p>串存储到字符指针变量 s 所指向的内存空间，当从输入缓冲区中读走字符后，相应的字符<strong>便不存在</strong>缓冲区了。</p><p>输入的字符串中就算是有空格也可以直接输入，字符串输入完成之后按回车即可，gets()函数不检查缓冲区溢出。</p><p>程序中使用 gets()函数是<strong>非常不安全</strong>的</p><p><strong>gets()与scanf()的区别</strong></p><ul><li>gets()函数允许输入的字符串带有空格、制表符，输入的空格和制表符也是字符串的一部分，仅以回车换行符作为字符串的分割符；而对于 scanf 以%s 格式输入的时候，空格、换行符、TAB 制表符等都是作为字符串分割符存在，即分隔符前后是两个字符串，读取字符串时并不会将分隔符读取出来作为字符串的组成部分，一个%s 只能读取一个字符串，若要多去多个字符串，则需要使用多个%s、并且需要使用多个字符数组存储。</li><li>gets()会将回车换行符从输入缓冲区中取出来，然后将其丢弃，所以使用 gets()读走缓冲区中的字符串数据之后，缓冲区中将不会遗留下回车换行符；而对于 scanf()来说，使用 scanf()读走缓冲区中的字符串数据时，并不会将分隔符（空格、TAB 制表符、回车换行符等）读走将其丢弃，所以使用 scanf()读走缓冲区中的字符串数据之后，缓冲区中依然还存在用户输入的分隔符。</li></ul><p>scanf()%s不读取缓冲区中的分割符和换行符</p><p>对于%c 读入时，空格、换行符、TAB 这些都是正常字符</p><p>gets()会将换行符读取出来并将其丢弃，剩下一个空字符串</p><p>getchar()函数也是从输入缓冲区读取字符数据，但只读取一个字符，包括空格、TAB 制表符、换行回车符等</p><p>fgets()与 gets()的区别主要是三点：</p><ul><li>gets()只能从标准输入设备中获取输入字符串，而 fgets()既可以从标准输入设备获取字符串、也可以从一个普通文件中获取输入字符串。</li><li>fgets()可以设置获取字符串的最大字符数。</li><li>gets()会将缓冲区中的换行符’\n’读取出来、将其丢弃、将’\n’替换为字符串结束符’\0’；fgets()也会将缓冲区中的换行符读取出来，但并不丢弃，而是作为字符串组成字符存在，读取完成之后自动在最后添加字符串结束字符’\0’。</li></ul><p>fgetc()与 getchar()一样，用于读取一个输入字符，fgetc()与 getchar()的区别在于，fgetc 可以指定输入字符的文件，既可以从标准输入设备输入字符，也可以从一个普通文件中输入字符，其它方面与 getchar 函数相同</p><p><strong>字符串长度</strong></p><p>使用该函数需要包含头文件&lt;string.h&gt;。</p><p>C 语言函数库中提供了一个用于计算字符串长度的函数 strlen()</p><p><strong>sizeof</strong> <strong>和</strong> <strong>strlen</strong> <strong>的区别</strong></p><p>在程序当中，我们通常也会使用 sizeof 来计算长度，那 strlen 和 sizeof 有什么区别呢？</p><ul><li>sizeof 是 C 语言内置的操作符关键字，而 strlen 是 C 语言库函数；</li><li>sizeof 仅用于计算数据类型的大小或者变量的大小，而 strlen 只能以结尾为’ \0 ‘的字符串作为参数；</li><li>编译器在编译时就计算出了 sizeof 的结果，而 strlen 必须在运行时才能计算出来；</li><li>sizeof 计算数据类型或变量会占用内存的大小，strlen 计算字符串实际长度。</li></ul><p><strong>字符串拼接</strong></p><p>C 语言函数库中提供了 strcat()函数或 strncat()函数用于将两个字符串连接（拼接）起来</p><p>strcat()函数会把 src 所指向的字符串追加到 dest 所指向的字符串末尾，所以必须要保证 dest 有足够的存储空间来容纳两个字符串，否则会导致溢出错误；dest 末尾的’ \0 ‘结束字符会被覆盖，src 末尾的结束字符’ \0 ‘会一起被复制过去，最终的字符串只有一个’ \0 ‘</p><p>strncat()与 strcat()的区别在于，strncat 可以指定源字符串追加到目标字符串的字符数量</p><p>如果源字符串 src 包含 n 个或更多个字符，则 strncat()将 n+1 个字节追加到 dest 目标字符串（src 中的 n个字符加上结束字符’ \0 ‘）</p><p><strong>字符串拷贝</strong></p><p>C 语言函数库中提供了 strcpy()函数和 strncpy()函数用于实现字符串拷贝</p><p>strcpy()会把 src（必须包含结束字符’ \0 ‘）指向的字符串复制（包括字符串结束字符’ \0 ‘）到 dest，所以必须保证 dest 指向的内存空间足够大，能够容纳下 src 字符串，否则会导致溢出错误</p><p>strncpy()与 strcpy()的区别在于，strncpy()可以指定从源字符串 src 复制到目标字符串 dest 的字符数量</p><p>除了 strcpy()和 strncpy()之外，其实还可以使用 memcpy()、memmove()以及 bcopy()这些库函数实现拷贝操作</p><p><strong>内存填充</strong></p><p>在编程中，经常需要将某一块内存中的数据全部设置为指定的值，譬如在定义数组、结构体这种类型变量时，通常需要对其进行初始化操作，而初始化操作一般都是将其占用的内存空间全部填充为 0</p><p>memset()函数用于将某一块内存的数据全部设置为指定的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void *memset(void *s, int c, size_t n);</span><br></pre></td></tr></table></figure><p>使用该函数需要包含头文件&lt;string.h&gt;。</p><p><strong>函数参数和返回值含义如下：</strong></p><p><strong>s：</strong>需要进行数据填充的内存空间起始地址。</p><p><strong>c：</strong>要被设置的值，该值以 int 类型传递。</p><p><strong>n：</strong>填充的字节数。</p><p><strong>返回值：</strong>返回指向内存空间 s 的指针。</p><p>参数 c 虽然是以 int 类型传递，但 memset()函数在填充内存块时是使用该值的无符号字符形式，也就是函数内部会将该值转换为 unsigned char 类型的数据，以字节为单位进行数据填充。</p><p>bzero()函数用于将一段内存空间中的数据全部设置为 0</p><p>可以对数组 str 进行初始化操作，将其存储的数据全部设置为 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzero(str, sizeof(str));</span><br></pre></td></tr></table></figure><p><strong>字符串比较</strong></p><p>C 语言函数库提供了用于字符串比较的函数 strcmp()和 strncmp()，strcmp()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int strcmp(const char *s1, const char *s2);</span><br></pre></td></tr></table></figure><p><strong>函数参数和返回值含义如下：</strong></p><p><strong>s1**</strong>：**进行比较的字符串 1。</p><p><strong>s2**</strong>：**进行比较的字符串 2。</p><p><strong>返回值：</strong></p><ul><li>如果返回值小于 0，则表示 str1 小于 str2 </li><li>如果返回值大于 0，则表示 str1 大于 str2 </li><li>如果返回值等于 0，则表示字符串 str1 等于字符串 str2 </li></ul><p>strcmp 进行字符串比较，主要是通过比较字符串中的字符对应的 ASCII 码值，strcmp 会根据 ASCII 编码依次比较 str1 和 str2 的每一个字符，直到出现了不同的字符，或者某一字符串已经到达末尾（遇见了字符串结束字符’ \0 ‘）</p><p>strncmp()与 strcmp()函数一样，也用于对字符串进行比较操作，但最多比较前 n 个字符</p><p><strong>字符串查找</strong></p><p>字符串查找在平时的编程当中也是一种很常见的操作，譬如从一个给定的字符串当中查找某一个字符</p><p>或者一个字符串，并获取它的位置。C 语言函数库中也提供了一些用于字符串查找的函数，包括 strchr()、strrchr()、strstr()、strpbrk()、index()以及 rindex()等</p><p>使用 strchr()函数可以查找到给定字符串当中的某一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char *strchr(const char *s, int c);</span><br></pre></td></tr></table></figure><p><strong>函数参数和返回值含义如下：</strong></p><p><strong>s：</strong>给定的目标字符串。</p><p><strong>c：</strong>需要查找的字符。</p><p><strong>返回值：</strong>返回字符 c 第一次在字符串 s 中出现的位置，如果未找到字符 c，则返回 NULL。</p><p>字符串结束字符’ \0 ‘也将作为字符串的一部分，因此，如果将参数 c 指定为’ \0 ‘，则函数将返回指向结束字符的指针。strchr 函数在字符串 s 中从前到后（或者称为从左到右）查找字符 c，找到字符 c 第一次出现的位置就返回，返回值指向这个位置，如果找不到字符 c 就返回 NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char *ptr &#x3D; NULL;</span><br><span class="line">char str[] &#x3D; &quot;Hello World!&quot;;</span><br><span class="line">ptr &#x3D; strchr(str, &#39;W&#39;);</span><br><span class="line">if (NULL !&#x3D; ptr) &#123;</span><br><span class="line">printf(&quot;Character: %c\n&quot;, *ptr);</span><br><span class="line">printf(&quot;Offset: %ld\n&quot;, ptr - str);&#x2F;&#x2F;打印目标的数组下标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strrchr()与 strchr()函数一样，它同样表示在字符串中查找某一个字符，返回字符第一次在字符串中出现的位置，如果没找到该字符，则返回值 NULL，但两者唯一不同的是，strrchr()函数在字符串中是从后到前（或者称为从右向左）查找字符，找到字符第一次出现的位置就返回，返回值指向这个位置</p><p>strstr()可在给定的字符串 haystack 中查找第一次出现子字符串 needle 的位置，不包含结束字符’ \0 ‘</p><p>C 函数库中还提供其它的字符串（或字符）查找函数，譬如 strpbrk()、index()以及 rindex()等</p><p><strong>字符串与数字互转</strong></p><p><strong>字符串转整形数据</strong></p><p>atoi()、atol()、atoll()三个函数可用于将字符串分别转换为 int、long int 以及 long long 类型的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int atoi(const char *nptr);</span><br><span class="line">long atol(const char *nptr);</span><br><span class="line">long long atoll(const char *nptr);</span><br></pre></td></tr></table></figure><p>使用这些函数需要包含头文件&lt;stdlib.h&gt;。</p><p>strtol()、strtoll()两个函数可分别将字符串转为 long int 类型数据和 long long ing 类型数据，与 atol()、atoll()之间的区别在于，strtol()、strtoll()可以实现将多种不同进制数（譬如二进制表示的数字字符串、八进制表示的数字字符串、十六进制表示的数数字符串）表示的字符串转换为整形数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">long int strtol(const char *nptr, char **endptr, int base);</span><br><span class="line">long long int strtoll(const char *nptr, char **endptr, int base);</span><br></pre></td></tr></table></figure><p>需要进行转换的目标字符串可以以任意数量的空格或者 0 开头，转换时跳过前面的空格字符，直到遇上数字字符或正负符号（’ + ‘或’ - ‘）才开始做转换，而再遇到非数字或字符串结束时(‘ /0 ‘)才结束转换，并将结果返回</p><p>在 base=0 （数字基数，合法范围，比如base = 2，合法数值为0，1）的情况下，如果字符串包含一个了“0x”前缀，表示该数字将以 16 为基数；如果包含的是“0”前缀，表示该数字将以 8 为基数。 当 base=16 时，字符串可以使用“0x”前缀。</p><p>strtoul()返回值类型是 unsignedlong int，strtoull()返回值类型是 unsigned long long int</p><p><strong>字符串转浮点型数据</strong></p><p>atof()用于将字符串转换为一个 double 类型的浮点数据</p><p>strtof()、strtod()以及 strtold()三个库函数可分别将字符串转换为 float 类型数据、double 类型数据、longdouble 类型数据</p><p><strong>数字转字符串</strong></p><p>数字转换为字符串推荐大家使用前面介绍的格式化 IO 相关库函数，譬如使用 printf()将数字转字符串、并将其输出到标准输出设备或者使用 sprintf()或 snprintf()将数字转换为字符串并存储在缓冲区中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(void) &#123;</span><br><span class="line"> char str[20] &#x3D; &#123;0&#125;;</span><br><span class="line"> sprintf(str, &quot;%d&quot;, 500);</span><br><span class="line"> puts(str);</span><br><span class="line"> memset(str, 0x0, sizeof(str));</span><br><span class="line"> sprintf(str, &quot;%f&quot;, 500.111);</span><br><span class="line"> puts(str);</span><br><span class="line"> memset(str, 0x0, sizeof(str));</span><br><span class="line"> sprintf(str, &quot;%u&quot;, 500);</span><br><span class="line"> puts(str);</span><br><span class="line"> exit(0);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>给应用程序传参</strong></p><p>如果在执行应用程序时，需要向应用程序传递参数，则写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line"> &#x2F;* 代码 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;* 代码 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递进来的参数以字符串的形式存在，字符串的起始地址存储在 argv 数组中，参数 argc 表示传递进来的参数个数，包括应用程序自身路径名，多个不同的参数之间使用空格分隔开来，如果参数本身带有空格、则可以使用双引号” “或者单引号’ ‘的形式来表示</p><p><strong>正则表达式</strong></p><p>在许多的应用程序当中，通常会有这样的需要：给定一个字符串，检查该字符串是否符合某种条件或规则、或者从给定的字符串中找出符合某种条件或规则的子字符串，将匹配到的字符串提取出来</p><p>正则表达式，又称为规则表达式（英语: Regular Expression），<strong>正则表达式通常被用来检索、替换那些符合某个模式（规则）的字符串，正则表达式描述了一种字符串的匹配模式（pattern），可以用来检查一个给定的字符串中是否含有某种子字符串、将匹配的字符串替换或者从某个字符串中取出符合某个条件的子字符串</strong>。</p><p>在 Linux 系统下运行命令的时候，相信大家都使用过?或 * 通配符来查找硬盘上的文件或者文本中的某个字符串，?通配符匹配 0 个或 1 个字符，而*通配符匹配 0 个或多个字符正则表达式其实也是一个字符串，该字符串由普通字符（譬如，数字 0~9、大小写字母以及其它字符）和特殊字符（称为“元字符”）所组成，由这些字符组成一个“规则字符串”，这个“规则字符串”用来表达对给定字符串的一种查找、匹配逻辑</p><p>占位！后续待正点原子更新&lt;=-=&gt;</p><hr><p>参考资料：正点原子嵌入式Linux C应用编程指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;strong&gt;字符串输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用以下函数需要包含头文件&amp;lt;stdio.h&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;puts()函数</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note52.6-文件属性与目录</title>
    <link href="https://www.chenzhan.club/2021/07/15/note52-6-%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%AE%E5%BD%95/"/>
    <id>https://www.chenzhan.club/2021/07/15/note52-6-%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%AE%E5%BD%95/</id>
    <published>2021-07-15T07:49:19.000Z</published>
    <updated>2021-07-19T08:20:30.951Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>可以通过 stat 命令或者 ls -l 命令来查看文件类型</p><ul><li>‘ - ‘：普通文件</li><li>‘ d ‘：目录文件</li><li>‘ c ‘：字符设备文件</li><li>‘ b ‘：块设备文件</li><li>‘ l ‘：符号链接文件</li><li>‘ s ‘：套接字文件</li><li>‘ p ‘：管道文件</li></ul><p><strong>目录文件</strong></p><p><strong>字符设备文件和块设备文件</strong></p><p>字符设备文件（character）、块设备文件（block）</p><p>字符设备文件一般存放在 Linux 系统/dev/目录下，所以/dev 也称为虚拟文件系统 devfs</p><p>设备文件对应于硬件设备</p><p><strong>符号链接文件</strong>（link）类似于 Windows 系统中的快捷方式文件，是一种特殊文件，它的内容指向的是另一个文件路径，当对符号链接文件进行操作时，系统根据情况会对这个操作转移到它指向的文件上去，而不是对它本身进行操作，譬如，读取一个符号链接文件内容时，实际上读到的是它指向的文件的内容</p><p><strong>管道文件</strong>（pipe）主要用于进程间通信</p><p><strong>套接字文件</strong>（socket）也是一种进程间通信的方式，与管道文件不同的是，它们可以在不同主机上的进程间通信，实际上就是网络通信</p><p>Linux 下可以使用 stat 命令查看文件的属性，其实这个命令内部就是通过调用 stat()函数来获取文件属性的，stat 函数是 Linux 中的系统调用，用于获取文件相关的信息</p><p>structstat 是内核定义的一个结构体，在&lt;sys/stat.h&gt;头文件中申明，所以可以在应用层使用，这个结构体中的所有元素加起来构成了文件的属性信息</p><p>st_mode 是 structstat 结构体中的一个成员变量，是一个 32 位无符号整形数据，该变量记录了文件的类型、文件的权限这些信息</p><p>struct timespec 结构体该结构体定义在&lt;time.h&gt;头文件中，是 Linux 系统中时间相关的结构体，应用程序中包含了&lt;time.h&gt;头文件</p><p>在 Linux 系统中，time_t 时间指的是一个时间段，从某一个时间点到某一个时间点所经过的秒数，譬如对于文件的三个时间属性来说，指的是从过去的某一个时间点（这个时间点是一个起始基准时间点）到文件最后被访问、文件内容最后被修改、文件状态最后被改变的这个时间点所经过的秒数</p><p>可以通过 localtime()/localtime_r()或者 strftime()来得到更利于我们查看的时间表达方式“2020-10-10 18:30:30”</p><p>fstat 与 stat 区别在于，stat 是从文件名出发得到文件属性信息，不需要先打开文件；而 fstat 函数则是从文件描述符出发得到文件属性信息，所以使用 fstat 函数之前需要先打开文件得到文件描述符</p><p>lstat()与 stat、fstat 的区别在于，对于符号链接文件，stat、fstat 查阅的是符号链接文件所指向的文件对应的文件属性信息，而 lstat 查阅的是符号链接文件本身的属性信息</p><p>Linux 是一个多用户操作系统，系统中一般存在着好几个不同的用户，而 Linux 系统中的每一个文件都有一个与之相关联的用户和用户组，通过这个信息可以判断文件的所有者和所属组</p><p>文件所属组则表示该文件属于哪一个用户组。在 Linux 中，系统并不是通过用户名或用户组名来识别不同的用户和用户组，而是通过 ID。ID 就是一个编号，Linux 系统会为每一个用户或用户组分配一个 ID，将用户名或用户组名与对应的 ID 关联起来，所以系统通过用户 ID（UID）或组 ID（GID）就可以识别出不同的用户和用户组</p><p>Tips：用户 ID 简称 UID、用户组 ID 简称 GID。</p><p>文件的用户 ID 和组 ID 分别由 struct stat 结构体中的 st_uid 和 st_gid 所指定</p><ul><li>实际用户 ID 和实际组 ID 标识我们究竟是谁，也就是执行该进程的用户是谁、以及该用户对应的所属组；实际用户 ID 和实际组 ID 确定了进程所属的用户和组。</li><li>进程的有效用户 ID、有效组 ID 以及附属组 ID 用于文件访问权限检查。</li></ul><p>对于有效用户 ID 和有效组 ID 来说，这是进程所持有的概念，对于文件来说，并无此属性！有效用户 ID 和有效组 ID 是站在操作系统的角度，用于给操作系统判断当前执行该进程的用户在当前环境下对某个文件是否拥有相应的权限</p><p><strong>chown 是一个系统调用，该系统调用可用于改变文件的所有者（用户 ID）和所属组（组 ID）</strong></p><p>将 testApp.c</p><p>文件的所有者和所属组修改为 root：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown root:root testApp.c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int chown(const char *pathname, uid_t owner, gid_t group);</span><br></pre></td></tr></table></figure><ul><li>只有超级用户进程能更改文件的用户 ID；</li><li>普通用户进程可以将文件的组 ID 修改为其所从属的任意附属组 ID，前提条件是该进程的有效用户 ID 等于文件的用户 ID；而超级用户进程可以将文件的组 ID 修改为任意值。</li></ul><p>在 Linux 系统下，可以使用 getuid 和 getgid 两个系统调用分别用于获取当前进程的用户 ID 和用户组ID，这里说的进程的用户 ID 和用户组 ID 指的就是进程的实际用户 ID 和实际组 ID</p><p><strong>0 指的就是 root用户和 root 用户组</strong></p><p>struct stat 结构体中的 st_mode 字段记录了文件的访问权限位</p><p>文件的权限可以分为两个大类，分别是普通权限和特殊权限（也可称为附加权限）。普通权限包括对文件的读、写以及执行，而特殊权限则包括一些对文件的附加权限，譬如Set-User-ID、Set-Group-ID以及Sticky</p><p><strong>普通权限</strong></p><p>每个文件都有 9 个普通的访问权限位，可将它们分为 3 类</p><table><thead><tr><th>st_mode 权限表示宏</th><th>含义</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>文件所有者读权限</td></tr><tr><td>S_IWUSR</td><td>文件所有者写权限</td></tr><tr><td>S_IXUSR</td><td>文件所有者执行权限</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>一串字符串就描述了该文件的 9 个访问权限以及文件类型，譬如”- （文件类型）| rwx（所有者权限） | rwx（同组用户权限） | rx（其他用户权限）”： </p><p>“ - “表示该文件是一个普通文件。</p><p><strong>r</strong> 表示具有读权限；</p><p><strong>w</strong> 表示具有写权限；</p><p><strong>x</strong> 表示具有执行权限； </p><p>**-**表示无此权限</p><ul><li>如果进程的有效用户 ID 等于文件所有者 ID（st_uid），意味着该进程以文件所有者的角色存在；</li><li>如果进程的有效用户 ID 并不等于文件所有者 ID，意味着该进程并不是文件所有者身份；但是进程的有效用户组 ID 或进程的附属组 ID 之一等于文件的组 ID（st_gid），那么意味着该进程以文件所属组成员的角色存在，也就是文件所属组的同组用户成员。 </li><li>如果进程的有效用户 ID 不等于文件所有者 ID、并且进程的有效用户组 ID 或进程的所有附属组 ID均不等于文件的组 ID（st_gid），那么意味着该进程以其它用户的角色存在。</li><li>如果进程的有效用户 ID 等于 0（root 用户），则无需进行权限检查，直接对该文件拥有最高权限。</li></ul><p>st_mode 字段中除了记录文件的 9 个普通权限之外，还记录了文件的 3 个特殊权限，也就是 S 字段权限位，S 字段三个 bit 位中，从高位到低位依次表示文件的 set-user-ID 位权限、set-groupID 位权限以及 sticky 位权限</p><ul><li>当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-user-ID 位权限被设置，内核会将进程的有效 ID 设置为该文件的用户 ID（文件所有者 ID），意味着该进程直接获取了文件所有者的权限、以文件所有者的身份操作该文件。</li><li>当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-group-ID 位权限被设置，内核会将进程的有效用户组 ID 设置为该文件的用户组 ID（文件所属组 ID），意味着该进程直接获取了文件所属组成员的权限、以文件所属组成员的身份操作该文件。</li></ul><p>Linux 系统下绝大部分的文件都没有设置 set-user-ID 位权限和 set-group-ID 位权限，所以通常情况下，进程的有效用户等于实际用户（有效用户 ID 等于实际用户 ID），有效组等于实际组（有效组 ID 等于实际组 ID）</p><p><strong>普通文件权限方案（S/U/G/O）</strong></p><ul><li>目录的读权限：可列出（譬如：通过 ls 命令）目录之下的内容（即目录下有哪些文件）。</li><li>目录的写权限：可以在目录下创建文件、删除文件。</li><li>目录的执行权限：可访问目录下的文件，譬如对目录下的文件进行读、写、执行等操作。</li></ul><p>为了确保使用的是 ls 命令本身，执行时需要给出路径的完整路径/bin/ls</p><p>要想访问目录下的文件，譬如查看文件的 inode 节点、大小、权限等信息，还需要对目录拥有执行权限</p><p>反之，若拥有对目录的执行权限、而无读权限，只要知道目录内文件的名称，仍可对其进行访问，但不能列出目录下的内容（即目录下包含的其它文件的名称）。</p><p>要想在目录下创建文件或删除原有文件，需要同时拥有对该目录的执行和写权限。</p><p>所以由此可知，如果需要对文件进行读、写或执行等操作，不光是需要拥有该文件本身的读、写或执行权限，还需要拥有文件所在目录的执行权限。</p><p><strong>检查文件权限</strong> <strong>access</strong></p><p>使用该函数需要包含头文件&lt;unistd.h&gt;</p><p><strong>修改文件权限</strong> <strong>chmod</strong>/<strong>fchmod</strong> </p><p>使用该函数需要包含头文件&lt;sys/stat.h&gt;。</p><p>rwxrwxrwx（0777）</p><p>rw-r–r–（0644）</p><p>umask命令用于查看/设置权限掩码，权限掩码主要用于对新建文件的权限进行屏蔽</p><p>调用 open 函数新建文件时，文件实际的权限并不等于 mode 参数所描述的权限，而是通过如下关系得到实际权限：mode &amp; ~umask</p><p>譬如调用 open 函数新建文件时，mode 参数指定为 0777，假设 umask 为 0002，那么实际权限为：0777 &amp; (~0002) = 0775</p><p>umask 权限掩码是进程的一种属性，用于指明该进程新建文件或目录时，应屏蔽哪些权限位。进程的umask 通常继承至其父进程</p><p>umask 函数用于设置进程的权限掩码，该函数是一个系统调用（可通过”man 2 umask”命令查看）</p><p>使用该命令需要包含头文件&lt;sys/types.h&gt;和&lt;sys/stat.h&gt;</p><p><strong>文件的时间属性</strong></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>st_atim</td><td>文件最后被访问的时间</td></tr><tr><td>st_mtim</td><td>文件内容最后被修改的时间</td></tr><tr><td>st_ctim</td><td>文件状态最后被改变的时间</td></tr></tbody></table><ul><li>文件最后被访问的时间：访问指的是读取文件内容，文件内容最后一次被读取的时间，譬如使用read()函数读取文件内容便会改变该时间属性；</li><li>文件内容最后被修改的时间：文件内容发生改变，譬如使用 write()函数写入数据到文件中便会改变该时间属性；</li><li>文件状态最后被改变的时间：状态更改指的是该文件的 inode 节点最后一次被修改的时间，譬如更改文件的访问权限、更改文件的用户 ID、用户组 ID、更改链接数等</li></ul><p><strong>utime()、utimes()修改时间属性</strong></p><p>time()是 Linux 系统调用，用于获取当前时间（也可以直接将 times 参数设置为 NULL，这样就不需要使用 time 函数来获取当前时间了），单位为秒</p><p>可以使用 date 命令查看当前系统时间</p><p>用于显式修改文件时间戳，它们是 <strong>futimens()和 utimensat()</strong></p><ul><li>可按纳秒级精度设置时间戳。相对于提供微秒级精度的 utimes()，这是重大改进！</li><li>可单独设置某一时间戳。譬如，只设置访问时间、而修改时间保持不变，如果要使用 utime()或 utimes()来实现此功能，则需要首先使用 stat()获取另一个时间戳的值，然后再将获取值与打算变更的时间戳一同指定。</li><li>可独立将任一时间戳设置为当前时间。使用 utime()或 utimes()函数虽然也可以通过将 times 参数设置为 NULL 来达到将时间戳设置为当前时间的效果，但是不能单独指定某一个时间戳，必须全部设置为当前时间（不考虑使用额外函数获取当前时间的方式，譬如 time()）。</li></ul><p><strong>符号链接（软链接）与硬链接</strong></p><p>Tips：使用 ln 命令可以为一个文件创建软链接文件或硬链接文件，用法如下：</p><p>硬链接：ln 源文件 链接文件</p><p>软链接：ln -s 源文件 链接文件</p><p>使用 ln 命令创建的两个硬链接文件与源文件 test_file 都拥有相同的 inode 号，既然inode 相同，也就意味着它们指向了物理硬盘的同一个区块，仅仅只是文件名字不同而已，创建出来的硬链接文件与源文件对文件系统来说是完全平等的关系inode 数据结结构中会记录文件的链接数，这个链接数指的就是硬链接数，struct stat 结构体中的st_nlink 成员变量就记录了文件的链接数</p><p>当为文件每创建一个硬链接，inode 节点上的链接数就会加一，每删除一个硬链接，inode 节点上的链接数就会减一，直到为 0，inode 节点和对应的数据块才会被文件系统所回收，也就意味着文件已经从文件系统中被删除了</p><p>当源文件被删除之后，软链接文件依然存在，但此时它指向的是一个无效的文件路径，这种链接文件被称为悬空链接</p><p><strong>创建硬链接</strong> **link()**需要包含头文件&lt;unistd.h&gt;。</p><p><strong>创建软链接</strong> **symlink()**需要包含头文件&lt;unistd.h&gt;</p><p>使用系统调用 readlink<strong>读取软链接文件</strong>中存储的路径信息</p><p>目录（文件夹）在 Linux 系统也是一种文件，是一种特殊文件，同样可以使用前面给大家介绍 open、read 等这些系统调用以及 C 库函数对其进行操作，但是目录作为一种特殊文件，并不适合使用前面介绍的文件 I/O 方式进行读写等操作。在 Linux 系统下，会有一些专门的系统调用或 C 库函数用于对文件夹进行操作，譬如：打开、创建文件夹、删除文件夹、读取文件夹以及遍历文件夹中的文件等</p><ul><li>普通文件由 inode 节点和数据块构成</li><li>目录由 inode 节点和目录块构成</li></ul><p>在 Linux 系统下，提供了专门用于创建目录 mkdir()以及删除目录 rmdir 相关的系统调用</p><p>可以使用 opendir()、readdir()和 closedir()来打开、读取以及关闭目录</p><p>Tips：“流”是从自然界中抽象出来的一种概念，有点类似于自然界当中的水流，在文件操作中，文件内容数据类似池塘中存储的水，N 个字节数据被读取出来或将 N 个字节数据写入到文件中，这些数据就构成了字节流。</p><p>“流”这个概念是动态的，而不是静态的。编程当中提到这个概念，一般都是与 I/O 相关，所以也经常叫做 I/O 流；但对于目录这种特殊文件来说，这里将目录块中存储的数据称为目录流，存储了一个一个的目录项（目录条目）。</p><p>rewinddir()是 C 库函数，可将目录流重置为目录起点，以便对 readdir()的下一次调用将从目录列表中的第一个文件开始</p><p>Linux 下的每一个进程都有自己的当前工作目录（current working directory），当前工作目录是该进程解析、搜索相对路径名的起点（不是以” / “斜杆开头的绝对路径）</p><p>一般情况下，运行一个进程时、其父进程的当前工作目录将被该进程所继承，成为该进程的当前工作目录。可通过 getcwd 函数来获取进程的当前工作目录</p><p>系统调用 chdir()和 fchdir()可以用于更改进程的当前工作目录</p><p>unlink()用于删除一个文件（不包括目录）</p><p>remove()是一个 C 库函数，用于移除一个文件或空目录</p><p>借助于 rename()既可以对文件进行重命名，又可以将文件移至同一文件系统中的另一个目录下</p><p>根据 oldpath、newpath 的不同，有以下不同的情况需要进行说明：</p><ul><li>若 newpath 参数指定的文件或目录已经存在，则将其覆盖；</li><li>若 newpath 和 oldpath 指向同一个文件，则不发生变化（且调用成功）。</li><li>rename()系统调用对其两个参数中的软链接均不进行解引用。如果 oldpath 是一个软链接，那么将重命名该软链接；如果 newpath 是一个软链接，则会将其移除、被覆盖。 </li><li>如果 oldpath 指代文件，而非目录，那么就不能将 newpath 指定为一个目录的路径名。要想重命名一个文件到某一个目录下，newpath 必须包含新的文件名。</li><li>如果 oldpath 指代为一个目录，在这种情况下，newpath 要么不存在，要么必须指定为一个空目录。</li><li>oldpath 和 newpath 所指代的文件必须位于同一文件系统。由前面的介绍，可以得出此结论！不能对.（当前目录）和..（上一级目录）进行重命名。</li></ul><hr><p>参考资料：正点原子嵌入式Linux C应用编程指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;可以通过 stat 命令或者 ls -l 命令来查看文件类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘ - ‘：普通文件&lt;/li&gt;
&lt;li&gt;‘ d ‘：目录文件&lt;/li&gt;
&lt;li&gt;‘ c ‘：字</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note51.6-标准IO库</title>
    <link href="https://www.chenzhan.club/2021/07/15/note51-6-%E6%A0%87%E5%87%86IO%E5%BA%93/"/>
    <id>https://www.chenzhan.club/2021/07/15/note51-6-%E6%A0%87%E5%87%86IO%E5%BA%93/</id>
    <published>2021-07-15T07:15:44.000Z</published>
    <updated>2021-07-19T08:23:36.166Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>标准</strong> <strong>I/O</strong> <strong>库</strong></p><p><strong>FILE</strong> <strong>指针</strong></p><p>进程将从标准输入（stdin）文件中得到输入数据，将正常输出数据（譬如程序中 printf 打印输出的字符串）输出到标准输出（stdout）文件，而将错误信息（譬如函数调用报错打印的信息）输出到标准错误（stderr）文件</p><p>在标准 I/O 中，可以使用 stdin、stdout、stderr 来表示标准输入、标准输出和标准错误</p><p><strong>打开文件</strong> <strong>fopen()</strong></p><p><strong>读文件和写文件</strong>fread()和 fwrite()</p><p><strong>fseek</strong> <strong>定位</strong></p><p>库函数 ftell()可用于获取文件当前的读写位置偏移量</p><p>库函数 feof()用于测试参数 stream 所指文件的 end-of-file 标志，如果 end-of-file 标志被设置了，则调用feof()函数将返回一个非零值，如果 end-of-file 标志没有被设置，则返回 0</p><p>当文件的读写位置移动到了文件末尾时，end-of-file 标志将会被设置</p><p>库函数 ferror()用于测试参数 stream 所指文件的错误标志，如果错误标志被设置了，则调用 ferror()函数将返回一个非零值，如果错误标志没有被设置，则返回 0</p><p>当对文件的 I/O 操作发生错误时，错误标志将会被设置</p><p>库函数 clearerr()用于清除 end-of-file 标志和错误标志</p><p>格式化输出还包括：printf()、fprintf()、dprintf()、sprintf()、snprintf()这 4 个库函数</p><p>格式化输入包括：scanf()、fscanf()、sscanf()</p><p>C 库函数提供了 3 个格式化输入函数，包括：scanf()、fscanf()、sscanf()</p><table><thead><tr><th>mode</th><th>说明</th><th>对应于 open()函数的 flags 参数取值</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件</td><td>O_RDONLY</td></tr><tr><td>r+</td><td>以可读、可写方式打开文件</td><td>O_RDWR</td></tr><tr><td>……</td><td>…..</td><td>……</td></tr></tbody></table><p><strong>I/O</strong> <strong>缓冲</strong></p><p><strong>文件</strong> <strong>I/O</strong> <strong>的内核缓冲</strong></p><p><strong>刷新文件</strong> <strong>I/O</strong> <strong>的内核缓冲区</strong></p><p>Linux 中提供了一些系统调用可用于控制文件 I/O 内核缓冲，包括系统调用 sync()、syncfs()、fsync()以 及 fdatasync()</p><p><strong>控制文件</strong> <strong>I/O</strong> <strong>内核缓冲的标志</strong></p><p>在调用 open()函数时，指定 O_DSYNC 标志，其效果类似于在每个 write()调用之后调用 fdatasync()函数进行数据同步</p><p>在调用 open()函数时，指定 O_SYNC 标志，使得每个 write()调用都会自动将文件内容数据和元数据刷新到磁盘设备中，其效果类似于在每个 write()调用之后调用 fsync()函数进行数据同步</p><p>在程序中频繁调用 fsync()、fdatasync()、sync()（或者调用 open 时指定 O_DSYNC 或 O_SYNC 标志）对性能的影响极大，大部分的应用程序是没有这种需求的，所以在大部分应用程序当中基本不会使用到</p><p><strong>直接</strong> <strong>I/O**</strong>：绕过内核缓冲**</p><p>Linux 允许应用程序在执行文件 I/O 操作时绕过内核缓冲区，从用户空间直接将数据传递到文件或磁盘设备，把这种操作也称为直接 I/O（direct I/O）或裸 I/O（raw I/O）</p><p>执行直接 I/O 时，必须要遵守以下三个对齐限制要 求：</p><ul><li>应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐； </li><li>写文件时，文件的位置偏移量必须是块大小的整数倍；</li><li>写入到文件的数据大小必须是块大小的整数倍。</li></ul><p>如果不满足以上任何一个要求，调用 write()均为以错误返回 Invalid argument</p><p>可以使用 tune2fs 命令进行查看磁盘分区的块大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -l &#x2F;dev&#x2F;sda1 | grep &quot;Block size&quot;</span><br></pre></td></tr></table></figure><p>-l 后面指定了需要查看的磁盘分区，可以使用 df -h 命令查看 Ubuntu 系统的根文件系统所挂载的磁盘分区</p><p>使用 tune2fs 命令查看该分区的块大小</p><p>Tips：_GNU_SOURCE 宏可用于开启/禁用 Linux 系统调用和 glibc 库函数的一些功能、特性，要打开这些特性，需要在应用程序中定义该宏，定义该宏之后意味着用户应用程序打开了所有的特性；默认情况下，_GNU_SOURCE 宏并没有被定义，所以当使用到它控制的一些特性时，应用程序编译将会报错！定义该宏的方式有两种：</p><ul><li>直接在源文件中定义：#define _GNU_SOURCE_</li><li>_gcc 编译时使用-D 选项定义_GNU_SOURCE 宏：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -D_GNU_SOURCE -o testApp testApp.c</span><br></pre></td></tr></table></figure><p>gcc 的-D 选项可用于定义一个宏，并且该宏定义在整个源码工程中都是生效的，是一个全局宏定义</p><p>C 语言提供了一些库函数可用于对标准 I/O 的 stdio 缓冲区进行相关的一些设置，包括 setbuf()、setbuffer()以及 setvbuf()</p><p><strong>标准输出</strong> <strong>printf()**</strong>的行缓冲模式**</p><p><strong>刷新</strong> <strong>stdio</strong> <strong>缓冲区</strong></p><p><strong>㈠、关闭文件时刷新</strong> <strong>stdio</strong> <strong>缓冲区</strong></p><p><strong>㈡、程序退出时刷新</strong> <strong>stdio</strong> <strong>缓冲区</strong></p><p>关于刷新 stdio 缓冲区相关内容，最后进行一个总结：</p><ul><li>调用 fflush()库函数可强制刷新指定文件的 stdio 缓冲区；</li><li>调用 fclose()关闭文件时会自动刷新文件的 stdio 缓冲区；</li><li>程序退出时会自动刷新 stdio 缓冲区（注意区分不同的情况）。</li></ul><p>首先应用程序调用标准 I/O 库函数将用户数据写入到 stdio 缓冲区中，stdio 缓冲区是由 stdio 库所维护的用户空间缓冲区。针对不同的缓冲模式，当满足条件时，stdio 库会调用文件 I/O（系统调用 I/O）将 stdio 缓冲区中缓存的数据写入到内核缓冲区中，内核缓冲区位于内核空间。最终由内核向磁盘设备发起读写操作，将内核缓冲区中的数据写入到磁盘（或者从磁盘设备读取数据到内核缓冲区）。</p><p>应用程序调用库函数可以对 stdio 缓冲区进行相应的设置，设置缓冲区缓冲模式、缓冲区大小以及由调用者指定一块空间作为 stdio 缓冲区，并且可以强制调用 fflush()函数刷新缓冲区；而对于内核缓冲区来说，应用程序可以调用相关系统调用对内核缓冲区进行控制，譬如调用 fsync()、fdatasync()或 sync()来刷新内核缓冲区（或通过 open 指定 O_SYNC 或 O_DSYNC 标志），或者使用直接 I/O 绕过内核缓冲区（open 函数指定 O_DIRECT 标志）</p><p><strong>库函数 fileno()可以将标准 I/O 中使用的 FILE 指针转换为文件 I/O 中所使用的文件描述符，而 fdopen()则进行着相反的操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fileno(FILE *stream);</span><br><span class="line">FILE *fdopen(int fd, const char *mode);</span><br></pre></td></tr></table></figure><hr><p>参考资料：正点原子嵌入式Linux C应用编程指南V1.0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;strong&gt;标准&lt;/strong&gt; &lt;strong&gt;I/O&lt;/strong&gt; &lt;strong&gt;库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FILE&lt;/strong&gt; &lt;s</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note50.10-《UNIX网络编程卷1》第一章习题</title>
    <link href="https://www.chenzhan.club/2021/07/14/note50-10-%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98/"/>
    <id>https://www.chenzhan.club/2021/07/14/note50-10-%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98/</id>
    <published>2021-07-14T13:59:14.000Z</published>
    <updated>2021-07-19T08:24:20.108Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>1.1 找出自己的网络拓扑的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">chenzhan@chenzhan-virtual-machine:&#x2F;$ netstat -ni</span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line"></span><br><span class="line">ens33      1500 0       229      0      0 0           279      0      0      0 BMRU</span><br><span class="line"></span><br><span class="line">lo        65536 0       244      0      0 0           244      0      0      0 LRU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chenzhan@chenzhan-virtual-machine:&#x2F;$ netstat -nr</span><br><span class="line">内核 IP 路由表</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG        0 0          0 ens33</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 ens33</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 ens33</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chenzhan@chenzhan-virtual-machine:&#x2F;$ ifconfig ens33</span><br><span class="line">ens33     Link encap:以太网  硬件地址 00:0c:29:f7:fa:d7  </span><br><span class="line">          inet 地址:192.168.1.242  广播:192.168.1.255  掩码:255.255.255.0</span><br><span class="line">          inet6 地址: 2409:8955:6d8:de9:297e:a328:e294:7db2&#x2F;64 Scope:Global</span><br><span class="line">          inet6 地址: fe80::5d6a:3ff1:9168:b741&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  跃点数:1</span><br><span class="line">          接收数据包:235 错误:0 丢弃:0 过载:0 帧数:0</span><br><span class="line">          发送数据包:284 错误:0 丢弃:0 过载:0 载波:0</span><br><span class="line">          碰撞:0 发送队列长度:1000 </span><br><span class="line">          接收字节:30015 (30.0 KB)  发送字节:26084 (26.0 KB)</span><br><span class="line"></span><br><span class="line">chenzhan@chenzhan-virtual-machine:&#x2F;$ ping -b 192.168.1.255</span><br><span class="line">WARNING: pinging broadcast address</span><br><span class="line">PING 192.168.1.255 (192.168.1.255) 56(84) bytes of data.</span><br></pre></td></tr></table></figure><p>1.2 测试TCP时间获取客户程序，以不同IP地址作为命令行参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ .&#x2F;ONE 127.0.0.1</span><br><span class="line">14 JUL 2021 22:05:17 CST</span><br><span class="line"></span><br><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ .&#x2F;ONE 192.168.1.54</span><br><span class="line">connect error: No route to host</span><br><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ .&#x2F;ONE 127.5.5.5</span><br><span class="line">14 JUL 2021 22:06:32 CST</span><br></pre></td></tr></table></figure><p>1.3 改socket的第一参数为9999，结果？找出所输出出错的errno值。如何找到更多？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ vi daytimetcpcli.c </span><br><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ gcc daytimetcpcli.c -o ONE -lunp</span><br><span class="line">chenzhan@chenzhan-virtual-machine:~&#x2F;unixtcp&#x2F;1_daytimetcpcli$ .&#x2F;ONE  127.0.0.1</span><br><span class="line">socket error: Address family not supported by protocol</span><br><span class="line"></span><br><span class="line">应该是Socket包裹函数，err_sys</span><br><span class="line"></span><br><span class="line">man socket&#x2F;error</span><br><span class="line">或者</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">    if ( (sockfd &#x3D; socket(9999, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">perror(“socket error”);</span><br><span class="line"></span><br><span class="line">socket error: Address family not supported by protocol</span><br><span class="line">connect error: Bad file descriptor</span><br></pre></td></tr></table></figure><p>1.4 加一个计数器，返回read大于零的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0;</span><br><span class="line">while(...)&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">printf(&quot;%d\n&quot;,sum);</span><br><span class="line">exit(0);</span><br><span class="line"></span><br><span class="line">16 JUL 2021 09:43:22 CST</span><br><span class="line">1</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;1.1 找出自己的网络拓扑的信息&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="网络编程" scheme="https://www.chenzhan.club/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>note49.6-深入探究文件I/O</title>
    <link href="https://www.chenzhan.club/2021/07/13/note49-6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6%E6%96%87%E4%BB%B6I-O/"/>
    <id>https://www.chenzhan.club/2021/07/13/note49-6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6%E6%96%87%E4%BB%B6I-O/</id>
    <published>2021-07-13T09:02:53.000Z</published>
    <updated>2021-07-19T08:26:20.979Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>硬盘的最小存储单位叫做“扇区”（Sector），每个扇区储存 512 字节（相当于 0.5KB）</p><p>由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是 4KB，即连续八个 sector 组成一个 block</p><p>磁盘在进行分区、格式化的时候会将其分为两个区域，一个是数据区，用于存储文件中的数据；另一个是 inode 区，用于存放 inode table（inode 表），inode table 中存放的是一个一个的 inode（也成为 inode节点），不同的 inode 就可以表示不同的文件，每一个文件都必须对应一个 inode，inode 实质上是一个结构体，这个结构体中有很多的元素，不同的元素记录了文件了不同信息，譬如文件字节大小、文件所有者、文件对应的读/写/执行权限、文件时间戳（创建时间、更新时间等）、文件类型、文件数据存储的 block（块）位置等等信息</p><p><strong>通过”ls -i”命令查看文件的 inode 编号</strong>（还可以使用 stat 命令查看）</p><p>打开一个文件，系统内部会将这个过程分为三步：</p><ol><li><p>系统找到这个文件名所对应的 inode 编号；</p></li><li><p>通过 inode 编号从 inode table 中找到对应的 inode 结构体；</p></li><li><p>根据 inode 结构体中记录的信息，确定文件数据所在的 block，并读出数据。</p></li></ol><p>调用 open 函数去打开文件的时候，内核会申请一段内存（一段缓冲区），并且将静态文件的数据内容从磁盘这些存储设备中读取到内存中进行管理、缓存（也把内存中的这份文件数据叫做动态文件、内核缓冲区）。打开文件后，以后对这个文件的读写操作，都是针对内存中这一份动态文件进行相关的操作，而并不是针对磁盘中存放的静态文件</p><p>当对动态文件进行读写操作后，此时内存中的动态文件和磁盘设备中的静态文件就不同步了，数据的同步工作由内核完成，内核会在之后将内存这份动态文件更新（同步）到磁盘设备中</p><p>在 Linux 系统中，内核会为每个进程设置一个专门的数据结构用于管理该进程，譬如用于记录进程的状态信息、运行特征等，我们把这个称为进程控制块（Process control block，缩写PCB）</p><p>PCB 数据结构体中有一个指针指向了文件描述符表（File descriptors），文件描述符表中的每一个元素索引到对应的文件表（File table），文件表也是一个数据结构体，其中记录了很多文件相关的信息，譬如文件状态标志、引用计数、当前文件的读写偏移量以及 i-node 指针（指向该文件对应的 inode）等，进程打开的所有文件对应的文件描述符都记录在文件描述符表中，每一个文件描述符都会指向一个对应的文件表</p><p>Linux 系统下对常见的错误做了一个编号，每一个编号都代表着每一种不同的错误类型，当函数执行发生错误的时候，操作系统会将这个错误所对应的编号赋值给 errno 变量，每一个进程（程序）都维护了自己的 errno 变量，它是程序中的全局变量，该变量用于存储就近发生的函数执行错误编号，也就意味着下一次的错误码会覆盖上一次的错误码</p><p>通过 man 手册便可以查到一个函数出错时系统是否会设置 errno</p><p>只需要在我们程序当中包含**&lt;errno.h&gt;**头文件即可获取系统所维护的这个errno变量</p><p>**strerror()**，该函数可以将对应的 errno 转换成适合我们查看的字符串信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char *strerror(int errnum);</span><br></pre></td></tr></table></figure><p>可以使用 <strong>perror</strong> 函数来查看错误信息，一般用的最多的还是这个函数，调用此函数不需要传入 errno，函数内部会自己去获取 errno 变量的值，调用此函数会直接将错误提示字符串打印出来，而不是返回字符串，除此之外还可以在输出的错误提示字符串之前加入自己的打印信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void perror(const char *s);</span><br></pre></td></tr></table></figure><p>在 Linux 系统下，进程（程序）退出可以分为正常退出和异常退出</p><p>在 Linux 系统下，进程正常退出除了可以使用 return 之外，还可以使用 exit()、_exit()以及_Exit()</p><p>main 函数中使用 return 后返回，return 执行后把控制权交给调用函数，结束该进程。调用_exit()函数会清除其使用的内存空间，并销毁其在内核中的各种数据结构，关闭进程的所有文件描述符，并结束进程、将控制权交给操作系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure><p>调用函数需要传入 status 状态标志，0 表示正常结束、若为其它值则表示程序执行过程中检测到有错误发生，_exit()和_Exit()两者等价，用法作用是一样的</p><p>exit()函数_exit()函数都是用来终止进程的，exit()是一个标准 C 库函数，而_exit()和_Exit()是系统调用。</p><p>执行 exit()会执行一些清理工作，最后调用_exit()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure><p><strong>空洞文件</strong>对多线程共同操作文件是及其有用的</p><p><strong>一个进程内多次</strong> <strong>open</strong> <strong>打开同一个文件，那么会得到多个不同的文件描述符 fd，同理在关闭文件的时候也需要调用 close 依次关闭各个文件描述符。</strong></p><p>子进程会继承父进程的文件描述符</p><p><strong>一个进程内多次</strong> <strong>open</strong> <strong>打开同一个文件，在内存中并不会存在多份动态文件</strong></p><p>当调用 open 函数的时候，会将文件数据（文件内容）从磁盘等块设备读取到内存中，将文件数据在内存中进行维护，内存中的这份文件数据我们就把它称为动态文件</p><p><strong>一个进程内多次</strong> <strong>open</strong> <strong>打开同一个文件，不同文件描述符所对应的读写位置偏移量是相互独立的</strong></p><p>Tips：多个不同的进程中调用 open()打开磁盘中的同一个文件，同样在内存中也只是维护了一份动态文件，多个进程间共享，它们有各自独立的文件读写位置偏移量。动态文件何时被关闭呢？当文件的引用计数为 0 时，系统会自动将其关闭，同一个文件被打开多次，文件表中会记录该文件的引用计数</p><p>在 Linux 系统中，open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新的文件描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，复制得到的文件描述符和旧的文件描述符拥有相同的权限，<strong>可以使用 dup 或 dup2 这两个系统调用对文件描述符进行复制</strong>，在使用完毕之后也需要使用 close 来关闭文件描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd);</span><br></pre></td></tr></table></figure><p>dup 系统调用分配的文件描述符是由系统分配的，遵循文件描述符分配原则，并不能自己指定一个文件描述符，这是 dup 系统调用的一个缺陷；而 dup2 系统调用修复了这个缺陷，可以手动指定文件描述符，而不需要遵循文件描述符分配原则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup2(int oldfd, int newfd);</span><br></pre></td></tr></table></figure><p>可以对同一个文件描述符 fd 调用 dup 或 dup2 函数复制多次，得到多个不同的文件描述符文件共享指的是同一个文件（譬如磁盘上的同一个文件，对应同一个 inode）被多个独立的读写体同时进行 IO 操作。多个独立的读写体大家可以将其简单地理解为对应于同一个文件的多个不同的文件描述符</p><p><strong>常见的三种文件共享的实现方式</strong></p><p><strong>同一个进程中多次调用</strong> <strong>open</strong> <strong>函数打开同一个文件</strong></p><p>多次调用 open 函数打开同一个文件会得到多个不同的文件描述符，并且多个文件描述符对应多个不同的文件表，所有的文件表都索引到了同一个 inode 节点，也就是磁盘上的同一个文件</p><p><strong>不同进程中分别使用</strong> <strong>open</strong> <strong>函数打开同一个文件</strong></p><p>进程 1 和进程 2 分别是运行在 Linux 系统上两个独立的进程（理解为两个独立的程序），在他们各自的程序中分别调用 open 函数打开同一个文件，进程 1 对应的文件描述符为 fd1，进程 2 对应的文件描述符为fd2，fd1 指向了进程 1 的文件表 1，fd2 指向了进程 2 的文件表 2；各自的文件表都索引到了同一个 inode 节 点，从而实现共享文件</p><p><strong>同一个进程中通过 dup（dup2）函数对文件描述符进行复制</strong></p><p><strong>竞争冒险</strong></p><p><strong>O_APPEND</strong> <strong>实现原子操作</strong></p><p><strong>pread()**</strong>和** <strong>pwrite()</strong></p><p>调用 pread 相当于调用 lseek 后再调用 read</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t pread(int fd, void *buf, size_t count, off_t offset);</span><br><span class="line">ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);</span><br></pre></td></tr></table></figure><p>：O_EXCL 可以用于测试一个文件是否存在，如果不存在则创建此文件，如果存在则返回错误，这使得测试和创建两者成为一个原子操作</p><p>fcntl()函数可以对一个已经打开的文件描述符执行一系列控制操作，譬如复制一个文件描述符（与 dup、dup2 作用相同）、获取/设置文件描述符标志、获取/设置文件状态标志等，类似于一个多功能文件描述符管理工具箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int fcntl(int fd, int cmd, ... &#x2F;* arg *&#x2F; )</span><br></pre></td></tr></table></figure><p>ioctl()可以认为是一个文件 IO 操作的杂物箱，可以处理的事情非常杂、不统一，一般用于操作特殊文件或硬件外设</p><p>使用系统调用 truncate()或 ftruncate()可将普通文件截断为指定字节长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">int truncate(const char *path, off_t length);</span><br><span class="line">int ftruncate(int fd, off_t length);</span><br></pre></td></tr></table></figure><p>ftruncate()使用文件描述符 fd 来指定目标文件，而 truncate()则直接使用文件路径 path 来指定目标文件</p><p>将文件截断为参数 length 指定的字节长度，如果文件目前的大小大于参数 length 所指定的大小，则多余的数据将被丢失，类似于多余的部分被“砍”掉了；如果文件目前的大小小于参数 length 所指定的大小，则将其进行扩展，对扩展部分进行读取将得到空字节”\0”</p><p>使用 ftruncate()函数进行文件截断操作之前，必须调用 open()函数打开该文件得到文件描述符，并且必须要具有可写权限，也就是调用 open()打开文件时需要指定 O_WRONLY 或 O_RDWR</p><p>调用这两个函数并不会导致文件读写位置偏移量发生改变，所以截断之后一般需要重新设置文件当前的读写位置偏移量，以免由于之前所指向的位置已经不存在而发生错误</p><p>调用成功返回 0，失败将返回-1，并设置 errno 以指示错误原因</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;硬盘的最小存储单位叫做“扇区”（Sector），每个扇区储存 512 字节（相当于 0.5KB）&lt;/p&gt;
&lt;p&gt;由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note48.6-文件IO</title>
    <link href="https://www.chenzhan.club/2021/07/13/note48-6-%E6%96%87%E4%BB%B6IO/"/>
    <id>https://www.chenzhan.club/2021/07/13/note48-6-%E6%96%87%E4%BB%B6IO/</id>
    <published>2021-07-13T01:21:58.000Z</published>
    <updated>2021-07-19T08:26:12.441Z</updated>
    
    <content type="html"><![CDATA[<pre><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code></pre><p>​        C 语言库是应用层使用的一套函数库，在 Linux 下，通常以动态（.so）库文件的形式提供，存放在根文件系统/lib 目录下，C 语言库函数构建于系统调用之上，也就是说库函数其实是由系统调用封装而来的，是以动态库文件的形式提供的，通常存放在/lib 目录，它的命名方式通常是libc.so.6，不过这个是一个软链接文件，它会链接到真正的库文件</p><p>​        在 Linux 系 统 下 ， 使 用 的 C 语 言 库 为 GNU C 语 言 函 数 库 （ 也 叫 作 glibc ）</p><h3 id="open-打开文件"><a href="#open-打开文件" class="headerlink" title="open 打开文件"></a><strong>open</strong> <strong>打开文件</strong></h3><p><strong>文件描述符</strong></p><p>​        调用 open 函数会有一个返回值，在 open函数执行成功的情况下，会返回一个非负整数，该返回值就是一个文件描述符（file descriptor），这说明文件描述符是一个非负整数；对于 Linux 内核而言，所有打开的文件都会通过文件描述符进行索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 打开目标文件 dest_file(只写方式) *&#x2F;</span><br><span class="line">fd2 &#x3D; open(&quot;.&#x2F;dest_file&quot;, O_WRONLY);</span><br><span class="line">if (-1 &#x3D;&#x3D; fd2) &#123;</span><br><span class="line">ret &#x3D; fd2;</span><br><span class="line">goto out1;</span><br><span class="line">&#125;</span><br><span class="line">out1:</span><br><span class="line">&#x2F;* 关闭源文件 *&#x2F;</span><br><span class="line">close(fd1);</span><br><span class="line">return ret; &#125;</span><br></pre></td></tr></table></figure><p>​        当调用 open 函数打开一个现有文件或创建一个新文件时，内核会向进程返回一个文件描述符，<strong>用于指代被打开的文件</strong>，所有执行 IO 操作的系统调用都是通过文件描述符来索引到对应的文件</p><p>​        一个进程可以打开多个文件，但是在 Linux 系统中，一个进程可以打开的文件数是有限制，文件越大、打开的文件越多那占用的内存就越多，必然会对整个系统造成很大的影响，如果超过进程可打开的最大文件数限制，内核将会发送警告信号给对应的进程，然后结束进程；在 Linux 系统下，我们可以通过 ulimit 命令来查看进程可打开的最大文件数</p><p>​        所以对于一个进程来说，文件描述符是一种有限资源，文件描述符是从 0 开始分配的，每一个被打开的文件在同一个进程中都有一个唯一的文件描述符，不会重复，如果文件被关闭后，它对应的文件描述符将会被<strong>释放</strong>，那么这个文件描述符将可以再次分配给其它打开的文件、与对应的文件绑定起来</p><p>​        每次给打开的文件分配文件描述符都是从最小的没有被使用的文件描述符（如果Ulimit -n 查看得到的数值是1024 ，则是文件描述符共有 0~1023）开始</p><p>​        调用 open 函数打开文件的时候，分配的文件描述符一般都是<strong>从 3 开始</strong>，但是 0、1、2 这三个文件描述符已经默认被系统占用了，分别分配给了系统标注输入（0）、标注输出（1）以及标准错误（2）</p><p>​        标准输入一般对应的是键盘，可以理解为 0 便是打开键盘对应的设备文件时所得到的文件描述符；标准输出一般指的是 LCD 显示器，可以理解为 1 便是打开 LCD 设备对应的设备文件时所得到的文件描述符</p><p>​        在 Linux 系统下，可以通过 man 命令（也叫 man 手册）来查看某一个 Linux 系统调用的帮助信息，man命令可以将该系统调用的详细信息显示出来，譬如函数功能介绍、函数原型、参数、返回值以及使用该函数所需包含的头文件等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man 2 open #查看 open 函数的帮助信息</span><br><span class="line"></span><br><span class="line">man man #查看 man 函数的帮助信息</span><br></pre></td></tr></table></figure><p>​        Tips：man 命令后面跟着两个参数，数字 2 表示系统调用，man 命令除了可以查看系统调用的帮助信息外，还可以查看 Linux 命令（对应数字 1）以及标准 C 库函数（对应数字 3）所对应的帮助信息；最后一个参数 open 表示需要查看的系统调用函数名。</p><p>​        在应用程序中使用 open 函数时，需要包含 3 个头文件“#include &lt;sys/types.h&gt;”、“#include &lt;sys/stat.h&gt;”、“#include &lt;fcntl.h&gt;”</p><p><strong>函数参数和返回值含义如下：</strong></p><p>​        <strong>pathname：</strong>字符串类型，用于标识需要打开或创建的文件，可以包含路径（绝对路径或相对路径）信息，譬如：”./src_file”（当前目录下的 src_file 文件）、”/home/dengtao/hello.c”等；如果 pathname 是一个符号链接，会对其进行解引用。</p><p>​        <strong>flags：</strong>调用 open 函数时需要提供的标志，包括文件访问模式标志以及其它文件相关标志，这些标志使用宏定义进行描述，都是常量，open 函数提供了非常多的标志，我们传入 flags 参数时既可以单独使用某一个标志，也可以通过位或运算（|）将多个标志进行组合。</p><p>​        open 函数 flags 参数值介绍</p><table><thead><tr><th>标志</th><th>用途</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>以只读方式打开文件</td></tr><tr><td>O_WRONLY</td><td>以只写方式打开文件</td></tr><tr><td>O_RDWR</td><td>以可读可写方式打开文件</td></tr></tbody></table><p>​        这三个是文件访问权限标志，传入的flags 参数中必须要包含其中一种标志，而且只能包含一种，打开的文件只能按照这种权限来操作，譬如使用了 O_RDONLY 标志，就只能对文件进行读取操作，不能写操作。</p><table><thead><tr><th>O_CREAT</th><th>如果 pathname 参数指向的文件不存在则创建</th></tr></thead></table><p>​        使用此标志时，调用 open 函数需要传入第 3 个参数 mode，参数 mode 用 于指定新建文件的访问权限，稍后将对此进行说明。<strong>open 函数的第 3 个参数只有在使用了 O_CREAT 或 O_TMPFILE标志时才有效。</strong></p><table><thead><tr><th>O_DIRECTORY</th><th>O_EXCL</th><th>O_NOFOLLOW</th></tr></thead></table><p>​        Tips：不同内核版本所支持的 flags 标志是存在差别的，man 手册中对一些标志支持有简单地说明flags 参数时既可以单独使用某一个标志，也可以通过位或运算（|）将多个标志进行组合，譬如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;.&#x2F;src_file&quot;, O_RDONLY) &#x2F;&#x2F;单独使用某一个标志</span><br><span class="line">open(&quot;.&#x2F;src_file&quot;, O_RDONLY | O_NOFOLLOW) &#x2F;&#x2F;多个标志组合</span><br></pre></td></tr></table></figure><p>​        <strong>mode**</strong>：**此参数用于指定新建文件的访问权限，只有当 flags 参数中包含 O_CREAT 或 O_TMPFILE 标志时才有效（O_TMPFILE 标志用于创建一个临时文件）。权限对于文件来说是一个很重要的属性，那么在 Linux系统中，我们可以通过 touch 命令新建一个文件，此时文件会有一个默认的权限，如果需要修改文件权限，可通过 chmod 命令对文件权限进行修改，譬如在 Linux 系统下我们可以使用”ls -l”命令来查看到文件所对应的权限。</p><p>​        当我们调用 open 函数去新建一个文件时，也需要指定该文件的权限，而 mode 参数便用于指定此文件的权限，接下来看看我们该如何通过 mode 参数来表示文件的权限，首先 mode 参数的类型是 mode_t，这是一个 u32 无符号整形数据，权限表示方法如下所示：</p><blockquote><p>0000        000(S)        000(U)        000(G)        000(O)</p></blockquote><p>O—这 3 个 bit 位用于表示其他用户的权限；</p><p>G—这 3 个 bit 位用于表示同组用户（group）的权限，即与文件所有者有相同组 ID 的所有用户；</p><p>U—这 3 个 bit 位用于表示文件所属用户的权限，即文件或目录的所属者； </p><p>S—这 3 个 bit 位用于表示文件的特殊权限，文件特殊权限一般用的比较少。</p><p>​        3 个 bit 位中，按照 rwx 顺序来分配权限位（特殊权限除外），最高位（权值为 4）表示读权限，为 1 时表示具有读权限，为 0 时没有读权限；中间位（权值为 2）表示写权限，为 1 时表示具有写权限，为 0 时没有写权限；最低位（权值为 1）表示执行权限，为 1 时表示具有可执行权限，为 0 时没有执行权限</p><blockquote><p>最高权限表示方法：111111111（二进制表示）、777（八进制表示）、511（十进制表示）；</p><p>最高权限这里意味着所有用户对此文件都具有读权限、写权限以及执行权限。</p><p>111000000（二进制表示）：表示文件所属者具有读、写、执行权限，而同组用户和其他用户不具有任何权限；</p><p>100100100（二进制表示）：表示文件所属者、同组用户以及其他用户都具有读权限，但都没有写、执行权限。</p></blockquote><p>​        Tips：只有用户对该文件具有相应权限时，才可以使用对应的标志去打开文件，否则会打开失败！</p><p>​        在实际编程中，我们可以直接使用 Linux 中已经定义好的宏，不同的宏定义表示不同的权限，如下所示：</p><table><thead><tr><th>宏定义</th><th>说明</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>允许文件所属者读文件</td></tr><tr><td>S_IWUSR</td><td>允许文件所属者写文件</td></tr><tr><td>S_IXUSR</td><td>允许文件所属者执行文件</td></tr><tr><td>S_IRWXU</td><td>允许文件所属者读、写、执行文件</td></tr><tr><td>S_IRGRP</td><td>允许同组用户读文件</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>​        这些宏既可以单独使用，也可以通过位或运算将多个宏组合在一起，譬如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_IRUSR | S_IWUSR | S_IROTH</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong>成功将返回文件描述符，文件描述符是一个非负整数；失败将返回-1。</p><p><strong>open</strong> <strong>函数使用示例</strong></p><p>​        (1)使用 open 函数打开一个已经存在的文件（例如当前目录下的 app.c 文件），使用只读方式打开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fd &#x3D; open(&quot;.&#x2F;app.c&quot;, O_RDONLY)</span><br><span class="line">if (-1 &#x3D;&#x3D; fd)</span><br><span class="line">return fd;</span><br></pre></td></tr></table></figure><p>​        (2)使用 open 函数打开一个已经存在的文件（例如当前目录下的 app.c 文件），使用可读可写方式打开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fd &#x3D; open(&quot;.&#x2F;app.c&quot;, O_RDWR)</span><br><span class="line">if (-1 &#x3D;&#x3D; fd)</span><br><span class="line">return fd;</span><br></pre></td></tr></table></figure><p>​        (3)使用 open 函数打开一个指定的文件（譬如/home/dengtao/hello），使用可读可写方式,如果该文件是一个符号链接文件，则不对其进行解引用，直接返回错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fd &#x3D; open(&quot;&#x2F;home&#x2F;dengtao&#x2F;hello&quot;, O_RDWR | O_NOFOLLOW);</span><br><span class="line">if (-1 &#x3D;&#x3D; fd)</span><br><span class="line">return fd;</span><br></pre></td></tr></table></figure><p>​        (4)使用 open 函数打开一个指定的文件（譬如/home/dengtao/hello），如果该文件不存在则创建该文件，创建该文件时，将文件权限设置如下：</p><p>文件所属者拥有读、写、执行权限；同组用户与其他用户只有读权限。使用可读可写方式打开： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fd &#x3D; open(&quot;&#x2F;home&#x2F;dengtao&#x2F;hello&quot;, O_RDWR | O_CREAT, S_IRWXU | S_IRGRP | S_IROTH);</span><br><span class="line">if (-1 &#x3D;&#x3D; fd)</span><br><span class="line">return fd;</span><br></pre></td></tr></table></figure><h3 id="其它文件IO"><a href="#其它文件IO" class="headerlink" title="其它文件IO"></a>其它文件IO</h3><p><strong>write</strong> <strong>写文件</strong></p><p>​        调用 write 函数可向打开的文件写入数据，其函数原型如下所示（可通过”man 2 write”查看）：        首先使用 write 函数需要先包含 unistd.h 头文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br></pre></td></tr></table></figure><p><strong>read</strong> <strong>读文件</strong></p><p>​        调用 read 函数可从打开的文件中读取数据，其函数原型如下所示（可通过”man 2 read”查看）：</p><p>​        首先使用 read 函数需要先包含 unistd.h 头文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br></pre></td></tr></table></figure><p><strong>close</strong> <strong>关闭文件</strong></p><p>​        可调用 close 函数关闭一个已经打开的文件，其函数原型如下所示（可通过”man 2 close”查看）：</p><p>​        首先使用 close 函数需要先包含 unistd.h 头文件，当我们对文件进行 IO 操作完成之后，后续不再对文件进行操作时，需要将文件关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure><p><strong>lseek</strong></p><p>​        对于每个打开的文件，系统都会记录它的读写位置偏移量，我们也把这个读写位置偏移量称为读写偏移量，记录了文件当前的读写位置，当调用 read()或 write()函数对文件进行读写操作时，就会从当前读写位置偏移量开始进行数据读写。</p><p>​        读写偏移量用于指示 read()或 write()函数操作时文件的起始位置，会以相对于文件头部的位置偏移量来表示，文件第一个字节数据的位置偏移量为 0。</p><p>​        当打开文件时，会将读写偏移量设置为指向文件开始位置处，以后每次调用 read()、write()将自动对其进行调整，以指向已读或已写数据后的下一字节，因此，连续的调用 read()和 write()函数将使得读写按顺序递增，对文件进行操作。我们先来看看 lseek 函数的原型，如下所示（可通过”man 2 lseek”查看）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br></pre></td></tr></table></figure><hr><p>参考资料：正点原子《【正点原子】I.MX6U嵌入式Linux C应用编程指南V1.0》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;referrer&amp;quot; content=&amp;quot;no-referrer&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​        C 语言库是应用层使用的一套函数库，在 Linux 下，通常以动</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note47.8-STL初识</title>
    <link href="https://www.chenzhan.club/2021/07/11/note47-8-STL%E5%88%9D%E8%AF%86/"/>
    <id>https://www.chenzhan.club/2021/07/11/note47-8-STL%E5%88%9D%E8%AF%86/</id>
    <published>2021-07-11T15:47:00.000Z</published>
    <updated>2021-07-19T08:26:50.351Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h2><h3 id="STL的诞生"><a href="#STL的诞生" class="headerlink" title="STL的诞生"></a>STL的诞生</h3><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="STL中容器、算法、迭代器"><a href="#STL中容器、算法、迭代器" class="headerlink" title="STL中容器、算法、迭代器"></a>STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​    <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​    <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p><strong>算法：</strong>问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.begin();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pBegin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.begin(), v.end(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>vector中存放自定义数据类型，并打印输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">mName = name;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> mName;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(&amp;p1);</span><br><span class="line">v.push_back(&amp;p2);</span><br><span class="line">v.push_back(&amp;p3);</span><br><span class="line">v.push_back(&amp;p4);</span><br><span class="line">v.push_back(&amp;p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">Person * p = (*it);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">    </span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vector容器嵌套容器"><a href="#Vector容器嵌套容器" class="headerlink" title="Vector容器嵌套容器"></a>Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">v2.push_back(i + <span class="number">2</span>);</span><br><span class="line">v3.push_back(i + <span class="number">3</span>);</span><br><span class="line">v4.push_back(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line">v.push_back(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>资料来源：黑马程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h2 id=&quot;STL初识&quot;&gt;&lt;a href=&quot;#STL初识&quot; class=&quot;headerlink&quot; title=&quot;STL初识&quot;&gt;&lt;/a&gt;STL初识&lt;/h2&gt;&lt;h3 id=&quot;STL的诞生&quot;</summary>
      
    
    
    
    
    <category term="C++" scheme="https://www.chenzhan.club/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>note46.8-类和对象-多态</title>
    <link href="https://www.chenzhan.club/2021/07/11/note46-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/"/>
    <id>https://www.chenzhan.club/2021/07/11/note46-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</id>
    <published>2021-07-11T15:46:14.000Z</published>
    <updated>2021-07-19T08:27:26.084Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">DoSpeak(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line">DoSpeak(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;func();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Animal()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~Animal() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat(<span class="built_in">string</span> name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> Cat(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;Speak();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​    3. 拥有纯虚析构函数的类也属于抽象类</p><hr><p>资料：黑马程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h3&gt;&lt;h4 id=&quot;多态的基本概念&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="C++" scheme="https://www.chenzhan.club/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>note45.8-类和对象-继承</title>
    <link href="https://www.chenzhan.club/2021/07/11/note45-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.chenzhan.club/2021/07/11/note45-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/</id>
    <published>2021-07-11T15:42:15.000Z</published>
    <updated>2021-07-19T08:28:15.133Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Java ja;</span><br><span class="line">ja.header();</span><br><span class="line">ja.footer();</span><br><span class="line">ja.left();</span><br><span class="line">ja.content();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Python py;</span><br><span class="line">py.header();</span><br><span class="line">py.footer();</span><br><span class="line">py.left();</span><br><span class="line">py.content();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.header();</span><br><span class="line">cp.footer();</span><br><span class="line">cp.left();</span><br><span class="line">cp.content();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Java ja;</span><br><span class="line">ja.header();</span><br><span class="line">ja.footer();</span><br><span class="line">ja.left();</span><br><span class="line">ja.content();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Python py;</span><br><span class="line">py.header();</span><br><span class="line">py.footer();</span><br><span class="line">py.left();</span><br><span class="line">py.content();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.header();</span><br><span class="line">cp.footer();</span><br><span class="line">cp.left();</span><br><span class="line">cp.content();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B; </p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p>![img](D:/C++学习资料/匠心精作C++从0到1入门编程-学习编程不再难资料/第3阶段-C++核心编程 资料/讲义/assets/clip_image002.png)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>:</span><span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>:</span><span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandSon3</span> :</span><span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Son) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><p>![1545881904150](D:/C++学习资料/匠心精作C++从0到1入门编程-学习编程不再难资料/第3阶段-C++核心编程 资料/讲义/assets/1545881904150.png)</p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p>![1545882158050](D:/C++学习资料/匠心精作C++从0到1入门编程-学习编程不再难资料/第3阶段-C++核心编程 资料/讲义/assets/1545882158050.png)</p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s.func();</span><br><span class="line">s.Base::func();</span><br><span class="line">s.Base::func(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Son s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Son s;</span><br><span class="line">s.func();</span><br><span class="line">s.Base::func();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Son::func();</span><br><span class="line">Son::Base::func();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::func(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base1()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base2()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line"><span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.Base1::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.Base2::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​    两个派生类继承同一个基类</p><p>​    又有某个类同时继承者两个派生类</p><p>​    这种继承被称为菱形继承，或者钻石继承</p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span>   :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><hr><p>资料来源：黑马程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;继承是面向对象三大特性之一&lt;/s</summary>
      
    
    
    
    
    <category term="C++" scheme="https://www.chenzhan.club/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>note44.8-类和对象-友元和运算符重载</title>
    <link href="https://www.chenzhan.club/2021/07/11/note44-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%8F%8B%E5%85%83%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>https://www.chenzhan.club/2021/07/11/note44-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%8F%8B%E5%85%83%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2021-07-10T16:25:20.000Z</published>
    <updated>2021-07-19T08:28:58.632Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span><br><span class="line">friend void goodGay(Building * building);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Building()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">string m_BedRoom; &#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void goodGay(Building * building)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Building b;</span><br><span class="line">goodGay(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">goodGay();</span><br><span class="line">void visit();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">friend class goodGay;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Building();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line">private:</span><br><span class="line">string m_BedRoom;&#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay()</span><br><span class="line">&#123;</span><br><span class="line">building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.visit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">goodGay();</span><br><span class="line">void visit(); &#x2F;&#x2F;只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br><span class="line">void visit2(); </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span><br><span class="line">friend void goodGay::visit();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Building();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line">private:</span><br><span class="line">string m_BedRoom;&#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay()</span><br><span class="line">&#123;</span><br><span class="line">building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">goodGay  gg;</span><br><span class="line">gg.visit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;&#125;;</span><br><span class="line">Person(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_A &#x3D; a;</span><br><span class="line">this-&gt;m_B &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;成员函数实现 + 号运算符重载</span><br><span class="line">Person operator+(const Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A &#x3D; this-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B &#x3D; this-&gt;m_B + p.m_B;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">int m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局函数实现 + 号运算符重载</span><br><span class="line">&#x2F;&#x2F;Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span><br><span class="line">&#x2F;&#x2F;Person temp(0, 0);</span><br><span class="line">&#x2F;&#x2F;temp.m_A &#x3D; p1.m_A + p2.m_A;</span><br><span class="line">&#x2F;&#x2F;temp.m_B &#x3D; p1.m_B + p2.m_B;</span><br><span class="line">&#x2F;&#x2F;return temp;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运算符重载 可以发生函数重载 </span><br><span class="line">Person operator+(const Person&amp; p2, int val)  </span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A &#x3D; p2.m_A + val;</span><br><span class="line">temp.m_B &#x3D; p2.m_B + val;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">Person p1(10, 10);</span><br><span class="line">Person p2(20, 20);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数方式</span><br><span class="line">Person p3 &#x3D; p2 + p1;  &#x2F;&#x2F;相当于 p2.operaor+(p1)</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person p4 &#x3D; p3 + 10; &#x2F;&#x2F;相当于 operator+(p3,10)</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote></blockquote><h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Person(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_A &#x3D; a;</span><br><span class="line">this-&gt;m_B &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span><br><span class="line">&#x2F;&#x2F;void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int m_A;</span><br><span class="line">int m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局函数实现左移重载</span><br><span class="line">&#x2F;&#x2F;ostream对象只能有一个</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;</span><br><span class="line">return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">Person p1(10, 20);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#x2F;&#x2F;链式编程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyInteger() &#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="comment">//先++</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="comment">//再返回</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line"><span class="comment">//先返回</span></span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">out &lt;&lt; myint.m_Num;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myInt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ++myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyInteger myInt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myInt++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="keyword">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int a = 0;</span></span><br><span class="line"><span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a != b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; text &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">MyPrint myFunc;</span><br><span class="line">myFunc(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line"><span class="keyword">int</span> ret = add(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; MyAdd()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>资料来源：黑马程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h4 id=&quot;友元&quot;&gt;&lt;a href=&quot;#友元&quot; class=&quot;headerlink&quot; title=&quot;友元&quot;&gt;&lt;/a&gt;友元&lt;/h4&gt;&lt;p&gt;友元的关键字为  ==friend==&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="C++" scheme="https://www.chenzhan.club/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>note43.8-类和对象-对象特性</title>
    <link href="https://www.chenzhan.club/2021/07/07/note43-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
    <id>https://www.chenzhan.club/2021/07/07/note43-8-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/</id>
    <published>2021-07-07T13:02:55.000Z</published>
    <updated>2021-07-19T08:30:22.200Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p><strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;构造函数</span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;析构函数</span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p>两种分类方式：</p><p>​    按参数分为： 有参构造和无参构造</p><p>​    按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​    括号法</p><p>​    显示法</p><p>​    隐式转换法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、构造函数分类</span><br><span class="line">&#x2F;&#x2F; 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="line">&#x2F;&#x2F; 按照类型分类分为 普通构造和拷贝构造</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;无参（默认）构造函数</span><br><span class="line">Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;有参构造函数</span><br><span class="line">Person(int a) &#123;</span><br><span class="line">age &#x3D; a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;拷贝构造函数</span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">age &#x3D; p.age;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、构造函数的调用</span><br><span class="line">&#x2F;&#x2F;调用无参构造函数</span><br><span class="line">void test01() &#123;</span><br><span class="line">Person p; &#x2F;&#x2F;调用无参构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用有参的构造函数</span><br><span class="line">void test02() &#123;</span><br><span class="line">&#x2F;&#x2F;2.1  括号法，常用</span><br><span class="line">Person p1(10);</span><br><span class="line">&#x2F;&#x2F;注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="line">&#x2F;&#x2F;Person p2();</span><br><span class="line">&#x2F;&#x2F;2.2 显式法</span><br><span class="line">Person p2 &#x3D; Person(10); </span><br><span class="line">Person p3 &#x3D; Person(p2);</span><br><span class="line">&#x2F;&#x2F;Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><span class="line">&#x2F;&#x2F;2.3 隐式转换法</span><br><span class="line">Person p4 &#x3D; 10; &#x2F;&#x2F; Person p4 &#x3D; Person(10); </span><br><span class="line">Person p5 &#x3D; p4; &#x2F;&#x2F; Person p5 &#x3D; Person(p4); </span><br><span class="line">&#x2F;&#x2F;注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br><span class="line">&#x2F;&#x2F;Person p5(p4);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">&#x2F;&#x2F;test02();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">mAge &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">Person(int age) &#123;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">mAge &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">mAge &#x3D; p.mAge;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;析构函数在释放内存之前调用</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1. 使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="line">void test01() &#123;</span><br><span class="line"></span><br><span class="line">Person man(100); &#x2F;&#x2F;p对象已经创建完毕</span><br><span class="line">Person newman(man); &#x2F;&#x2F;调用拷贝构造函数</span><br><span class="line">Person newman2 &#x3D; man; &#x2F;&#x2F;拷贝构造</span><br><span class="line">&#x2F;&#x2F;Person newman3;</span><br><span class="line">&#x2F;&#x2F;newman3 &#x3D; man; &#x2F;&#x2F;不是调用拷贝构造函数，赋值操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 值传递的方式给函数参数传值</span><br><span class="line">&#x2F;&#x2F;相当于Person p1 &#x3D; p;</span><br><span class="line">void doWork(Person p1) &#123;&#125;</span><br><span class="line">void test02() &#123;</span><br><span class="line">Person p; &#x2F;&#x2F;无参构造函数</span><br><span class="line">doWork(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3. 以值方式返回局部对象</span><br><span class="line">Person doWork2()</span><br><span class="line">&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">return p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">Person p &#x3D; doWork2();</span><br><span class="line">cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">&#x2F;&#x2F;test01();</span><br><span class="line">&#x2F;&#x2F;test02();</span><br><span class="line">test03();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li></ul><ul><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;无参（默认）构造函数</span><br><span class="line">Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;有参构造函数</span><br><span class="line">Person(int a) &#123;</span><br><span class="line">age &#x3D; a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;拷贝构造函数</span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">age &#x3D; p.age;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(18);</span><br><span class="line">&#x2F;&#x2F;如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span><br><span class="line">Person p2(p1);</span><br><span class="line">cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span><br><span class="line">Person p1; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错</span><br><span class="line">Person p2(10); &#x2F;&#x2F;用户提供的有参</span><br><span class="line">Person p3(p2); &#x2F;&#x2F;此时如果用户没有提供拷贝构造，编译器会提供</span><br><span class="line">&#x2F;&#x2F;如果用户提供拷贝构造，编译器不会提供其他构造函数</span><br><span class="line">Person p4; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错</span><br><span class="line">Person p5(10); &#x2F;&#x2F;此时如果用户自己没有提供有参，会出错</span><br><span class="line">Person p6(p5); &#x2F;&#x2F;用户自己提供拷贝构造</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;无参（默认）构造函数</span><br><span class="line">Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;有参构造函数</span><br><span class="line">Person(int age ,int height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age &#x3D; age;</span><br><span class="line">m_height &#x3D; new int(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;拷贝构造函数  </span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span><br><span class="line">m_age &#x3D; p.m_age;</span><br><span class="line">m_height &#x3D; new int(*p.m_height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">if (m_height !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">int* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(18, 180);</span><br><span class="line">Person p2(p1);</span><br><span class="line">cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong>`构造函数()：属性1(值1),属性2（值2）… {}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;传统方式初始化</span><br><span class="line">&#x2F;&#x2F;Person(int a, int b, int c) &#123;</span><br><span class="line">&#x2F;&#x2F;m_A &#x3D; a;</span><br><span class="line">&#x2F;&#x2F;m_B &#x3D; b;</span><br><span class="line">&#x2F;&#x2F;m_C &#x3D; c;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化列表方式初始化</span><br><span class="line">Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br><span class="line">void PrintPerson() &#123;</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int m_A;</span><br><span class="line">int m_B;</span><br><span class="line">int m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">Person p(1, 2, 3);</span><br><span class="line">p.PrintPerson();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Phone</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Phone(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName &#x3D; name;</span><br><span class="line">cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Phone()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化列表可以告诉编译器调用哪一个构造函数</span><br><span class="line">Person(string name, string pName) :m_Name(name), m_Phone(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void playGame()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;当类中成员是其他类对象时，我们称该成员为 对象成员</span><br><span class="line">&#x2F;&#x2F;构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span><br><span class="line">&#x2F;&#x2F;析构顺序与构造相反</span><br><span class="line">Person p(&quot;张三&quot; , &quot;苹果X&quot;);</span><br><span class="line">p.playGame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li> 所有对象共享同一份数据</li><li> 在编译阶段分配内存</li><li> 类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li> 所有对象共享同一个函数</li><li> 静态成员函数只能访问静态成员变量</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">static int m_A; &#x2F;&#x2F;静态成员变量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态成员变量特点：</span><br><span class="line">&#x2F;&#x2F;1 在编译阶段分配内存</span><br><span class="line">&#x2F;&#x2F;2 类内声明，类外初始化</span><br><span class="line">&#x2F;&#x2F;3 所有对象共享同一份数据</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">static int m_B; &#x2F;&#x2F;静态成员变量也是有访问权限的</span><br><span class="line">&#125;;</span><br><span class="line">int Person::m_A &#x3D; 10;</span><br><span class="line">int Person::m_B &#x3D; 10;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;静态成员变量两种访问方式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1、通过对象</span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A &#x3D; 100;</span><br><span class="line">cout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A &#x3D; 200;</span><br><span class="line">cout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl; &#x2F;&#x2F;共享同一份数据</span><br><span class="line">cout &lt;&lt; &quot;p2.m_A &#x3D; &quot; &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、通过类名</span><br><span class="line">cout &lt;&lt; &quot;m_A &#x3D; &quot; &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;m_B &#x3D; &quot; &lt;&lt; Person::m_B &lt;&lt; endl; &#x2F;&#x2F;私有权限访问不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态成员函数特点：</span><br><span class="line">&#x2F;&#x2F;1 程序共享一个函数</span><br><span class="line">&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量</span><br><span class="line">static void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;</span><br><span class="line">m_A &#x3D; 100;</span><br><span class="line">&#x2F;&#x2F;m_B &#x3D; 100; &#x2F;&#x2F;错误，不可以访问非静态成员变量</span><br><span class="line">&#125;</span><br><span class="line">static int m_A; &#x2F;&#x2F;静态成员变量</span><br><span class="line">int m_B; &#x2F;&#x2F; </span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态成员函数也是有访问权限的</span><br><span class="line">static void func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Person::m_A &#x3D; 10;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;静态成员变量两种访问方式</span><br><span class="line">&#x2F;&#x2F;1、通过对象</span><br><span class="line">Person p1;</span><br><span class="line">p1.func();</span><br><span class="line">&#x2F;&#x2F;2、通过类名</span><br><span class="line">Person::func();</span><br><span class="line">&#x2F;&#x2F;Person::func2(); &#x2F;&#x2F;私有权限访问不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;</span><br><span class="line">mA &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;非静态成员变量占对象空间</span><br><span class="line">int mA;</span><br><span class="line">&#x2F;&#x2F;静态成员变量不占对象空间</span><br><span class="line">static int mB; </span><br><span class="line">&#x2F;&#x2F;函数也不占对象空间，所有函数共享一个函数实例</span><br><span class="line">void func() &#123;</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;静态成员函数也不占对象空间</span><br><span class="line">static void sfunc() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">cout &lt;&lt; sizeof(Person) &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li> 当形参和成员变量同名时，可用this指针来区分</li><li> 在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Person(int age)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;1、当形参和成员变量同名时，可用this指针来区分</span><br><span class="line">this-&gt;age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp; PersonAddPerson(Person p)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;age +&#x3D; p.age;</span><br><span class="line">&#x2F;&#x2F;返回对象本身</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(10);</span><br><span class="line">cout &lt;&lt; &quot;p1.age &#x3D; &quot; &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2(10);</span><br><span class="line">p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);</span><br><span class="line">cout &lt;&lt; &quot;p2.age &#x3D; &quot; &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;空指针访问成员函数</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">void ShowClassName() &#123;</span><br><span class="line">cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void ShowPerson() &#123;</span><br><span class="line">if (this &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person * p &#x3D; NULL;</span><br><span class="line">p-&gt;ShowClassName(); &#x2F;&#x2F;空指针，可以调用成员函数</span><br><span class="line">p-&gt;ShowPerson();  &#x2F;&#x2F;但是如果成员函数中用到了this指针，就不可以了</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;</span><br><span class="line">m_A &#x3D; 0;</span><br><span class="line">m_B &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;this指针的本质是一个指针常量，指针的指向不可修改</span><br><span class="line">&#x2F;&#x2F;如果想让指针指向的值也不可以修改，需要声明常函数</span><br><span class="line">void ShowPerson() const &#123;</span><br><span class="line">&#x2F;&#x2F;const Type* const pointer;</span><br><span class="line">&#x2F;&#x2F;this &#x3D; NULL; &#x2F;&#x2F;不能修改指针的指向 Person* const this;</span><br><span class="line">&#x2F;&#x2F;this-&gt;mA &#x3D; 100; &#x2F;&#x2F;但是this指针指向的对象的数据是可以修改的</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span><br><span class="line">this-&gt;m_B &#x3D; 100;</span><br><span class="line">&#125;</span><br><span class="line">void MyFunc() const &#123;</span><br><span class="line">&#x2F;&#x2F;mA &#x3D; 10000;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">mutable int m_B; &#x2F;&#x2F;可修改 可变的</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;const修饰对象  常对象</span><br><span class="line">void test01() &#123;</span><br><span class="line">const Person person; &#x2F;&#x2F;常量对象  </span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;person.mA &#x3D; 100; &#x2F;&#x2F;常对象不能修改成员变量的值,但是可以访问</span><br><span class="line">person.m_B &#x3D; 100; &#x2F;&#x2F;但是常对象可以修改mutable修饰成员变量</span><br><span class="line">&#x2F;&#x2F;常对象访问成员函数</span><br><span class="line">person.MyFunc(); &#x2F;&#x2F;常对象不能调用const的函数</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>来源：黑马程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h4 id=&quot;构造函数和析构函数&quot;&gt;&lt;a href=&quot;#构造函数和析构函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数和析构函数&quot;&gt;&lt;/a&gt;构造函数和析构函数&lt;/h4</summary>
      
    
    
    
    
    <category term="C++" scheme="https://www.chenzhan.club/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>note42.7-OpenOCD、JTAG</title>
    <link href="https://www.chenzhan.club/2021/07/05/note42-7-OpenOCD%E3%80%81JTAG/"/>
    <id>https://www.chenzhan.club/2021/07/05/note42-7-OpenOCD%E3%80%81JTAG/</id>
    <published>2021-07-05T02:36:41.000Z</published>
    <updated>2021-07-19T08:31:15.395Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>OpenOCD（Open On-Chip Debugger）开源片上调试器，是一款开源软件</p><p>OpenOCD旨在提供针对嵌入式设备的调试、系统编程和边界扫描功能</p><blockquote><p>边界扫描（Boundary Scan）测试发展于上个世纪90年代，随着大规模集成电路的出现，印制电路板制造工艺向小，微，薄发展，传统的ICT 测试已经没有办法满足这类产品的测试要求。由于芯片的引脚多，元器件体积小，板的密度特别大，根本没有办法进行下探针测试。一种新的测试技术产生了，联合测试行为组织（Joint Test Action Group）简称JTAG 定义这种新的测试方法即边界扫描测试。所有复杂的 IC 芯片几乎都具有JTAG控制接口，JTAG控制逻辑简单方便，易于实现。</p></blockquote><p>JTAG支持调试和边界扫描。</p><p>SWD（Serial Wire Debug）信号与一些比较新的ARM芯片进行通讯，而且还可以作为那些同时支持JTAG和SWD的芯片的仿真器。不过SWD仅支持调试，不支持边检扫描。</p><p><strong>加密狗</strong>：OpenOCD目前支持多种类型的硬件加密狗：基于USB的，基于并行端口的，以及其他在内部运行OpenOCD的独立盒子。</p><p><strong>GDB调试</strong>：它允许ARM7（ARM7TDMI和ARM720t），ARM9（ARM920T，ARM922T，ARM926EJ-S，ARM966E-S），XScale（PXA25x，IXP42x），Cortex-M3（Stellaris LM3，ST STM32和Energy Micro EFM32）和基于Intel Quark（x10xx）的内核使用GDB协议进行调试。</p><p><strong>Flash编程</strong>：擦写FLASH支持外部CFI兼容NOR闪存（Intel和AMD / Spansion命令集）和几个内部闪存（LPC1700，LPC1800，LPC2000，LPC4300，AT91SAM7，AT91SAM3U，STR7x，STR9x，LM3，STM32x和EFM32）。包括各种NAND闪存控制器（LPC3180，Orion，S3C24xx等）的初步支持。</p><h4 id="OpenOCD-在启动时做了些什么"><a href="#OpenOCD-在启动时做了些什么" class="headerlink" title="OpenOCD 在启动时做了些什么"></a>OpenOCD 在启动时做了些什么</h4><p>OpenOCD首先处理命令行上提供的配置命令，如果没有 <code>-c</code> 或 <code>-f</code> 的命令，OpenOCD会处理名为 <code>openocd.cfg</code> 文件中的命令。可以查看[Configuration Stage]章节的介绍。在配置阶段最后，OpenOCD会使用配置好的命令参数验证JTAG扫描链，所以要确保配置正确。通常OpenOCD会作为server一直运行。OpenOCD的命令也可以作为提前终止配置阶段，执行其它工作（如烧写flash），此时不会作为server一直运行，工作任务结束后会自动关闭。</p><hr><p>[1]知乎-Tomato-跟我一起学OpenOCD(一)</p><p>[2]百度百科-边界扫描</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;OpenOCD（Open On-Chip Debugger）开源片上调试器，是一款开源软件&lt;/p&gt;
&lt;p&gt;OpenOCD旨在提供针对嵌入式设备的调试、系统编程和边界扫描功能&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="其他" scheme="https://www.chenzhan.club/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>note41.6-内存管理进程映射(暂空)</title>
    <link href="https://www.chenzhan.club/2021/05/30/note41-6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%B0%84(%E6%9A%82%E7%A9%BA)/"/>
    <id>https://www.chenzhan.club/2021/05/30/note41-6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%B0%84(%E6%9A%82%E7%A9%BA)/</id>
    <published>2021-05-30T14:01:06.000Z</published>
    <updated>2021-07-19T08:31:30.187Z</updated>
    
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note40.6-LinuxC一些基础</title>
    <link href="https://www.chenzhan.club/2021/05/07/note40-6-UnixC%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.chenzhan.club/2021/05/07/note40-6-UnixC%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-07T14:24:16.000Z</published>
    <updated>2021-07-19T08:32:15.359Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><ul><li><p>#ifndef是”if not defined”的简写，是宏定义的一种，可以根据是否已经定义了一个变量来进行分支选择，一般用于调试等</p><p> 作用1：防止头文件的重复包含和编译</p><p> 作用2：便于程序的调试和移植</p><p> 配套使用：#endif</p><p> 类型：宏定义条件编译</p></li><li><p>#endif用于结束条件编译，编译时与前面最近的#if、#ifdef或#ifndef作为一对，经常一起使用，编译两者之间的部分程序段</p></li><li><p>bit[5:3]：bit5、bit4、bit3</p></li><li><p>构建过程：源代码(.c)-预编译-&gt;头文件和宏扩展-编译-&gt;汇编码(.s)-汇编-&gt;目标码(.o)-链接-&gt;可执行代码(a.out)</p><ul><li>vi hello.c - 编写源代码<br>gcc -E hello.c -o hello.i - 预编译(编译预处理)<br>gcc -S hello.i - 获得汇编代码(hello.s)<br>gcc -c hello.s - 获得目标代码(hello.o)<br>gcc hello.o -o hello - 获得可执行代码(hello)<br>./hello - 运行可执行代码</li></ul></li><li><p>文件名后缀</p><ul><li>.h - C语言源代码头文件                  <br>.c - 预处理前的C语言源代码文件      &gt; 可读文本<br>.s - 汇编语言文件                            /<br>.o - 目标文件                                   <br>.a - 静态库文件                                 &gt; 不可读的二进制<br>.so - 共享(动态)库文件                     /<br>.out - 可执行文件                           /</li></ul></li><li><p>编译选项</p><ul><li>gcc [选项] [参数] 文件1 文件2 …<br>-o: 指定输出文件<pre><code>    如：gcc hello.c -o hello</code></pre>-E: 预编译，缺省输出到屏幕，用-o指定输出文件<pre><code>    如：gcc -E hello.c -o hello.i</code></pre>-S: 编译，将高级语言文件编译成汇编语言文件<pre><code>    如：gcc -S hello.c</code></pre>-c: 汇编，将汇编语言文件汇编成机器语言文件<pre><code>    如：gcc -c hello.s</code></pre>-Wall：产生全部警告<pre><code>    如：gcc -Wall wall.c</code></pre>-Werror：将警告作为错误处理<pre><code>    如：gcc -Werror werror.c</code></pre>-x: 指定源代码的语言<pre><code>    xxx.c - C语言    xxx.cpp - C++语言    xxx.for - Fortran语言    xxx.java - Java语言    ...    gcc -x c++ cpp.c -lstdc++ -o cpp</code></pre>-O0/O1/O2/O3: 指定优化等级，O0不优化，缺省O1优化</li></ul></li><li><p>外部变量声明<br>extern double e</p></li><li><p>重定义<br>一个头文件可能会被多个源文件包含，写在头文件里的函数定义也会因此被预处理器扩展到多个包含该头文件的源文件中，并在编译阶段被编译到等多个不同的目标文件中，这将导致链接错误：multiple definition，多重定义</p></li><li><p>gcc -I&lt;头文件的附加搜索路径&gt;</p><ul><li>#include &lt;my.h&gt;<br>先找-I指定的目录，再找系统目录。</li><li>#include “my.h”<br>先找-I指定的目录，再找当前目录，最后找系统目录。</li></ul></li><li><p>头文件的系统目录：<br>/usr/include - 标准C库<br>/usr/local/include - 第三方库<br>/usr/lib/gcc/i686-linux-gnu/5.4.0/include - 编译器库</p></li><li><p>预处理指令<br>#include - 将指定的文件内容插至此指令处<br>#define - 定义宏<br>#undef - 删除宏<br>#if - 如果<br>#ifdef - 如果宏已定义<br>#ifndef - 如果宏未定义<br>#else - 否则，与#if/#ifdef/#ifndef配合使用<br>#elif - 否则如果，与#if/#ifdef/#ifndef配合使用<br>#endif - 结束判定，与#if/#ifdef/#ifndef配合使用<br>#error - 产生错误，结束预处理<br>#warning - 产生警告，继续预处理</p><p>#line - 指定行号<br>#pragma - 设定编译器的状态或者指示编译器的操作<br>#pragma GCC dependency 被依赖文件<br>#pragma GCC poison 语法禁忌<br>#pragma pack(按几字节对齐：1/2/4/8)<br>#pragma pack() - 按缺省字节数对齐</p></li><li><p>预定义宏<br>无需自行定义，预处理器会根据事先设定好的规则将这些宏扩展成其对应的值。<br>__ BASE_FILE__ : 正在被处理的源文件名<br>__ FILE__ : 所在文件名<br>__ LINE__ : 所在行的行号<br>__ FUNCTION__ : 所在函数的函数名<br>__ func__ : 同__ FUNCTION __<br>__ DATE__ : 处理日期<br>__ TIME__ : 处理时间<br>__ INCLUDE_LEVEL__ : 包含层数，从0开始<br>__cplusplus: C++有定义，C无定义</p></li><li><p>环境变量<br>在进程向下文中保存的一些数据：键(功能，是什么)=值(内容)。<br>env<br>C_INCLUDE_PATH<br>C语言头文件的附加搜索路径，相当于-I选项。<br>CPATH<br>同C_INCLUDE_PATH<br>CPLUS_INCLUDE_PATH<br>C++语言头文件的附加搜索路径，相当于-I选项。<br>LIBRARY_PATH<br>链接库路径<br>LD_LIBRARY_PATH<br>加载库路径<br>#include “/…/…/xxx.h” - 移植性差<br>#include “xxx.h”<br>gcc -I/…/… … - 推荐<br>C_INCLUDE_PATH/CPATH=/…/…:/… - 易冲突</p></li><li><p>库<br>a.c -&gt; a.out<br>单一模型：将程序中所有功能全部实现于一个单一的源文件内部。编译时间长，不易于维护和升级，不易于协作开发。<br>分离模型：将程序中的不同功能模块划分到不同的源文件中。缩短编译时间，易于维护和升级，易于协作开发。<br>a.o <br>b.o   | -&gt; 库 + 其它模块 -&gt; …<br>c.o   |<br>…    /</p></li><li><p>静态库<br>静态库的本质就是将多个目标文件打包成一个文件。<br>链接静态库就是将库中被调用的代码复制到调用模块中。<br>使用静态库的程序通常会占用较大的空间，库中代码一旦修改，所有使用该库的程序必须重新链接。<br>使用静态库的程序在运行无需依赖库，其执行效率高。<br>静态库的形式：libxxx.a<br>构建静态库：<br>.c -&gt; .o -&gt; .a<br>ar -r libxxx.a x.o y.o z.o<br>使用静态库：<br>gcc … -lxxx -L&lt;库路径&gt;<br>export LIBRARY_PATH=&lt;库路径&gt;<br>gcc … -lxxx</p></li><li><p>动态(共享)库<br>动态库和静态库最大的不同就是，链接动态库并不需要将库中被调用的代码复制到调用模块中，相反被嵌入到调用模块中的仅仅是被调用代码在动态库中的相对地址。<br>如果动态库中的代码同时为多个进程所用，动态库的实例在整个内存空间中仅需一份，因此动态库也叫共享库或共享对象(Shared Object, so)。<br>使用动态库的模块所占空间较小，即使修改了库中的代码，只要接口保持不变，无需重新链接。<br>使用动态库的代码在运行时需要依赖库，执行效率略低。<br>动态库的形式：libxxx.so<br>构建动态库：<br>gcc -c -fpic xxx.c -&gt; xxx.o</p><pre><code>           |</code></pre><p>   生成位置无关码<br>库内部的函数调用也用相对地址表示<br>gcc -shared -o libxxx.so x.o y.o z.o<br>使用动态库：<br>gcc … -lxxx -L&lt;库路径&gt;<br>export LIBRARY_PATH=&lt;库路径&gt;<br>gcc … -lxxx<br>运行时所调用的动态库必须位于LD_LIBRARY_PATH环境变量所表示的路径中。<br>gcc缺省链接共享库，可通过-static选项强制链接静态库。</p></li><li><p>动态加载动态库<br>#include &lt;dlfcn.h&gt; \ 系统提供的针对动态<br>-ldl                             / 库的动态加载函数集<br>void* dlopen(const char* filename, int flag);</p><p>成功返回动态库的句柄，失败返回NULL。</p><p>FILE* fp = fopen(…);<br>fread(fp…);</p><p>fwrite(fp…);</p><p>filename - 动态库路径，若只给文件名，则根据LD_LIBRARY_PATH环境变量搜索动态库<br>flag - 加载方式，可取以下值：<br>RTLD_LAZY - 延迟加载，使用动态中的符号时才加载<br>RTLD_NOW - 立即加载<br>该函数所返回的动态库句柄唯一地标识了系统内核所维护的动态库对象，将作为后续函数调用的参数。<br>void* dlsym(void* handle, const char* symbol);<br>成功返回函数地址，失败返回NULL。<br>handle - 动态库句柄<br>symbol - 符号(函数或全局变量)名<br>该函数所返回的函数指针是void * 类型，需要强制类型转换为实际的函数指针类型才能调用。<br>int dlclose(void* handle);<br>成功返回0，失败返回非零。<br>handle - 动态库句柄<br>char* dlerror(void);<br>之前若有错误发生则返回错误信息字符串，否则返回NULL。</p></li><li><p>辅助工具<br>1.查看符号表：nm<br>列出目标文件(.o)、可执行文件、静态库文件(.a)或动态库文件(.so)中的符号<br>代码：nm.c<br>2.显示二进制模块的反汇编信息：objdump -S<br>3.删除目标文件(.o)、可执行文件、静态库文件(.a)或动态库文件(.so)中的符号表和调试信息：strip<br>4.查看可执行程序文件或动态库文件所依赖的动态库文件：ldd</p></li><li><p>错误号和错误信息<br>1.通过函数的返回值表达错误<br>返回整数的函数：通过返回合法值域以外的值表示错误<br>int age(char const* name) {</p><pre><code>...return 1000;</code></pre><p>}<br>返回指针的函数：通过返回NULL指针表示错误<br>不需要通过返回值输出信息的函数：返回0表示成功，返回-1表示失败。<br>int delete(char const* filename) {</p><pre><code>...return 0;...return -1;</code></pre><p>}</p></li><li><p>通过错误号和错误信息表示产生错误的具体原因<br>#include &lt;errno.h&gt;<br>全局变量：errno，整数，标识最近一次系统调用的错误<br>#include &lt;string.h&gt;<br>char* strerror(int errnum); // 根据错误号返回错误信息<br>#include &lt;stdio.h&gt;<br>void perror(const char* s); // 打印最近错误的错误信息<br>printf函数的%m标记被替换为最近错误的错误信息<br>代码：errno.c<br>虽然所有的错误号都不是0，但是因为在函数执行成功的情况下错误号全局变量errno不会被清0，因此不能用errno是否为0作为函数成功失败的判断条件，是否出错还是应该根据函数的返回值来决定。<br>返回值 = 函数调用(…);<br>if (返回值表示函数调用失败) {</p><pre><code>根据errno判断发生了什么错误针对不同的错误提供不同的处理</code></pre><p>}</p></li><li><p>环境变量<br>每个进程都有一张独立的环境变量表，其中的每个条目都是一个形如“键=值”形式的环境变量。<br>env<br>全局变量：environ，需要自己在代码做外部声明。<br>environ-&gt;|    *    |-&gt;AAA=aaa\0</p><pre><code>              |    *    |-&gt;BBB=bbb\0              |    *    |-&gt;CCC=ccc\0              |NULL|</code></pre><p>所谓环境变量表就是一个以NULL指针结束的字符指针数组，其中的每个元素都是一个字符指针，指向一个以空字符结尾的字符串，该字符串就是形如”键=值”形式的环境变量。<br>argv-&gt; *      *      *     NULL</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>​          a.out  -c    b.c</td><td></td></tr><tr><td>根据环境变量名获取其值</td><td></td></tr><tr><td>char* getenv(char const* name);</td><td></td></tr><tr><td>成功返回变量名匹配的变量值，失败返回NULL。</td><td></td></tr><tr><td>name - 环境变量名，即等号左边的部分</td><td></td></tr><tr><td>添加或修改环境变量</td><td></td></tr><tr><td>int putenv(char* string);</td><td></td></tr><tr><td>成功返回0，失败返回-1。</td><td></td></tr><tr><td>string - 形如“键=值”形式的环境变量字符串</td><td></td></tr><tr><td>若其键已存在，则修改其中，若其键不存在，则添加新变量</td><td></td></tr><tr><td>添加或修改环境变量</td><td></td></tr><tr><td>int setenv(const char* name, const char* value,</td><td></td></tr><tr><td>​    int overwrite);</td><td></td></tr><tr><td>成功返回0，失败返回-1。</td><td></td></tr><tr><td>name - 环境变量名，即等号左边的部分</td><td></td></tr><tr><td>value - 环境变量值，即等号右边的部分</td><td></td></tr><tr><td>overwrite - 当name参数所表示的环境变量名已存在，此参数取0则保持该变量的原值不变，若此参数取非0，则将该变量的值修改为value。</td><td></td></tr><tr><td>删除环境变量</td><td></td></tr><tr><td>int unsetenv(const char* name);</td><td></td></tr><tr><td>成功返回0，失败返回-1。</td><td></td></tr><tr><td>name - 环境变量名，即等号左边的部分</td><td></td></tr><tr><td>清空环境变量</td><td></td></tr><tr><td>int clearenv(void);</td><td></td></tr><tr><td>成功返回0，失败返回-1。</td><td></td></tr></tbody></table></li><li><p>内存<br>1.虚拟内存、物理内存、半导体内存和换页文件<br>虚拟内存：地址空间，虚拟的存储区域，应用程序所访问的都是虚拟内存。<br>物理内存：存储空间，实际的存储区域，只有系统内核可以访问物理内存。<br>虚拟内存和物理内存之间存在对应关系，当应用程序访问虚拟内存时，系统内核会依据这种对应关系找到与之相应的物理内存。上述对应关系存储在内核中的内存映射表中。<br>物理内存包括半导体内存和换页文件两部分。<br>当半导体内存不够用时，可以把一些长期闲置的代码和数据从半导体内存中缓存到换页文件中，这叫页面换出，一旦需要使用被换出的代码和数据，再把它们从换页文件恢复到半导体内存中，这叫页面换入。因此，系统中的虚拟内存比半导体内存大得多。</p><ol start="2"><li>进程映射(Process Maps)<br>每个进程都拥有独立的4G字节的虚拟内存，分别被映射到不同的物理内存区域。<br>内存映射和换入换出都是以页为单位，1页=4096字节。<br>4G虚拟内存中高地址的1G被映射到内核的代码和数据区，这1个G在各个进程间共享。用户的应用程序只能直接访问低地址的3个G虚拟内存，因此该区域被称为用户空间，而高地址的1个G虚拟内存则被称为内核空间。用户空间中的代码只能直接访问用户空间的数据，如果要想访问内核空间中的代码和数据必须借助专门的系统调用完成。<br>用户空间的3G虚拟内存可以进一步被划分为如下区域：<pre><code>   ------------------      系统内核(1G)</code></pre>高地址——————<pre><code>        命令行参数        和环境变量   ------------------              栈区：非静态局部变量   -  -  -  -  -  -  -  -                v</code></pre> 3G<pre><code>                ^   -  -  -  -  -  -  -  -             堆区：动态内存分配(malloc函数族)   -----------------           BSS区：无初值的全局和静态局部变量   -----------------           数据区：非const型有初值的全局和静态局部变量   -----------------        只读常量：字面值常量，const型有初值的全局                         和静态局部变量    代码区(正文段)：可执行指令</code></pre>低地址—————–</li></ol></li></ul><hr><p>参考资料：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;#ifndef是”if not defined”的简写，是宏定义的一种，可以根据是否已经定义了一个变量来进行分支选择，一般用于调试等&lt;/p&gt;
&lt;p&gt; 作用1：防止头</summary>
      
    
    
    
    
    <category term="LinuxC" scheme="https://www.chenzhan.club/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>note39.5-platform设备</title>
    <link href="https://www.chenzhan.club/2021/05/05/note39-5-platform%E8%AE%BE%E5%A4%87/"/>
    <id>https://www.chenzhan.club/2021/05/05/note39-5-platform%E8%AE%BE%E5%A4%87/</id>
    <published>2021-05-05T07:29:57.000Z</published>
    <updated>2021-07-19T08:35:15.276Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Linux-驱动的分离与分层"><a href="#Linux-驱动的分离与分层" class="headerlink" title="Linux 驱动的分离与分层"></a><strong>Linux</strong> <strong>驱动的分离与分层</strong></h2><h3 id="驱动的分隔与分离"><a href="#驱动的分隔与分离" class="headerlink" title="驱动的分隔与分离"></a><strong>驱动的分隔与分离</strong></h3><ul><li>网络的 7 层模型：7 应用层6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1物理层</li><li>Linux系统内核使用bus_type结构体表示总线，此结构体定义在文include/linux/device.h</li><li>platform_driver 驱动和 platform_device设备</li><li>match 函数是完成设备和驱动之间匹配的（总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数）</li><li>platform 总线是 bus_type 的一个具体实例，定义在文件 drivers/base/platform.c</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">platform 总线实例</span><br><span class="line"></span><br><span class="line">1 struct bus_type platform_bus_type &#x3D; &#123; </span><br><span class="line">2 .name &#x3D; &quot;platform&quot;, </span><br><span class="line">3 .dev_groups &#x3D; platform_dev_groups, </span><br><span class="line">4 .match &#x3D; platform_match, </span><br><span class="line">5 .uevent &#x3D; platform_uevent, </span><br><span class="line">6 .pm &#x3D; &amp;platform_dev_pm_ops, </span><br><span class="line">7 &#125;;</span><br></pre></td></tr></table></figure><ul><li>匹配函数 platform_match 函数定义在文件 drivers/base/platform.c</li><li>驱动和设备有四种匹配写法<ul><li>OF 类型即设备树的匹配（of_driver_match_device 函数定义在文件 include/linux/of_device.h）<ul><li>device_driver 结构体(表示设备驱动)中 of_match_table 成员变量，保存着驱动的compatible匹配表，设备树中的每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较，查看是否有相同的条目，如果有表示设备和此驱动匹配，设备和驱动匹配成功后 probe 函数执行</li></ul></li><li>ACPI 匹配方式</li><li>id_table 匹配<ul><li>platform_driver 结构体有 id_table成员变量，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱动类型</li></ul></li><li>如果第三种匹配方式的 id_table 不存在的话就直接比较驱动和设备的 name 字段，如果相等的话就匹配成功</li><li>一般用的最多的还是直接比较驱动和设备的 name 字段</li></ul></li></ul><h4 id="platform-驱动"><a href="#platform-驱动" class="headerlink" title="platform 驱动"></a><strong>platform</strong> <strong>驱动</strong></h4><ul><li>platform_driver 结 构 体 表 示 platform 驱动，此结构体定义在文件include/linux/platform_device.h<ul><li>当驱动与设备匹配成功以后 probe 函数就会执行</li><li>device_driver 相当于基类，提供最基础的驱动框架。plaform_driver 继承了这个基类</li><li>id_table 是个表(也就是数组)，每个元素的类型为 platform_device_id</li></ul></li><li>device_driver 结构体定义在 include/linux/device.h</li><li>of_match_table 是采用设备树驱动使用的匹配表，数组，匹配项为 of_device_id 结构体类型，定义在文件 include/linux/mod_devicetable.h </li></ul><blockquote><p>在编写 platform 驱动的时候，首先定义一个 platform_driver 结构体变量，然后实现结构体中的各个成员变量，重点是实现匹配方法以及 probe 函数。当驱动和设备匹配成功以后 probe函数就会执行，具体的驱动程序在 probe 函数里面编写，比如字符设备驱动等等</p></blockquote><p>定义并初始化好 platform_driver 结构体变量后，需要在驱动入口函数里面调用platform_driver_register 函数向 Linux 内核注册一个 platform 驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int platform_driver_register (struct platform_driver *driver)</span><br><span class="line">driver：要注册的 platform 驱动。</span><br><span class="line">返回值：负数，失败；0，成功</span><br></pre></td></tr></table></figure><p>在驱动卸载函数中通过 platform_driver_unregister 函数卸载 platform 驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void platform_driver_unregister(struct platform_driver *drv)</span><br><span class="line">drv：要卸载的 platform 驱动。</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure><h4 id="platform-设备"><a href="#platform-设备" class="headerlink" title="platform 设备"></a><strong>platform</strong> <strong>设备</strong></h4><ul><li>platform_device 这个结构体表示 platform 设备</li><li>platform_device 结构体定义在文件include/linux/platform_device.h</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">platform_device 结构体代码段</span><br><span class="line"></span><br><span class="line">22 struct platform_device &#123;</span><br><span class="line">23 const char *name; </span><br><span class="line">24 int id; </span><br><span class="line">25 bool id_auto;</span><br><span class="line">26 struct device dev;</span><br><span class="line">27 u32 num_resources; </span><br><span class="line">28 struct resource *resource;</span><br><span class="line">29</span><br><span class="line">30 const struct platform_device_id *id_entry;</span><br><span class="line">31 char *driver_override; &#x2F;* Driver name to force a match *&#x2F;</span><br><span class="line">32</span><br><span class="line">33 &#x2F;* MFD cell pointer *&#x2F;</span><br><span class="line">34 struct mfd_cell *mfd_cell;</span><br><span class="line">35</span><br><span class="line">36 &#x2F;* arch specific additions *&#x2F;</span><br><span class="line">37 struct pdev_archdata archdata;</span><br><span class="line">38 &#125;;</span><br></pre></td></tr></table></figure><p>name 表示设备名字，要和所使用的 platform 驱动的 name 字段相同</p><p>num_resources 表示资源数量，为 resource 资源的大小</p><p>resource设备信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource 结构体代码段</span><br><span class="line"></span><br><span class="line">18 struct resource &#123;</span><br><span class="line">19 resource_size_t start;</span><br><span class="line">20 resource_size_t end;</span><br><span class="line">21 const char *name;</span><br><span class="line">22 unsigned long flags;</span><br><span class="line">23 struct resource *parent, *sibling, *child;</span><br><span class="line">24 &#125;;</span><br></pre></td></tr></table></figure><p>start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址</p><p>name 表示资源名字，flags 表示资源类型</p><p>可选的资源类型都定义在了文件include/linux/ioport.h</p><ul><li>使用 platform_device_register 函数将设备信息注册到 Linux 内核中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int platform_device_register(struct platform_device *pdev)</span><br></pre></td></tr></table></figure><p>pdev：要注册的 platform 设备。</p><p>返回值：负数，失败；0，成功。</p><ul><li>通过 platform_device_unregister 函数注销掉相应的 platform设备</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void platform_device_unregister(struct platform_device *pdev)</span><br></pre></td></tr></table></figure><p>pdev：要注销的 platform 设备。</p><p>返回值：无。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>根文件系统中/sys/bus/platform/目录下保存着当前板子 platform 总线下的设备和驱动，其中devices 子目录为 platform 设备，drivers 子目录为 plartofm 驱动</p><h2 id="设备树下的-platform-驱动"><a href="#设备树下的-platform-驱动" class="headerlink" title="设备树下的 platform 驱动"></a><strong>设备树下的</strong> <strong>platform</strong> <strong>驱动</strong></h2><p>在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 不需要去编写，我们只需要实现 platform_driver 即可</p><h3 id="在设备树中创建设备节点"><a href="#在设备树中创建设备节点" class="headerlink" title="在设备树中创建设备节点"></a><strong>在设备树中创建设备节点</strong></h3><p>compatible 属性值为“atkalpha-gpioled”，因此在编写 platform驱动的时候 of_match_table 属性表中要有“atkalpha-gpioled”</p><h3 id="编写-platform-驱动的时候要注意兼容属性"><a href="#编写-platform-驱动的时候要注意兼容属性" class="headerlink" title="编写 platform 驱动的时候要注意兼容属性"></a><strong>编写</strong> <strong>platform</strong> <strong>驱动的时候要注意兼容属性</strong></h3><p>of_device_id 表，也就是驱动的兼容表，是一个数组，每个数组元素为 of_device_id类型。每个数组元素都是一个兼容属性，表示兼容的设备，一个驱动可以跟多个设备匹配</p><p>驱动中的 compatible 属性和设备中的 compatible 属性相匹配，因此驱动中对应的 probe 函数就会执行</p><p>在编写 of_device_id 的时候最后一个元素一定要为空！</p><h3 id="编写-platform-驱动"><a href="#编写-platform-驱动" class="headerlink" title="编写 platform 驱动"></a><strong>编写</strong> <strong>platform</strong> <strong>驱动</strong></h3><p>我们需要在 probe 函数里面执行字符设备驱动那一套，当注销驱动模块的时候 remove 函数就会执行</p><p>原来在驱动加载函数里面做的工作现在全部放到 probe 函数里面完成</p><p>原来驱动卸载函数里面的工作全部都放到 remove 函数中完成</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h2 id=&quot;Linux-驱动的分离与分层&quot;&gt;&lt;a href=&quot;#Linux-驱动的分离与分层&quot; class=&quot;headerlink&quot; title=&quot;Linux 驱动的分离与分层&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="驱动开发" scheme="https://www.chenzhan.club/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>note38.5-阻塞与非阻塞IO(暂空)</title>
    <link href="https://www.chenzhan.club/2021/04/27/note38-5-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO(%E6%9A%82%E7%A9%BA)/"/>
    <id>https://www.chenzhan.club/2021/04/27/note38-5-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO(%E6%9A%82%E7%A9%BA)/</id>
    <published>2021-04-27T14:04:36.000Z</published>
    <updated>2021-07-19T08:32:38.129Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>note37.5-按键</title>
    <link href="https://www.chenzhan.club/2021/04/23/note37-5-%E6%8C%89%E9%94%AE/"/>
    <id>https://www.chenzhan.club/2021/04/23/note37-5-%E6%8C%89%E9%94%AE/</id>
    <published>2021-04-23T12:45:47.000Z</published>
    <updated>2021-07-19T08:33:51.663Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><blockquote><p>实现按键输入，在驱动程序中使用一个整形变量来表示按键值，应用程序通过 read 函数来读取按键值，判断按键有没有按下。这个保存按键值的变量就是个共享资源，驱动程序要向其写入按键值，应用程序要读取按键值。所以我们要对其进行保护，对于整形变量而言我们首选的就是原子操作，使用原子操作对变量进行赋值以及读取</p></blockquote><h1 id="修改设备树文件"><a href="#修改设备树文件" class="headerlink" title="修改设备树文件"></a><strong>修改设备树文件</strong></h1><p><strong>添加 pinctrl 节点</strong></p><p>在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为“pinctrl_key”的子节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_key: keygrp &#123;</span><br><span class="line">fsl,pins &#x3D; &lt;</span><br><span class="line">MX6UL_PAD_UART1_CTS_B__GPIO1_IO18 0xF080 &#x2F;* KEY0 *&#x2F;</span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>添加 KEY 设备节点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">key &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">compatible &#x3D; &quot;atkalpha-key&quot;;</span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;pinctrl_key&gt;;</span><br><span class="line">key-gpio &#x3D; &lt;&amp;gpio1 18 GPIO_ACTIVE_LOW&gt;; &#x2F;* KEY0 *&#x2F;</span><br><span class="line">status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>检查</strong> <strong>PIN</strong> <strong>是否被其他外设使用</strong></p><p>先检查 PIN 为 UART1_CTS_B 这 个 PIN 有没有被其他的 pinctrl 节点使用，如果有使用的话就要屏蔽掉，然后再检查 GPIO1_IO18这个 GPIO 有没有被其他外设使用，如果有的话也要屏蔽掉</p><hr><p>参考资料：正点原子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;实现按键输入，在驱动程序中使用一个整形变量来表示按键值，应用程序通过 read 函数来读取按键值，判断按键有没有按下。这个保存按键值的变量就是个共享资源，驱</summary>
      
    
    
    
    
    <category term="驱动开发" scheme="https://www.chenzhan.club/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
